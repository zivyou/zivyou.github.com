[{"title":"learning big data","url":"/2025/06/19/learning-big-data/","content":"\n# 大数据领域发展time line\n1999: Doug Cutting编写了Lucene, 之后又引入了Nutch;\n2004: google发表了三篇论文:GFS, MapReduce, BigTable;\n2004: Doug Cutting读了google的论文后, 非常兴奋, 按照论文中的描述开始手搓GFS & MapReduce;\n2006: Doug Cutting从Nutch中拆出了大数据相关的功能, 组成了项目Hadoop; 初期的Hadoop主要有两大部分: HDFS & MapReduce;\n2007: Facebook开始基于开源的Hadoop开发Hive;\n2008: Hadoop成为Apache顶级项目;\n2008: Facebook将Hive贡献给Apache;\n2009: UCB开发了另一种思路的大数据分布式处理系统Spark;\n2012: Hadoop生态中的Yarn组件开始独立成为一个项目;\n2014: Spark成为Apache的顶级项目;\n","tags":["TECH"]},{"title":"macos docker全家桶坑","url":"/2025/05/28/macos-docker全家桶坑/","content":"\n# colima\n\n"},{"title":"or-tools","url":"/2025/02/09/or-tools/","content":"\n# INSTALL\nubuntu 22.04，直接导入cmake会缺少一些依赖：\n1. 缺少absl库\n`sudo apt install libabsl-dev` ~事实证明这样安装不行，这样安装会缺少cmake配置文件，后面有的库安装会找absl的cmake~所以只能通过源码自己编译、安装，唉，简直了；\n这里还是用checkinstall安装；\n\n\n2. 缺少protobuf\n`sudo apt install libprotobuf-dev`\n3. 缺少HIGHS库\n查了一下，这个是一个运筹学领域的线性优化求解器，官网： https://highs.dev/。简单看了一下官方推荐还是使用源码自编译安装；\n\n## 安装highs库\n下载源码后，cmake , make, make install这一套； 鉴于怕污染系统导致后面我的电脑软件管理混乱，这里直接上checkinstall来安装deb包了；\n\n4. 缺少SCIP库\n这个是一个Constraint Integer Programs问题求解器，官网https://www.scipopt.org/，提供了deb包供下载（太好了）\n\n5. 缺少re2::re2库\n这个库是google出品，主页：https://github.com/google/re2，看起来是一个C++的正则表达式库；\n可恶的是没有提供deb包，只能通过源码去安装；\n这里还是直接上checkinstall;\n## 安装re2::re2\n这个re2库依赖于absl::absl_check和absl::absl_log，这么搞下去估计要把google全家桶都安装上了；\n\n6. 缺少Coin::CbcSolver库\n主页https://github.com/coin-or/Cbc?tab=readme-ov-file，看起来也是一个整数域线性规划求解器。\n试了一下通过apt-get安装的方式： sudo apt-get install  coinor-cbc coinor-libcbc-dev，居然可以用（官方的安装包中有cmake配置项，所以or-tools的cmake可以找到依赖）。\n\n好了，至此可以编译or-tools了。\n","tags":["TECH"]},{"title":"NeRF","url":"/2024/02/18/NeRF/","content":"# NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis\n> NeRF: 用于视图合成的神经辐射场场景重建\n\n## 摘要\n\n我们提出了一种方法，可以达到目前业界最好的效果，用于合成新的复杂场景的视图，通过优化一个目标连续体积场景函数，这个函数使用一系列的稀疏视图作为输入。我们的算法使用一个全连通(非巻积)深度网络来重建场景，这个网络的输入是一个单个连续的5D坐标(包含位置信息(x,y,z)以及一个视图方向信息($\\theta, \\phi$))，其输出是特殊位置下的体积密度(volume density)以及视角相关的发射亮度。我们通过查询5D坐标和相机光线，同时使用经典的体积渲染技术来构建输出颜色和密度到一帧图像中，从而合成视图。由于体积渲染是一个自然可微分的过程，我们的重建过程要求的唯一输入是一系列已知相机位置的图片。我们在文中描述了如何有效的优化神经网络场来渲染出复杂形状和外表的效果逼真的场景图，并在文中演示了优于先前的神经渲染和视图合成工作的结果。感受综合结果最好的方式是观看视频，因此我们强烈建议读者观看我们提供的视频来感受令人信服的演示效果。"},{"title":"正态分布","url":"/2023/09/27/正态分布/","content":"# what \n概率密度:`$ f(x)=\\frac{1}{\\sigma \\sqrt{2 \\pi}} e^{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}} $`\n\n\n# why \n为什么正态分布如此广泛的存在于自然界?\n> 「正态」这个词翻译的感觉不太好，英文原意是normal，对应的应该是「常规」、「普遍」\n\n这个事实是由「中心极限定理」明确指出的;\n中心极限定理: 无论随机变量服从什么分布，我们随机采样后样本的均值会服从正态分布。\n\n之所以会如此广泛的存在于自然界，是因为我们去观测一个样本值的时候，这个样本值无论如何都会受到各种各样随机因素的干扰，这些干扰因素互相独立且相互叠加。\n如果我们的观测方式是取均值，那么本质上是样本值的加法，这样这些随机干扰因素是线性的叠加到我们的观测值中的，这样的观测方式下，我们样本的观测值就会体现出一定的规律。\n\n所以，总结一下的话，就是自然界中的干扰因素一般都是随机的，而我们的观测方法选取一般都会让这些干扰因素线性可叠加的体现到观测结果中，所以我们的观测结果很多都会成正态分布。\n\n# p.s.\n这个问题等价于「中心极限定理的证明问题」\n太难了，等以后搞明白了再补充。","tags":["math"]},{"title":"分布式算法导论","url":"/2023/01/29/分布式算法导论/","content":"\n# 前言\n## 分布式系统的定义\n分布式系统是一系列节点(node)互连的集合。而节点(node)指的是:自主计算机、进程或者处理器等等。自主性是说node必须要配备自己专用的控制单元。互连是说node之间必须能够交换信息。\n这个定义还不够完备，Tanenbaum在此基础之上又补充了一条:系统中的自主性node必须对使用者是透明的。\n\n提出分布式系统的目的:\n- 信息交换;\n- 资源共享;\n- 通过备份提高可靠性;\n- 通过并行化提高性能;\n- 通过规范简化设计;\n\n分布式系统的应用领域:\n- 计算机网络(广域网、局域网)\n- 多处理器计算机\n\n分布式系统领域的学术会议/期刊:\n- Principles of Distributed Computing(PoDC), ACM会议\n- International Workshops on Distributed Algorithm(WDAG), Springer期刊\n- Distributed Computing(DISC), ACM会议\n- Foundation of Computer Science(FoCS), IEEE会议\n- Journal of Parallel and Distributed Computing(JPDC), 期刊\n\n本书的内容主要是3个话题:\n1. 协议;\n2. 基本算法;\n3. 容错;\n\n# 协议\n## 分布式系统的数学模型\n### 转移系统的数学形式化定义\n分布式计算: 一组离散事件的集合，每个事件在全局状态中都是一个原子元素。因此分布式系统可以定义成一个转移系统。\n转移系统(Transition System)的数学形式定义:\n> 转移系统由一个三元组定义: S = (C, ->, I),其中C是配置集合(所有全局状态的集合)，->是C中的二元转移操作，I是初始配置，I是C的一个子集。\n显然，转移操作->是C×C的一个子集。\n在这个数学形式系统下，这个分布式系统的一次执行过程可以用: 一个序列`$E=(r0, r1, r2, ...)$`,r0属于I, ri -> ri+1 属于->。\n\n### 异步消息系统的数学形式化定义\n分布式系统由进程集和通信子系统组成。每个进程自身是一个转移系统，而且这个转移系统可以和通信子系统交互。在进程中，我们用「事件」和「状态」来描述进程的属性。\n","tags":["books"]},{"title":"物理内存的管理","url":"/2022/11/22/物理内存的管理/","content":"> 只针对x86-32架构的机器。目前只懂这个。\n\n# 实模式下的物理内存\n实模式下的一开始的640KB物理内存分配给了BIOS，后面640K-1M的空间依次给了一些给显示器和硬件接口。\n可见一开始的实模式下，CPU可以使用的物理内存空间为1M。\n## BIOS\n1. CPU在通电后，默认是去读取0xFFFF0(1023K+1008B = 1M - 4B)这个地方的内存内容，并将其当作代码来执行。而0xFFFF0这个地方的内容是ROM-BIOS中的地址。也就是说，CPU在实模式下，大于1\n   M的地址，是不会从RAM中去找的，而是找到了ROM中。\n2. 0 - 0x3FF(1K-1B) : BIOS将自己的中断向量表拷贝到[0, 1K)的这个地址范围内，也就是说，内存刚上电初始化时，其开始的地址会被BIOS改写成BIOS的中断向量表；\n3. 0x400(1K) - 0x4FF(2K-1B): BIOS存储自己的数据的地方，[1K, 2k)\n4. 0x7C00(31K) - 0x7DFF(31K+511B): [31K, 31K+512B)BIOS会将启动磁盘的第一个扇区（这个扇区共512B）的内容拷贝到内存的0x7C00(31K)处；\n\n## 显示器\n1. 0xA0000(640K) - 0xAFFFF(704k-1B): [640K, 704K): 彩色显示器的内存映射；\n2. 0xB0000(704K) - 0xB7FFF(736K-1B): [704K, 736): 黑白显示器的内存映射；\n3. 0xB8000(736K) - 0xBFFFF(768K-1B): [736K, 768K): 文本模式显示器；\n4. 0xC0000(768K) - 0xC7FFF(800K-1B): [768K, 800K): 暂未查到是哪种显示器使用了；\n\n\n## 其他硬件\n1. 0xC8000(800K) - 0xEFFFF(960K-1B): [800K, 960K): 硬件控制器的ROM或者内存映射式I/O； \n\n\n","tags":["Tech"]},{"title":"CRDT: 最终一致性","url":"/2022/06/23/CRDT-最终一致性/","content":"\n> 挖个大坑，是一个有意思的课题\n","tags":["Tech"]},{"title":"上分密码","url":"/2022/02/24/code-of-score/","content":"\n计数\n字符串匹配\nManacher\n字符串哈希\n模拟\n枚举\n排序\n\n线段树\n树状数组\n后缀数组\n并查集\n字典树\n\ndp\n记忆化搜索\n贪心\n分治\n树形dp\n\n\n二叉搜索树\n栈\n单调栈\n哈希\n堆\n有序表\n链表\n图\n拓扑排序\n最短路径\n最小生成树\n欧拉回路\n强连通分量\n\ndfs\nbfs\n回溯\n\n滑动窗口\n双指针\n二分查找\n状态压缩\n离散化\n扫描线\n前缀和\n滚动哈希\n\n\n","tags":["Tech"]},{"title":"旧书新读-《高等工程数学》","url":"/2022/01/20/read-old-books-advanced-engieering-mathmatics/","content":"\n- [线性空间](#线性空间)\n  - [线性组合/线性表出](#线性组合线性表出)\n  - [线性相关](#线性相关)\n  - [唯一线性表出定理](#唯一线性表出定理)\n  - [基](#基)\n  - [坐标](#坐标)\n  - [维度](#维度)\n  - [基与坐标变换](#基与坐标变换)\n  - [欧式空间](#欧式空间)\n  - [子空间](#子空间)\n\n> 线性代数应该怎么学? (ref: https://www.zhihu.com/question/311724817)\n\n> 要学好线性代数，最重要的是抓住线性代数的主线。线性代数的主线就是线性空间以及线性映射，整个线性代数的概念公式定义定理都是围绕着线性空间以及线性映射展开的。你要做的，就是紧紧抓住这条主线，把线性代数的所有知识点串联起来，然后融会贯通，自然就能学好线性代数了。\n\n> 1，线性空间。线性空间的定义比较抽象，简单的说，就是向量组成的一个集合，这个集合可以定义加法以及纯量乘法，并且对加法以及乘法满足交换律结合律以及分配率。这个集合以及定义在集合上的代数运算就是线性空间。\n\n> 研究线性空间有几个途径，一是基与维数，二是同构，三是子空间与直和以及商空间，四是线性映射。\n\n> 先讲讲基与维数。一个线性空间必定存在基，线性空间的任意元素都可以由基线性表出，且表出方式唯一，这个唯一的表出的组合就是这个元素在这个基下的坐标。线性表出且表出方式唯一的充分必要条件是什么？这里又引出了线性无关以及极大线性无关组的概念，极大线性无关组元素的个数又能引出秩的概念。由秩又能引出维度的概念。以上这些概念都是为了刻画线性空间的基与维数而衍生出来的，并不是凭空出现无中生有的。\n\n> 下面再谈谈同构。线性空间千千万，应如何研究呢？同构就是这样一个强大的概念，任何维数相同的线性空间之间是同构的，空间的维数是简单而深刻的，简单的自然数居然能够刻画空间最本质的性质。借助于同构，要研究任意一个n维线性空间，只要研究Rⁿ就行了。\n\n> n维线性空间作为一个整体，我们自然想到能不能先研究它的局部性质？所以自然而然的导出了子空间的概念以及整个空间的直和分解。直和分解要求把整个空间分解为两两不交的子空间之和，通过研究各个简单的子空间的性质，从而得出整个空间的性质。\n\n> 2，线性映射。\n\n> 前面讲了线性空间，舞台搭好了，轮到主角：线性映射登场了。\n\n> 线性映射的定义这里就不赘述了。我们小学就学过正比例函数y=kx，这是一个最简单的一维线性映射，也是一个具体的线性映射'模型'，线性映射的所有性质对比着正比例函数来看，一切都是那么简单易懂。现在把定义域从一维升级到多维，值域也从一维升级到多维，然后正比例系数k也升级为一个矩阵，那么这个正比例函数就升级为一个线性映射了。\n\n> 1)线性映射的核空间。这是线性映射的一个重要的概念，什么是线性映射的核空间呢？简单的说，就是映射到零的原像的集合，记作KER。用正比例函数来类比，显然当k不等于0时，它的核是零空间，当k为零时，它的核空间是整个R。\n\n> 有时候需要判定一个线性映射是不是单射，按照定义来还是没那么好证的，这时我们可以从它的核来判定，只要它的核是零，那么这个线性映射必然是单射。\n\n> 2)线性映射的像。当自变量取遍整个定义域时，它的像的取值范围成为一个线性子空间，称为像空间，记作IM。\n\n> 3)线性映射的矩阵表示。一个抽象的线性映射应如何'解析'的表达出来呢？这个表达式写出来就是一个矩阵，且这个矩阵依赖于基的选择。也就是说在不同的基下，线性映射有不同的矩阵。基有无穷个，相应的矩阵有无穷个。这就给用矩阵研究线性映射带来了麻烦。\n\n> 幸好我们有相似矩阵。同一个线性映射在不同的基下的矩阵是相似关系，相似不变量有秩，行列式，迹，特征值，特征多项式等。所以可以通过相似矩阵来研究线性映射的秩，行列式，迹，特征值，特征多项式等性质。\n\n> 线性映射的矩阵有无穷多，那么这其中有哪些是值得关注的呢？第一就是标准正交基下的矩阵了，这也是最常见的。\n\n> 然而一个线性映射的矩阵在标准正交基下可能特别复杂，所以需要选择一组特殊的基，让它的矩阵在这个基下有最简单的矩阵表示。如果存在这样的基，使得线性映射的矩阵为对角矩阵，则称这个线性映射可对角化。\n\n> 然而是不是所有线性映射都可以对角化呢，遗憾的是，并不是。那么就要问，如果一个线性映射不能对角化，那么它的最简矩阵是什么？这个问题的答案是若尔当标准型。可以证明，在复数域上，任何线性映射都存在唯一的若尔当标准型。\n\n# 线性空间\n1. 假定有一个n阶方阵的集合`$\\boldsymbol{R}^{n*n} = \\{方阵A,方阵B...\\}$`，然后针对这个集合定义加法和数乘运算法则，\n使得：\n- 加法满足交换律、结合律，存在加法零元和负元； \n- 数乘中的数来自数域`$\\boldsymbol{F}$`，数乘运算满足结合律、分配律，存在数乘的单位元；\n那么就称  `$\\boldsymbol{R}^{n*n}$`  这个集合为数域 `$\\boldsymbol{F}$` 上的一个线性空间。\n\n也就是说，线性空间本质上是一个满足了一定运算法则的集合。\n\n\n## 线性组合/线性表出\n假定有一个线性空间 `$\\boldsymbol{V} = \\{\\boldsymbol{\\alpha_1} , ..., \\boldsymbol{\\alpha_m}\\}$`，它是一个向量的集合。\n如果有一个向量`$\\boldsymbol{\\beta}=k_1\\boldsymbol{\\alpha_1}+...+k_m\\boldsymbol{\\alpha_m}$`，则称`$\\boldsymbol{\\beta}$`为`$\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}$`的一个线性组合，或者称`$\\boldsymbol{\\beta}$`可由`$\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}$`线性表出。\n\n## 线性相关\n设`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}\\}$`为线性空间`$\\boldsymbol{V}$`中的一个向量组（也就是说是集合`$\\boldsymbol{V}$`的一个子集），如果存在一组不全为零的数`$k_1, ..., k_m$`，使得：`$\\sum_{i=1}^{m}{k_i\\boldsymbol{\\alpha_i}}=\\boldsymbol{0}$`，则称向量组`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}\\}$`线性相关。\n若`$\\sum_{i=1}^{m}{k_i\\boldsymbol{\\alpha_i}}=\\boldsymbol{0}$` => `$k_1=k_2=...=k_m=0$`，则称向量组`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}\\}$`线性无关。\n\n## 唯一线性表出定理\n如果空间`$\\boldsymbol{V}$`中的向量组`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}\\}$`线性无关，且向量组`$\\{\\boldsymbol{\\beta}, \\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}\\}$`线性相关，那么`$\\boldsymbol{\\beta}$`可由`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}\\}$`唯一线性表出。\n\n## 基\n假设集合`$\\boldsymbol{V}$`是在数域`$\\boldsymbol{F}$`上形成线性空间的，`$\\boldsymbol{V}$`上有n个线性无关的向量`$\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}$`，如果说`$\\boldsymbol{V}$`上所有的向量（也就是集合的元素）都可以由`$\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}$`线性表出，则称`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}\\}$`为`$\\boldsymbol{V}$`空间的一个基。\n\n## 坐标\n假定`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}\\}$`为`$\\boldsymbol{V}$`空间的一个基，若有一个`$\\boldsymbol{V}$`中的向量`$\\boldsymbol{\\alpha}$`可以被这个基线性表出成: `$\\boldsymbol{\\alpha}=k_1\\boldsymbol{\\alpha_1}+k_2\\boldsymbol{\\alpha_2}+...+k_n\\boldsymbol{\\alpha_n}$`，那么这个系数组成的向量`$\\boldsymbol{k}=[k_1, k_2, ..., k_n]^T$`就称为`$\\boldsymbol{\\alpha}$`在基`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}\\}$`上的一个坐标。\n\n## 维度\n如果`$\\boldsymbol{V}$`的基是一个含有n个元素的集合，那么就称`$\\boldsymbol{V}$`为一个n维线性空间。记作`$dim\\boldsymbol{V}=n$`。如果`$\\boldsymbol{V}$`的基含有无穷多个元素，就称`$\\boldsymbol{V}$`为无限维的。\n\n## 基与坐标变换\n通常情况下，一个向量在不同的基下的坐标是不同的。\n设`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}\\}$`与`$\\{\\boldsymbol{\\beta_1},...,\\boldsymbol{\\beta_n}\\}$`是`$\\boldsymbol{V}$`中的两组基，则会有下面的运算关系：\n$$\n\\boldsymbol{\\beta_i}=p_{1i}\\boldsymbol{\\alpha_1}+p_{2i}\\boldsymbol{\\alpha_2}+...+p_{ni}\\boldsymbol{\\alpha_n}\n=\\left[\\boldsymbol{\\alpha_1}, \\boldsymbol{\\alpha_2}, ..., \\boldsymbol{\\alpha_n}\\right] \\left[\\begin{array}{c}\np_{1i}\\\\\np_{2i}\\\\\n...\\\\\np_{ni}\n\\end{array}\\right]\n$$\n同理，扩展一下任意`$\\boldsymbol{\\beta_i}$`的情况，我们可以得到下面的矩阵等式：\n$$\n\\left[\n  \\boldsymbol{\\beta_1}, \\boldsymbol{\\beta_2}, ..., \\boldsymbol{\\beta_n}\n  \\right]\n\n  = \\left[ \\boldsymbol{\\alpha_1}, \\boldsymbol{\\alpha_2}, ..., \\boldsymbol{\\alpha_n} \\right]\n\n  \\left[\\begin{array}{cccc}\n  p_{11}, p_{12}, ..., p_{1n} \\\\\n  p_{21}, p_{22}, ..., p_{2n} \\\\\n  ..., ..., ..., ..., \\\\\n  p_{n1}, p_{n2}, ..., p_{nn}\\\\\n    \\end{array}\\right]\n$$\n那么，右边👉这个大矩阵\n$$\n\\boldsymbol{P} =  \\left[\\begin{array}{cccc}\n  p_{11}, p_{12}, ..., p_{1n} \\\\\n  p_{21}, p_{22}, ..., p_{2n} \\\\\n  ..., ..., ..., ..., \\\\\n  p_{n1}, p_{n2}, ..., p_{nn}\\\\\n    \\end{array}\\right]\n$$\n就是从基`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}\\}$`到基`$\\{\\boldsymbol{\\beta_1},...,\\boldsymbol{\\beta_n}\\}$`的过渡矩阵。\n也就是说：\n$$\n\\left[\\boldsymbol{\\beta_1}, \\boldsymbol{\\beta_2}, ..., \\boldsymbol{\\beta_n}\\right] = \\left[\\boldsymbol{\\alpha_1}, \\boldsymbol{\\alpha_2}, ..., \\boldsymbol{\\alpha_n}\\right]\\boldsymbol{P}\n$$\n过渡矩阵必定是可逆矩阵。这是为什么呢？简单来想，基`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}\\}$`可以通过过渡矩阵线性变换到`$\\{\\boldsymbol{\\beta_1},...,\\boldsymbol{\\beta_n}\\}$`；那么也一定是可以变回来的。加法运算与数乘运算都是有逆元的。\n\n## 欧式空间\n首先，欧式空间是一个线性空间。它在实数域内满足向量加法的交换律、结合律、有零元和逆元；数乘运算满足交换律、结合律、有单位元。除了加法运算和数乘运算，欧式空间还定义了内积运算，它支持交换律、分配律，还有一些特殊的数乘运算规则（就是中学学的那些数乘运算规则）。那么这个线性空间就升级成了一个欧式空间。\n（猜测）欧式空间这种代数结构应该是用来总结早期的几何学内容的。\n\n## 子空间\n设`$\\boldsymbol{W}$`是空间`$\\boldsymbol{V}$`的一个子集，如果这个子集满足下面两个条件：\n(1)对于`$\\boldsymbol{W}$`中的任意两个向量`$\\boldsymbol{\\alpha}, \\boldsymbol{\\beta}$`，两者的和也在这个`$\\boldsymbol{W}$`中；\n(2)对于`$\\boldsymbol{W}$`的任意一个向量`$\\boldsymbol{\\alpha}$`，如果定义`$\\boldsymbol{V}$`时配套的数域`$\\boldsymbol{F}$`上的任意一个数k,都可以使得`$k\\boldsymbol{\\alpha}$`还属于这个`$\\boldsymbol{W}$`子集；\n那么就称`$\\boldsymbol{W}$`为`$\\boldsymbol{V}$`的一个子空间。\n用人话说就是，子集`$\\boldsymbol{W}$`对于加法和数乘自闭环。\n显然，子空间的维数小于等于原空间。\n\n\n### 子空间的张成\n1. 设`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_r}\\}$`为`$\\boldsymbol{V}$`中的一组向量，我们定义\n$$\nspan\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_r}\\} \\triangleq  \\{k_1*\\boldsymbol{\\alpha_1},...,k_n*\\boldsymbol{\\alpha_r} | \\forall k_i \\in F\\}\n$$\n称`$span\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_r}\\}$`为由`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_r}\\}$`张成的子空间。\n\n理解起来比较简单直观，`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}\\}$`中的任意向量在`$\\boldsymbol{V}$`中对于加法和数乘操作都是封闭的。\n\n### 子空间基的扩充\n设`$\\boldsymbol{W}$`为线性空间`$\\boldsymbol{V^n}$`的子空间，`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m}\\}$`为`$\\boldsymbol{W}$`的一组基，则可将它扩充`$\\boldsymbol{V^n}$`的一组基`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_m},\\boldsymbol{\\alpha_{m+1}},..., \\boldsymbol{\\alpha_n}\\}$`。\n这是在说子空间的基与空间的基之间的关系。\n\n### 子空间的交、和运算\n设`$\\boldsymbol{W_1}$`与`$\\boldsymbol{W_2}$`都是`$\\boldsymbol{V}$`的子空间。\n1. 那么交运算的定义为:\n\n$$\n\\boldsymbol{W_1} \\cap \\boldsymbol{W_2} \\triangleq \\{\\alpha \\in \\boldsymbol{V} | \\alpha \\in \\boldsymbol{W_1} 且 \\alpha \\in \\boldsymbol{W_2}\\}\n$$\n\n2. 和运算定义为:\n\n$$\n\\boldsymbol{W_1} + \\boldsymbol{W_2} \\triangleq \\{\\alpha \\in \\boldsymbol{V} | \\alpha=\\alpha_1+\\alpha_2, \\alpha_1 \\in \\boldsymbol{W_1} 且 \\alpha_2 \\in \\boldsymbol{W_2}\\}\n$$\n\n显然，`$\\boldsymbol{W}$`的两个子空间的交、和结果依然是`$\\boldsymbol{W}$`的子空间。\n\n### 子空间的和与张成\n如果说:`$\\boldsymbol{W_1}$`是由`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_r}\\}$`张成的，而`$\\boldsymbol{W}$`是由`$\\{\\boldsymbol{\\beta_1},...,\\boldsymbol{\\beta_s}\\}$`张成的，那么`$\\boldsymbol{W}$`与`$\\boldsymbol{W}$`的和是由`$\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_n}\\}$`与`$\\{\\boldsymbol{\\beta_1},...,\\boldsymbol{\\beta_s}\\}$`一起张成的。\n$$\n\\boldsymbol{W_1}= span\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_r}\\},\\boldsymbol{W_2} = span\\{\\boldsymbol{\\beta_1},...,\\boldsymbol{\\beta_s}\\}，则:\n\\boldsymbol{W_1} + \\boldsymbol{W_2} = span\\{\\boldsymbol{\\alpha_1},...,\\boldsymbol{\\alpha_r},\\boldsymbol{\\beta_1},...,\\boldsymbol{\\beta_s}\\}\n$$\n\n### 维数公式\n设`$\\boldsymbol{W_1}$`与`$\\boldsymbol{W_2}$`都是`$\\boldsymbol{V}$`的子空间，那么\n$$\ndim(\\boldsymbol{W_1}+\\boldsymbol{W_2}) + dim(\\boldsymbol{W_1} \\cap \\boldsymbol{W_2}) = dim\\boldsymbol{W_1} + dim\\boldsymbol{W_2}\n$$\n这个形式与集合论中集合的势的规律是一样的，应该是这些数学家在特意的凑规律。\n证明的思路依靠下面三条:\n1. 维数的值等于基中的向量个数;\n2. 基是一个空间的极大线性无关组;\n3. 线性无关是说一组向量，他们的数乘之和为0，这些数乘操作所有取的数字都不是0;","tags":["books"]},{"title":"有限状态机理论","url":"/2022/01/19/有限状态机理论/","content":"\n# 计算模型\n在计算理论中，FSM是一个计算模型。\n1. 一个抽象的机器，这个机器在任何时候只能处于有限的几个状态;\n2. 在某些特定的输入下，这个机器可以从一个状态切换到其他的状态; 这个切换过程称为transition;\n\n状态机可以由「一组状态」、「初始状态」、「触发每个transition的输入」唯一定义。\n\nFSM可以分成两大类: 确定性有限状态机 和 不确定性有限状态机。一个确定性有限状态机可以与任何一个非确定性有限状态机在数学上同构。\n\n在理论计算领域内，FSM的计算能力是比其他的一些计算模型要低的。典型的，FSM比图灵机的计算能力要弱。\n> 「计算能力」如何衡量? 比如有一些任务，图灵机能做，但是FSM却做不了。\n\n\n# UML状态机","tags":["Tech"]},{"title":"旧书新读: 《大象-think in UML》","url":"/2022/01/17/旧书新读-《大象-think-in-UML》/","content":"\n# why\n## 面向过程 VS. 面向对象\n\n面向对象与面向过程之争本质上是认识论的争论。书中提到说古希腊哲学家亚里士多德也思考过这个问题: 世界是过程还是对象?学术界也有关于这个面向对象思维认识论的讨论。[<sup>1</sup>](#ref-anchor-1)\n作者本人是认同这个世界的本质是由对象组成的，平时看上去相互无关的独立对象在不同的驱动力和规则下体现出不同的运动过程。而在面向过程的认知中，世界的一切都不是孤立的，他们互相紧密的联系在一起，缺一不可，互相影响，互相作用，并形成一个个具有严格因果律的小系统。\n\n从面向过程思想转变到面向对象思想，首先要接受的事实是: 这个世界是割裂的，只有在特点的场景下，孤立对象之间进行了某些信息交互才会表现出我们理解的一个过程。\n\n### 面向过程的问题\n> 面向过程方法认为每个小系统都有着明确的开始和明确的结束，开始和结束之间有着严谨的因果关系。只要我们将这个小系统中的每一个步骤和影响这个小系统走向的所有因素都分析出来，我们就能完全定一个这个系统的行为。\n单从上面的描述来看，文中对与面向过程思想的概括，与图灵机的定义非常像。\n\n图灵机模型:\n一台图灵机是一个七元组，`$ \\{ Q, \\Sigma, \\Gamma, \\delta, q_0, qaccept, qreject \\}$`。其中，`$Q, \\Sigma, \\Gamma $`都是有限集合。这个七元组满足:\n1. `$Q$`是状态集合;\n2. `$\\Sigma$`是输入字母表，其中不包含特殊的空白字符;\n3. `$\\Gamma$`是整个纸带上的字母集合，并且有，`$Q\\subseteq\\Gamma, \\Sigma\\subseteq\\Gamma$`，\n4. 定义运算: `$\\delta: Q\\times\\Gamma \\rightarrow Q\\times\\Gamma\\times\\{L, R\\}$`，其中的L, R标识的是纸带的运行方向;\n5. `$q_0 \\in Q$`代表机器的初始状态;\n6. qaccept代表一个特殊的状态，即「接受」;\n7. qreject代表一个特殊的状态，即「拒绝」;\n\n\n### 面向对象的思路\n将世界看作一个一个独立的对象，对象之间没有因果关系。在外部力量的推动下，对象之间会依据某种规律传递信息。\n\n### 面向对象的问题\n1. 对象自己是怎么来的? 它的的生命周期是怎么回事?\n2. 同一批对象，按照不同的结构组织起来，可以表达出不一样的功能。那么如何根据一批对象的组织结构来确定其功能呢?\n3. 怎么确定一批对象的组合就满足了我们的需要呢?什么样的组合方式是好的，什么样的组合方式是坏的?\n\n解决以上问题的关键，是抽象:\n1. 找到一种方法，可以将现实世界映射到对象世界;\n2. 找到一种方法，可以用对象世界描述现实世界;\n3. 找到一种方法，可以验证对象世界是否正确的反映了现实世界; \n\nUML就是这样一种方法。\n\n### 先将现实世界映射到业务模型\n使用用例图来实现。用例图是一种元模型，其中，Actor是整个业务的驱动者，代表现实世界的人，是模型信息来源的提供者。用例则是描述Actor业务目标的模型，代表现实世界的事。业务场景和用例场景则代表的是规则。对象业务模型(business object model)代表达成业务目标过程中的事务，对应现实世界的物。因此，用例图定义了与现实世界中的人、事、物、规则之间的映射。\n\n### 将业务模型映射到概念模型\n借助分析模型图来实现。分析模型主要定义了以下元素:\n1. 边界类: 定义了交互界面/操作界面;\n2. 实体类: 定义与现实世界一一映射的事物和其间的逻辑关联;\n3. 控制类: 定义原始需求中的动态信息;\n在分析模型图的基础之上，可以加以归纳和整理，得出软件的一些关键信息，比如包、组件和节点。\n\n### 将概念模型映射到设计模型\n做一些具体的软件设计工作，包括且不限于:\n1. 控制类转换成程序或者框架，比如说工作流，算法体等;\n2. 实体类转化成数据库表、XML文档等持久化元素;\n3. 设定实现类的关系，例如继承、接口等;\n4. 编程语言选型;\n5. 中间件选型;\n6. 代码规范选型;\n...\n\n# 建模\n什么是建模? 怎么样建模? 建出的模是什么?\n$$\n问题领域 = \\sum_{1}^{n} 抽象角度\n$$\n$$\n抽象角度 = 问题领域边界之外的参与者的业务目标 = 业务用例\n$$\n$$\n业务用例 = \\sum_{1}^{n} 特定场景\n$$\n$$\n特定场景 = 静态的事物 + 特定的规则 + 特定的动作\n$$\n$$\n特定场景 = 特定的事物 + 特定的规则 + 特定的的人的行动\n$$\n\n## 用例驱动\n用例可以用于构建以下内容:\n1. 逻辑视图: 以图形方式说明系统的关键用例实现、子系统、包和类;\n2. 进程视图: 以图形方式说明系统中进程的详细组织结构;\n3. 部署视图: 以图形的方式说明处理活动在系统中各节点的分布;\n4. 实施视图: 获取为实施指定的架构决策，包括: 描述子系统，描述分层，描述子系统的依赖关系。说的直白一点就是团队分工。\n\n## 抽象层次\n面向对象软件设计方法一般采用自顶向下的抽象方法;\n\n## 对象分析方法\n1. 一切都是对象;\n2. 对象都是独立的;\n3. 对象都具有原子性;\n4. 对象都是可抽象的;\n5. 对象都有层次;\n\n# UML核心元素\n\n## 版型(stereotype)\nUML中的一个基础元素以及扩展元素。例如以下概念都可以称之为版型: 业务用例、类、接口、边界类、实体类、控制类、参与者等基础元素，子系统、组织结构、模块等自定义的扩展元素，文档、开发小组等更模糊的元素。\n下面逐个介绍各个版型的内涵。\n\n## 参与者(Actor)\n参与者在建模中是处于核心地位的，他是系统外与系统交互的人或事物。\n\n## 用例\n用例是UML建模中最最重要的一个元素。由于面向对象世界中的对象是独立的、静止的，只有用例可以施加一种外力，让这些静止的对象成为一个系统。\n\n### 用例的特征\n1. 用例是相对独立的;\n2. 用例的执行结果对于参与者来说是可观测的、有意义的;\n3. 用例必须由参与者发起;\n4. 用例必须以动宾短语出现;\n5. 一个用例就是一个需求单元、分析单元、设计单元、开发单元、测试单元，甚至是部署单元;\n\n### 用例的粒度\n粒度的选择问题，本质上是边界认定的问题。\n1. 参与者中是位于系统边界之外的;\n2. 参与者对于系统有着明确的期望和明确的回报要求;\n3. 参与者的期望和回报要求在系统边界之外;\n\n## 业务实体\n业务实体是类(class)的一种版型，代表业务角色执行业务用例时所处理或使用的事物。\n\n### 业务实体的属性\n属性是用来保存业务实体特征的一个记录，业务实体的属性集合决定了它的唯一性。\n### 业务实体的方法\n方式是业务实体的一个访问句柄，它规定了外部可以怎样来使用它。\n\n### 如何获取业务实体\n首先，我们需要建立业务用例场景。一般来说是一个动宾短语，用来描述参与者实现其业务目标的过程。\n然后，我们从用例的动宾短语中获取其中的名词，这些名词都是我们业务实体的备选对象。\n然后，对这些备选对象进行一轮筛选，去除对于业务目标没有直接贡献的对象，剩下的就是业务实体。\n最后，分析这些业务实体的关系，并决定哪些可以单独建模，哪些只是作为属性。\n\n\n## 包\n包是一种容器，类似于文件夹，可以将信息分类，形成逻辑单元。包可以容纳任何UML元素，包括用例、业务实例、类图、子包等等。\n分包的好坏是由包之间的依赖关系来评判的，包与包之间只有一种关系: 依赖关系。好的包应该具有高内聚、低耦合的特征。\n什么是依赖?\n1. 如果A发生变化，B必然发生变化，我们称B依赖于A;\n分包可以按照以下思路:\n1. 分入同一个包中的元素应当是相互紧密联系、不可分割的;\n2. 包中任意一个元素被修改，其他包中的任何一个元素的内容都不受影响;\n3. 如何包与包之间有依赖关系，则这种依赖关系应该是单向的，应避免发生双向依赖或者循环依赖;\n\n一些常见的包的版型包括:\n1. 领域包: 用于在业务领域内的业务单元之间做分类;\n2. 子系统: 用于分类系统中的逻辑对象并形成子系统;\n3. 组织结构: 用于分类业务领域内的组织结构;\n4. 层: 用于分类软件中的层次;\n\n## 分析类\n\n\n## Reference\n\n<div id=\"ref-anchor-1\"></div>\n<!-- 下面必须有一个空行 -->\n\n  - [1]: [Aristotle and object-oriented programming](https://dl.acm.org/doi/10.1145/330908.331862)","tags":["books"]},{"title":"不动点与递推数列","url":"/2022/01/11/fixed-point-and-recursive-sequence/","content":"\n设数列 `$ \\{a_{n+1}\\} $`存在递推公式`$ a_{n+1}=f(a_{n}) $`，求数列的通项公式。\n考察函数`$ f(x) $`,假设该函数存在不动点`$ x_0 $`，使得`$ f(x_0)=x_0 $`，则:\n有`$ x=x_0 $` 是函数 `$ f(x)-x $`的一个解。\n如果函数`$ f(x)-x_0 $`是一个可以因式分解的函数，则`$ x-x_0 $`必定是方程`$ f(x)-x_0=0 $`的一个解。\n我们可以假设`$ f(x)-x_0=A*(x-x_0) $`，接下来我们可以想办法求出这个`$ A $`。\n将数列`$ \\{a_{n}\\} $`带入到上面的方程中:\n=> `$ f(a_{n})-x_0=A*(a_n-x_0) $` => `$ a_{n+1}-x_0=A*(a_n-x_0) $`\n=> `$ A=(a_{n+1}-x_0)/(a_n-x_0) $`\n在正常的出题中，`$ f(x) $`的形式都是给出了的，所以这里可以代入到上面的式子中算出A。\n算出A之后，新数列`$ \\{(a_{n+1}-x_0)/(a_n-x_0)\\} $`就成了一个等比数列。可以算出其通项公式。","tags":["Math"]},{"title":"数学的天梯","url":"/2022/01/10/the-step-of-math/","content":"\n> 古典数学\n```\n算术\n基本几何\n分数、开方、幂\n笛卡尔坐标\n无理数\n变量、方程、函数\n```\n\n> 基础数学\n```\n初等代数\n斜率\n多项式\n矩阵\n复数、对数\n弧度\n三角函数\n圆锥曲线\n微积分\n参数方程\n数理统计\n微分\n最优化\n积分\n极坐标\n无穷级数\n多元微积分\n向量分析\n微分方程、偏微分方程\n散度、斯托克斯定理\nS-L问题\n张量\n矢量空间\n线性变换\n若尔当标准型\n特征值、特征向量\n收敛\n傅立叶级数\n拉普拉斯变换\n```\n\n> 理论数学\n```\n群论\n变分学\n实分析\n欧式空间\n密码学\n博弈论\n随机分析\n组合学\n随机分析\n复分析\n复变函数\n全纯函数\n测度论\n拓扑学\n度量空间\n黎曼空间\n同胚\n同伦\n非欧几何\n布尔代数\n巴拿赫空间\n分形\n希尔伯特空间\n伽罗瓦理论\n微分几何\n群胚\n代数拓扑\nP进数分析\n光滑流形\n毛球定理\n纽结理论\n代数几何\n控制论\n射影簇\n代数数论\n自守形式\n混沌\n克利福德代数\n李代数\n无穷小变换\nE7李群\n```\n\n> 玄学\n```\n辛几何\n随机矩阵\n上同调\n同调镜像对称\n复克莱因群\n完美空间\n四色定理\n费马大定理\n庞加莱猜想\n宇宙际理论\n前禧年大奖难题\nNP=P问题\n黎曼猜想\n杨-米尔斯理论\n贝赫和斯维纳通-戴尔猜想\n霍奇猜想\n```","tags":["Math"]},{"title":"Spring中奇奇怪怪的注解","url":"/2021/12/29/SpringAnnotations/","content":"\n# @Import\nSpring用来做配置的几个重要注解之一。@Import可以将一个被注解的类生成一个Bean并交给容器管理，从这一点上看，@Import有着和@Bean相似的功能，但是@Import的能力更大。它可以提供自定义的导入方式、导入条件，甚至可以动态修改导入的Bean的属性、类型等等。\n这个注解最早设计的时候，目标是为了替代远古时期的XML配置的Bean注入功能。类似于XML中的<import />。后来演化出了更多功能。\n现在Import主要有三种用法:\n1. @Import({})直接声明要注入到容器中的Bean的类;\n2. @Import({})声明一个「实现了ImportSelector接口的类(假设为X)」; 在这个X类重写的selectImports接口中，声明要引入哪一些类; 这样绕一圈的目的是让开发者有办法自己过滤或者自己定义要引入哪一些类;\n3. @Import({})声明一个「实现了ImportBeanDefinitionRegister接口的类(假设为Y)」;在这个Y类重写的\n\n"},{"title":"旧书新读-《nodejs:来一打C++扩展》","url":"/2021/11/06/read-old-books-nodejs-c-addon/","content":"\n# V8基础\n\n## 内存机制\n### 内存管理基本原理\nV8有自己的堆内存区域，并且有自己的堆管理策略。简单来说，V8将堆内存分成了下面几种区域：\n- 新生代内存区： 基本的数据对象都会被分配到这里，其特点是小而频繁。区域小但是垃圾回收频繁；\n  新生代内存使用Scavenge算法进行回收：将新生代空间分成两部分，一部分为From，一部分为To。分配时总是从From空间中预留空间。在遇到GC时，V8会将From空间中存活的对象复制到To空间中，剩下的不存活的对象会被直接释放。完成后交换From和To的角色。\n- 老生代指针区：指向老生代内存区具体数据内容的指针会被存在这里。从新生代蜕变过来的对象的指针会被放在这里；\n  老生代使用Mark-Sweep和Mark-Compact结合的机制进行垃圾回收。Mark-Sweep即标记删除法：先遍历老生代中的对象，将已经死亡的对象标记，之后统一进行清除。\n  在使用标记清除法进行操作的时候，很容易产生内存碎片问题。Mark-Compact就是一种改进后的方案，可以堆内存碎片进行整理。即先标记，然后在统一进行清除的时候，让活着的对象尽可能的向内存区域的头部进行对齐。\n- 老生代数据区：存放数据对象，而不是指向其他对象的指针。老生代指针区的指针就往这边指。\n- 大对象区：这里存放体积超越其他区大小的对象，每个对象都有自己的内存，垃圾回收机制并不会移动大对象；\n- 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。这是唯一拥有执行权限的区域； \n- Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单；\n## 隔离实例(Isolate)\n一个引擎的实例称为一个isolate。可以理解为是V8引擎的一个实例，拥有完全独立的各种状态、堆管理、垃圾回收等等。\n在一个实例中生成的对象无法在另一个实例中使用。\n## 句柄\n句柄提供了对V8的堆内存的中JavaScript数据对象的一个引用。简单来说，句柄是一种包装过的指针，这种指针可以被V8的垃圾回收引擎识别，然后进行生命周期管理。\n句柄有多种类型：\n- 本地句柄：v8::Local; 本地句柄存在于栈中，在对应的析构函数被调用的时候会销毁内存。其生命周期由其所在的句柄作用域决定。可以通过成员函数As()/Cast()进行强制类型转换。\n- 持久句柄：v8::Presistent；比较复杂，分为弱持久句柄（PresistentBase::SetWeak）、唯一持久句柄（v8::UniquePersistent<>）和一般持久句柄（v8::Persistent<>）;\n- 永生句柄：v8::Eternal; 永生句柄在整个程序的生命周期内都不会被删除，也就是说不会进行垃圾回收。\n下面就是几种常见的句柄：\n```\nv8::Local<v8::Number>\nv8::Persistent<v8::String>\n```\n## 句柄作用域（Handle Scope）\n存在于栈空间中，是一个维护一堆句柄的容器。当一个句柄作用域被析构时，其容器内的所有句柄都会被析构。句柄作用域一个类似于栈帧的逻辑组织和使用。\n## 上下文\n上下文是V8中JavaScript代码的执行环境。各个上下文是独立存在并且允许存在多个。即使在同一个隔离实例中，不同的上下文也是不想干的，可以执行各自的JavaScript代码。\n在V8中，可以通过vm模块创建沙箱来执行一段JavaScript代码。也就是说，借助vm模块，可以自己定制上下文实例。\n## 模版\n在某个上下文中，创建JavaScript对象或者函数的一个原型。\n- 函数模版（FunctionTemplate）。可以通过函数模版的GetFunction()方法来获取其具体函数实例的句柄。这样获取的具体函数实例是可以被JavaScript代码直接识别和使用的。\n  函数模版的使用时候有一种特殊的情况，就是你设置了一个函数模版的实例，然后想让这个实例在JavaScript的世界中成为某一个类的构造函数。这是一个挺复杂的事情。在函数模版实例中，可以调用成员方法SetClassName()来设定‘当前函数为构造函数的情况下，new出来的对象是哪一个类的’。\n- 对象模版（ObjectTemplate）：对象模版用于在运行时创建对象。由于JavaScript的面向对象使用的是原型对象的模式，因此在对象模版中添加的属性，也会被创建出来的对象实例所继承。\n我们回顾一下JavaScript的原型链：\n1. 每个对象实例都有一个__proto__属性指向自己的原型对象；\n2. 所有的函数都有一个prototype属性，指向自己的原型对象。这个原型对象就是以该函数作为构造函数new出来的对象的原型；\n3. 函数也是一个对象，所以也有__proto__属性。特别的，所有函数的__proto__属性都指向Function.prototype，因为所有的函数看成对象的会都是由Function（）作为构造函数构造出来的对象。\n## 数据类型\n## 异常机制\n","tags":["books"]},{"title":"旧书新读:《程序员的自我修养》","url":"/2021/08/01/旧书新读-《程序员的自我修养》/","content":"- [编译与链接](#编译与链接)\n  - [编译过程](#编译过程)\n    - [预处理](#预处理)\n    - [编译](#编译)\n    - [汇编](#汇编)\n    - [链接](#链接)\n  - [编译器前端](#编译器前端)\n    - [词法分析](#词法分析)\n    - [语法分析](#语法分析)\n    - [中间代码生成](#中间代码生成)\n  - [编译器后端](#编译器后端)\n    - [代码生成](#代码生成)\n    - [目标代码优化](#目标代码优化)\n- [目标文件格式](#目标文件格式)\n  - [格式](#格式)\n  - [分析工具](#分析工具)\n    - [.text section](#text-section)\n    - [.data section / .rodata section](#data-section--rodata-section)\n    - [.bss section](#bss-section)\n    - [自定义section](#自定义section)\n  - [ELF文件格式](#elf文件格式)\n    - [文件头（File header）](#文件头file-header)\n    - [section表(section header table)](#section表section-header-table)\n    - [重定位表(Relocation Table)](#重定位表relocation-table)\n    - [字符串表](#字符串表)\n  - [符号](#符号)\n    - [符号表结构](#符号表结构)\n    - [特殊符号](#特殊符号)\n    - [符号修饰和函数签名](#符号修饰和函数签名)\n    - [extern \"C\"](#extern-c)\n- [静态链接过程](#静态链接过程)\n  - [空间与地址分配](#空间与地址分配)\n    - [空间占用与分配](#空间占用与分配)\n    - [相似段合并](#相似段合并)\n    - [两步链接法](#两步链接法)\n    - [链接命令](#链接命令)\n    - [链接后的地址变化](#链接后的地址变化)\n    - [符号地址的确定](#符号地址的确定)\n  - [符号解析与重定位](#符号解析与重定位)\n    - [重定位](#重定位)\n    - [重定位表](#重定位表)\n    - [符号的解析](#符号的解析)\n    - [指令的修正方式](#指令的修正方式)\n  - [链接过程控制](#链接过程控制)\n    - [链接器控制脚本](#链接器控制脚本)\n    - [查看默认的链接器脚本](#查看默认的链接器脚本)\n    - [最小的程序](#最小的程序)\n    - [链接器脚本编写](#链接器脚本编写)\n    - [链接器脚本语法](#链接器脚本语法)\n    - [BFD库](#bfd库)\n  \n\n# 编译与链接\n\n## 编译过程\nC程序的编译过程： \nC源码文件: hello.c  --预处理器(cpp命令)--> hello.i --编译(gcc命令)--> hello.s --汇编(as命令)--> hello.o --链接(ld命令)--> a.out\n\n### 预处理\n使用cpp命令执行源码的预处理，预处理阶段主要做以下事情：\n - 宏展开，替换所有的#define宏\n - 处理预编译命令，比如: #if, #ifdef, #elif, #else, #endif\n - 递归展开#include\n - 删除所有注释\n - 添加行号和文件名标识: #2 \"hello.c\" 2\n - 保留#pragma\n\n### 编译\n这里的编译指的是狭义上的编译，主要做的是编译器前端的工作。使用gcc命令执行编译，主要做的事情：\n - 词法分析\n - 语法分析\n - 语义分析\n - 生成汇编代码及优化\n这个阶段是广义的编译过程中最复杂的阶段。\n\n### 汇编\n比较简单，调用命令as对生成的汇编代码进行翻译，生成对应的机器指令即可。\n\n### 链接\n调用ld命令将汇编阶段生成的obj文件组装成一个可执行文件。这个过程略有一点复杂，下文重点讲这个内容。\n\n## 编译器前端\n\n### 词法分析\n步骤：\n1. 通过扫描器(Scanner)将源代码读入\n2. 通过有限状态机(Finite State Machine)将字符串分割成一系列记号(Token)\n可以识别出的记号一般包括这几种： 关键字、标识符、字面量、特殊符号（如加号，等号等）。在识别符号的同时也会做好分类，如将标识符放到符号表，将数字、字符串放到文字表等。\n可用的词法分析工具： lex, GNU的Flex等。\n\n### 语法分析\n目标是将上面词法分析过程产生的记号生成一个语法树(Syntax Tree， 也会被称作AST: Abstract Syntax Tree)。使用上下文无关语法（Context-free Grammar）推理自动机。语法树是以表达式（Expression）为节点的树。\n可选的语法分析工具包括： yacc(Yet Another Compiler Compiler), GNU的Bison, Antlr, JavaCC等。\n\n### 中间代码生成\n语法分析阶段生成的AST没法做优化，因此源代码优化器常常会将AST转换成中间代码(Intermediate Code， 也会被称作‘中间表达形式(Intermediate Representation)’)。它实际上是AST的一个线性展开，将语法树展开成顺序的表达形式。一般IC已经比较接近目标代码了，但目前为止和目标机器的运行时环境还是无关的，因为它不包含数据的尺寸、变量的地址、寄存器的名字等等。\n中间代码有多种类型，比较常见的有：\n - 三地址码(Three-address code): 三地址码的表达式形式： x = y op z\n  举个例子，表达式'2*a+(b-3)'用3地址码会翻译成下面这样：\n  T1 = 2 * a;\n  T2 = b - 3\n  T3 = t1 + t2\n - P代码（P-Code）: 用来生成那些具有逻辑栈结构的机器（也被称为P-Machine，通常我们会在P机器上写解释器）。生成的P代码一般都是用来直接解释执行的，所以在P代码中会包含运行时环境的一些隐式描述。\n  P机器由以下元素构成： 代码内存，有名变量的数据内存，栈，寄存器（抽象的）。\n  举个例子：  还是表达式'2*a+(b-3)'用P代码会翻译成下面这样\n  ```\n  ldc 2    ; 加载常量2\n  lod a    ; 加载变量a的值\n  mpi      ; 整数乘法操作\n  lod b    ; 加载变量b的值\n  ldc 3    ; 加载常量3\n  sbi      ; 整数减法\n  adi      ; 整数加法\n  ```\n\n## 编译器后端\n\n### 代码生成\n代码生成器（Code Generator）将中间代码转换成目标机器代码。这个过程的具体内容依赖于目标机器，因为不同的机器有不同的字长、寄存器、整数数据类型和浮点数据类型等等。\n我们以一个全新的例子来看。\n假设有一段C代码： array[index] = (index + 4) * (2 + 6)\n那么会生成中间代码（假设是三地址码）如下：\n```\nt1 = 2 + 6\nt2 = index + 4\nt3 = t2 * t1\narray[index] = t3\n```\n中间代码优化后会得到：\n```\nt2 = index + 4\nt2 = t2 * 8\narray[index] = t2\n```\n\n那么，上面优化后的三地址码在代码生成阶段会生成下面的目标代码：\n```\nmovl index, %ecx       ; 将index的值赋值给ecx\naddl $4, %ecx          ; ecx的值加4\nmull $8, %ecx          ; ecx的值乘以8\nmovl index, %eax       ; 将index的值赋值给eax\nmovl %ecx, array(, eax, 4) ; array[index] = ecx\n```\n\n### 目标代码优化\n得到了上面的目标代码之后，目标代码优化器（Target Code Optimizer）还会对生成的目标代码进一步优化。主要的优化手段包括：\n- 选择合适的寻址方式\n- 使用位运算替代乘法运算\n- 删除多余的指令\n等等。\n上面的例子，在优化之后，目标代码会变成：\n```\nmovl index, %edx\nleal 32(, %edx, 8), %eax\nmovl %eax, array(, %edx, 4)\n```\n\n至此，狭义的编译器的工作就全部完成了。\n\n##　链接器\n链接器的主要任务是各个目标文件中相互引用的部分处理好，使得各个目标文件可以正确衔接。主要包括以下几个过程：\n- 地址和空间分配（Address and Storage Allocation）\n- 符号决议（Symbol Resolution），也被称为 符号绑定（Symbol Binding）、名称绑定(Name Binding)、名称决议(Name Resolution)、地址绑定（Address Binding）、指令绑定（Instruction Binding）等等。\n- 重定位（Relocation）\n\n# 目标文件格式\nWindows平台的可执行文件格式为PE格式（Portable Executable），Linux下的为ELF格式（Executable Linkable Format）。这两者都是COFF(Common File Format)格式的变种。\n我们上面提到的‘目标文件’指的是编译完成后但是没有开始链接的那些中间文件，Windows下为.obj后缀，Linux下为.o后缀。\n目标文件和可执行文件的内容和结构相似，所以一般和可执行文件采取相同的格式存储。(其实.dll文件，.so文件，.lib, .a文件还有.core文件也是按这个格式存储的)\n\n## 格式\n目标文件中内容有那些？ 答： 有机器指令代码、数据、符号表、调试信息、字符串等。\n目标文件会将这些信息按照不同的属性，以section为单位进行存储。比如，编译后的机器指令放在.code或者.text section；全局变量和局部静态变量放在.data section中 等等。\n目标文件还有一个‘文件头（File Header）’，它描述了整个文件的文件属性，比如文件是否可执行、是静态链接还是动态链接、如果是可执行文件，那入口地址是多少、目标硬件是什么、目标操作系统是什么等等。文件头中还有一个section表（section table），它是一个描述文件中各个section的数组，记录了文件中各个section在文件中的偏移位置及sectoin的属性等。\n\n## 分析工具\nobjdump -h工具可以将文件的各个section的基本信息打印出来。\n示例代码:\n```\nint printf(const char* format, ...);\n\nint global_int_var = 84;\nint global_uninit_var;\n\nvoid func1(int i) {\n        print(\"%d, \\n\", i);\n}\n\nint main(void) {\n        static int static_var = 85;\n        static int static_var2;\n        int a = 1;\n        int b;\n        func1(static_var + static_var2 + a + b);\n        return a;\n}\n```\ngcc -o hello.o -c hello.c 编译之后得到hello.o。使用objdump -h得到：\n```\nhello.o:     file format elf64-x86-64\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         0000005f  0000000000000000  0000000000000000  00000040  2**0\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  1 .data         00000008  0000000000000000  0000000000000000  000000a0  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000004  0000000000000000  0000000000000000  000000a8  2**2\n                  ALLOC\n  3 .rodata       00000006  0000000000000000  0000000000000000  000000a8  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .comment      0000002b  0000000000000000  0000000000000000  000000ae  2**0\n                  CONTENTS, READONLY\n  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d9  2**0\n                  CONTENTS, READONLY\n  6 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000e0  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  7 .eh_frame     00000058  0000000000000000  0000000000000000  00000100  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n```\n上述输出中，section有多个必选属性： idx, 名字，大小，VMA，LMA，文件内偏移File Offset, 对齐方式Align。第二行的contents, allocation, load, relocation, readonly, code等标识section的一些可选属性。\n下面依次看这些section。\n\n### .text section\nobjdump -s 可以以十六进制打印，-d可进行反汇编，于是： objdump -s -d hello.o 有：\n```\nhello.o:     file format elf64-x86-64\n\nContents of section .text:\n 0000 f30f1efa 554889e5 4883ec10 897dfc8b  ....UH..H....}..\n 0010 45fc89c6 488d3d00 000000b8 00000000  E...H.=.........\n 0020 e8000000 0090c9c3 f30f1efa 554889e5  ............UH..\n 0030 4883ec10 c745f801 0000008b 15000000  H....E..........\n 0040 008b0500 00000001 c28b45f8 01c28b45  ..........E....E\n 0050 fc01d089 c7e80000 00008b45 f8c9c3    ...........E... \nContents of section .data:\n 0000 54000000 55000000                    T...U...        \nContents of section .rodata:\n 0000 25642c20 0a00                        %d, ..          \nContents of section .comment:\n 0000 00474343 3a202855 62756e74 7520392e  .GCC: (Ubuntu 9.\n 0010 332e302d 31377562 756e7475 317e3230  3.0-17ubuntu1~20\n 0020 2e303429 20392e33 2e3000             .04) 9.3.0.     \nContents of section .note.gnu.property:\n 0000 04000000 10000000 05000000 474e5500  ............GNU.\n 0010 020000c0 04000000 03000000 00000000  ................\nContents of section .eh_frame:\n 0000 14000000 00000000 017a5200 01781001  .........zR..x..\n 0010 1b0c0708 90010000 1c000000 1c000000  ................\n 0020 00000000 28000000 00450e10 8602430d  ....(....E....C.\n 0030 065f0c07 08000000 1c000000 3c000000  ._..........<...\n 0040 00000000 37000000 00450e10 8602430d  ....7....E....C.\n 0050 066e0c07 08000000                    .n......        \n\nDisassembly of section .text:\n\n0000000000000000 <func1>:\n   0:   f3 0f 1e fa             endbr64 \n   4:   55                      push   %rbp\n   5:   48 89 e5                mov    %rsp,%rbp\n   8:   48 83 ec 10             sub    $0x10,%rsp\n   c:   89 7d fc                mov    %edi,-0x4(%rbp)\n   f:   8b 45 fc                mov    -0x4(%rbp),%eax\n  12:   89 c6                   mov    %eax,%esi\n  14:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 1b <func1+0x1b>\n  1b:   b8 00 00 00 00          mov    $0x0,%eax\n  20:   e8 00 00 00 00          callq  25 <func1+0x25>\n  25:   90                      nop\n  26:   c9                      leaveq \n  27:   c3                      retq   \n\n0000000000000028 <main>:\n  28:   f3 0f 1e fa             endbr64 \n  2c:   55                      push   %rbp\n  2d:   48 89 e5                mov    %rsp,%rbp\n  30:   48 83 ec 10             sub    $0x10,%rsp\n  34:   c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%rbp)\n  3b:   8b 15 00 00 00 00       mov    0x0(%rip),%edx        # 41 <main+0x19>\n  41:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 47 <main+0x1f>\n  47:   01 c2                   add    %eax,%edx\n  49:   8b 45 f8                mov    -0x8(%rbp),%eax\n  4c:   01 c2                   add    %eax,%edx\n  4e:   8b 45 fc                mov    -0x4(%rbp),%eax\n  51:   01 d0                   add    %edx,%eax\n  53:   89 c7                   mov    %eax,%edi\n  55:   e8 00 00 00 00          callq  5a <main+0x32>\n  5a:   8b 45 f8                mov    -0x8(%rbp),%eax\n  5d:   c9                      leaveq \n  5e:   c3                      retq  \n```\n'Contents of section .text'部分就是用十六进制将.text section的内容打印出来。\n\n### .data section / .rodata section\n.data section存储已经初始化的全局静态变量和局部静态变量。.rodata section存放只读数据，如字符串字面量、使用了const修饰的只读变量等。\n\n### .bss section\n.bss存放未初始化的全局变量和未初始化的局部静态变量，比如示例中的global_uninit_var和static_var2就存在.bss section中。\n\n### 自定义section\n1. 将二进制数据拷贝到目标文件中： objcopy -I binary -O elf64-x86-64 -B i386 image.jpg hello.o\n2. 在C语言中显式地指定变量的section:\n   ```\n   __attribute__((setion(\"FOO\")) int global = 42;\n   __attribute__((section(\"BAR\"))) void foo() {}\n   ```\n\n\n## ELF文件格式\n\n### 文件头（File header）\n方法： 使用readelf命令来查看elf文件： readelf -h hello.o\n```\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00                  // EFL魔数\n  Class:                             ELF64                                  // 机器的字长\n  Data:                              2's complement, little endian          // 数据存储方式\n  Version:                           1 (current)                            // 版本\n  OS/ABI:                            UNIX - System V                        // 运行平台\n  ABI Version:                       0                                      // ABI版本\n  Type:                              REL (Relocatable file)                 // ELF重定位类型\n  Machine:                           Advanced Micro Devices X86-64          // 硬件平台\n  Version:                           0x1                                    // 硬件平台版本\n  Entry point address:               0x0                                    // 入口地址\n  Start of program headers:          0 (bytes into file)                    // 程序头入口和长度\n  Start of section headers:          1184 (bytes into file)                 // section表的位置和长度\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           64 (bytes)\n  Number of section headers:         14                                     // section的数量\n  Section header string table index: 13\n```\n\n\n### section表(section header table)\n保存各个section的基本属性信息，比如section名字、长度、在文件中的偏移、读写权限等等。\n获取section表的信息：  readelf -S hello.o\n```\nThere are 14 section headers, starting at offset 0x4a0:\n\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       000000000000005f  0000000000000000  AX       0     0     1\n  [ 2] .rela.text        RELA             0000000000000000  00000380\n       0000000000000078  0000000000000018   I      11     1     8\n  [ 3] .data             PROGBITS         0000000000000000  000000a0\n       0000000000000008  0000000000000000  WA       0     0     4\n  [ 4] .bss              NOBITS           0000000000000000  000000a8\n       0000000000000004  0000000000000000  WA       0     0     4\n  [ 5] .rodata           PROGBITS         0000000000000000  000000a8\n       0000000000000006  0000000000000000   A       0     0     1\n  [ 6] .comment          PROGBITS         0000000000000000  000000ae\n       000000000000002b  0000000000000001  MS       0     0     1\n  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000d9\n       0000000000000000  0000000000000000           0     0     1\n  [ 8] .note.gnu.propert NOTE             0000000000000000  000000e0\n       0000000000000020  0000000000000000   A       0     0     8\n  [ 9] .eh_frame         PROGBITS         0000000000000000  00000100\n       0000000000000058  0000000000000000   A       0     0     8\n  [10] .rela.eh_frame    RELA             0000000000000000  000003f8\n       0000000000000030  0000000000000018   I      11     9     8\n  [11] .symtab           SYMTAB           0000000000000000  00000158\n       00000000000001b0  0000000000000018          12    12     8\n  [12] .strtab           STRTAB           0000000000000000  00000308\n       0000000000000072  0000000000000000           0     0     1\n  [13] .shstrtab         STRTAB           0000000000000000  00000428\n       0000000000000074  0000000000000000           0     0     1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  l (large), p (processor specific)\n```\n这里面，需要关注一下的是section的类型，即Type这个属性。由于section的名字可以自定义，我们的系统是通过section的Type来确认这个section是干嘛用的。另外，Flags这个属性指示了这个section在进程虚拟地址空间中的属性，比如是否可写、是否可执行等等。Link和Info两个属性指示了该section如何进行链接，具体的组合有点复杂，这里略去。\n\n### 重定位表(Relocation Table)\n.rela.text这个section的Type属性是RELA，说明这个section是一个重定位表（Relocation Table）。这个section指示了链接器需要对那些内容进行怎样的重定位。需要说明的是，.rela.text这个section是针对.text section中那些需要重定位的内容设置的，同理，如果需要对.data section进行重定位，那么也会有一个.rela.data section来提供这些信息。\n\n### 字符串表\n上面例子中的.strtab和.shstrtab section就是字符串表，用来存储普通的字符串。\n\n## 符号\n函数和变量都是符号。链接的过程就是让引用符号的人找到符号定义的地址的过程。\n每个目标文件都会有一个符号表（Symbol Table），用来记录目标文件需要使用到的符号。每个符号都有一个对应的值，叫做符号值（Symbol Value）。对于函数和变量来说，符号值就是它们的地址。\n除了函数和变量，还有其他种类的符号，它们分别是：\n - 定义在本目标文件中的全局符号，可以被其他目标文件引用。比如示例中的func1, main, global_init_var\n - 在本目标文件中引用的全局符号，但是却没有在本目标文件中定义，这种称为外部符号。比如示例中的printf\n - section名字，由编译器产生，它的值就是该section的起始地址。比如.text, .data\n - 局部符号，这种符号只能一个编译单元内部看到。比如static_var, static_var2。局部符号在链接过程是不可见的，链接器会直接忽略它们。\n - 行号信息，目标文件中的指令预源代码中的行号的对应信息\n  \n链接器最关心是上面的第一种和第二种符号。\n\n### 符号表结构\n符号表就是上面例子中的.symtab section。它的内容也是一个数组，数组中的每个元素包含以下几个关键信息： \n- 符号类型和绑定信息（st_info）:说明是不是外部的、弱引用的，同时还说明该符号是个啥类型\n- 符号所在section(st_shndx): 如果符号是在本目标文件中定义，那这个字段会指示其所在的是那个section。如果不是，那该字段会是几个特殊的值。\n- 符号值（st_value）: 对于变量和函数，就是它们的地址。\n\n可以通过readelf -s hello.o来看目标文件中的符号。\n```\nSymbol table '.symtab' contains 18 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 \n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 \n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 \n     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 \n     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1922\n     7: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 static_var2.1923\n     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 \n     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 \n    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 \n    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 \n    12: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_int_var\n    13: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var\n    14: 0000000000000000    40 FUNC    GLOBAL DEFAULT    1 func1\n    15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_\n    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND print\n    17: 0000000000000028    55 FUNC    GLOBAL DEFAULT    1 main\n```\n\n### 特殊符号\n有很多由链接器ld为我们内置的符号，我们甚至可以直接在代码中引用它们。\n- __executable_start: 程序的起始地址，不是入口地址，是指程序的最开始的地址\n- __etext: .text section的结束地址\n- _edata: .data section的结束地址\n- _end/end: 程序的结束地址\n上面的这些地址都是在程序状态完成之后，操作系统为我们分配的虚拟地址。\n\n### 符号修饰和函数签名\n简单来说，为了避免我们自己写的函数名、变量名和系统中内置的库中的函数名、变量名重复，编译器会在编译的时候给我们自定义的符号名修饰一下。\nC++的修饰方法：\n1. 函数签名： 函数签名包括了它的函数名、参数类型、所在的类、命令空间等等信息。\n   举个几个例子：\n   - int func(int) -> _Z4funci\n   - float func(float) -> _Z4funcf\n   - int C::func(int) -> _ZN1C4funcEi\n   - int C::C2::func(int) -> _ZN1C2C24funcEi\n   - int N::func(int) -> _ZN1N4funcEi\n   - int N::C::func(int) -> _ZN1N1C4funcEi\n   这个修饰的规律是： C++的修饰风格都以_Z打头，对于嵌套的名字；后面会加一个N，然后接命令空间或者类的名字，这里的名字前面的数字是指这个名字的长度；最后会以E结尾。参数列表会紧跟在E的后面。\n   有个工具叫c++filt可以帮我们翻译被修饰过的名字。\n\n### extern \"C\"\n这个语句是C++中用来声明和C兼容的语句的时候使用的。在使用了这个语句的大括号内的语句，C++编译器不会启动符号修饰机制。\n\n\n# 静态链接过程\n代码片段A：\n```\nextern int shared;\nint main() {\n     int a = 100;\n     swap(&a, &shared);\n}\n```\n编译： gcc -c a.c -fno-stack-protector -o a.o\n\n代码片段B：\n```\nint shared = 1;\nvoid swap (int *a, int * b) {\n     *a ^= *b ^= *a ^= *b;\n}\n```\n编译： gcc -c b.c -fno-stack-protector -o b.o\n\n## 空间与地址分配\n\n### 空间占用与分配\n在上文中，我们提到.text section和.data section，它们的空间占用很好理解： 它们中都存储了具体的内容，这些内容需要多少空间来存储，对应就有多少空间被占用。\n但是对于.bss section，它自身是没有包含内容的，它的空间占用如何理解？\n.bss section本身在obj文件和最终的输出文件中，都是不占用空间的，因为未初始化的数据，都是以0表示。为了节省，obj文件和输出文件都会用一句话描述'这里有多少个0'来描述.bss section，而不会实际去存那么多个0.\n但是，当最终输出的可执行文件装载并执行的时候，运行时的.bss section是会去申请内存空间的，并且有多少个0就会申请多少字节的空间。运行时申请的空间是虚拟地址空间。为了统一，下文在描述‘空间分配’问题时，都是只关注虚拟地址空间的分配。因此，在讨论空间分配问题的时候，.bss section也是需要考虑的。\n\n### 相似段合并\n上述A片段在编译之后的obj文件中会有.text, .data, .bss等section； 同样的，B片编译后产生的obj文件中也会有.text, .data, .bss等section。如何将A.obj和B.obj一起存放到输出文件中？这个是链接器需要解决的问题。\n现代链接器通常都会采用‘相似段合并’的策略，即A.obj中的.text section与B.obj中的.text section合并成为输出文件中的.text section。同样的，.data section和.bss section也会有这样一个相似段合并的过程。\n\n### 两步链接法\n采用了相似段合并的链接器，一般会采用一种‘两步链接法’：\n1. 分配空间与地址： \n   - 扫描所有输入文件，获取它们各个section的长度、属性和位置\n   - 获取所有输入文件中的符号表中的符号定义和符号引用，并统一放到一个全局符号表中\n   - 计算出输出文件中各个section所需的长度和对应的位置，并将记录输入文件中的各个section的映射关系\n\n2. 符号解析和重定位：\n   - 读取输入文件中section中的数据和重定位信息\n   - 进行符号解析、重定位、调整地址\n\n### 链接命令\nld a.o b.o -e main -o ab\n\n其中，-e声明了入口函数的名字， “-o ab”声明了输出文件的名字\n\n### 链接后的地址变化\na.o: 通过objdump -h a.o查看信息\n```\na.o:     file format elf64-x86-64\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         00000055  0000000000000000  0000000000000000  00000040  2**0\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  1 .data         00000000  0000000000000000  0000000000000000  00000095  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  0000000000000000  0000000000000000  00000095  2**0\n                  ALLOC\n  3 .comment      0000002b  0000000000000000  0000000000000000  00000095  2**0\n                  CONTENTS, READONLY\n  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000c0  2**0\n                  CONTENTS, READONLY\n  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000c0  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000e0  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n```\n\nb.o: 通过objdump -h b.o查看信息：\n```\nb.o:     file format elf64-x86-64\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .data         00000004  0000000000000000  0000000000000000  00000090  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  0000000000000000  0000000000000000  00000094  2**0\n                  ALLOC\n  3 .comment      0000002b  0000000000000000  0000000000000000  00000094  2**0\n                  CONTENTS, READONLY\n  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000bf  2**0\n                  CONTENTS, READONLY\n  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000c0  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000e0  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n```\n在链接之前，a.o的各个section,其VMA都是0，对应的，b.o也是。但是在链接之后，我们可以看下ab文件的内容： objdump -h ab\n```\nab:     file format elf64-x86-64\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .note.gnu.property 00000020  00000000004001c8  00000000004001c8  000001c8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  1 .text         00000040  0000000000401000  0000000000401000  00001000  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  2 .eh_frame     00000058  0000000000402000  0000000000402000  00002000  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  3 .data         00000004  0000000000404000  0000000000404000  00003000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  4 .comment      0000002a  0000000000000000  0000000000000000  00003004  2**0\n                  CONTENTS, READONLY\n```\n在链接之后，可执行文件的VMA地址已经确定下来。并且这个VMA地址是可执行文件在装载完成进入运行时后会对应的虚拟地址空间的地址。在这里可以看到，.text的VMA地址是0000000000401000，这个应该是约定好的x86-64系统中可执行文件的入口地址。\n\n### 符号地址的确定\n两步链接法中的第二部，是在各个section的VMA确定之后，开始确定各个符号的虚拟地址。\n各个符号在各自的section的偏移地址是确定的(这个信息很重要)，因此，在我们的例子中，‘main’、‘shared’、‘swap’的地址可以通过section+内部偏移的方式计算出来。\n\n## 符号解析与重定位\n\n### 重定位\n必须以例子才能讲明白重定位的过程。\n在链接发生之前，a.o的内容，可以通过 objdump -d a.o 来反汇编查看其中的逻辑：\n```\na.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 <main>:\n   0:   f3 0f 1e fa             endbr64                                         # 不太明白\n   4:   55                      push   %rbp                                     # 这一行和下面的一行是在初始化栈帧。rbp在上，rsp在下。上面为高地址，下面为低地址\n   5:   48 89 e5                mov    %rsp,%rbp\n   8:   48 83 ec 10             sub    $0x10,%rsp                               # 0x10对应10进制中的16，这里将rsp下移16是为了给main函数分配栈空间。其实这里main函数根本不需要在栈上申请空间（没有局部变量），\n                                                                                # 至于为啥这里还要再申请16字节的栈，可能有什么特别的原因。搞不太明白\n   c:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)                         # 将rbp[-4]的值设置成100(0x64)，由于rbp是在最上面的，rbp[-4]其实就是: int a = 100;\n  13:   48 8d 45 fc             lea    -0x4(%rbp),%rax                          # 将rpb[-4]的地址记录在rax中。上面说过rbp[-4]是a，所以这里取地址就是对应于 &a\n  17:   48 8d 35 00 00 00 00    lea    0x0(%rip),%rsi        # 1e <main+0x1e>   # 将rip[0]的地址记录在rsi中。rip寄存器记录的是当前执行位置，生成的注释中也说明了，当前的执行位置为<main+0x1e>\n                                                                                # rip[0]这个地址是什么呢？其实这个例子中编译器也猜不出来，这里就随便用了rip[0]来代表swap函数的shared参数（rsi一般用来记录参\n                                                                                # 数）。这个就是后面着重要介绍的符号重定位\n  1e:   48 89 c7                mov    %rax,%rdi                                # 上面我们说了，rax这里记录的是&a，所以这里是为了提供swap函数的另一个参数： &a\n  21:   b8 00 00 00 00          mov    $0x0,%eax                                # 清空eax。eax一般用来在函数中记录返回值\n  26:   e8 00 00 00 00          callq  2b <main+0x2b>                           # 这里就去调用swap函数了。这里调用的地址是<main+0x2b>。这里这样记录地址，也是后面需要着重介绍的符号重定位\n  2b:   b8 00 00 00 00          mov    $0x0,%eax                                # 这里就设置main函数的返回值了，默认是0\n  30:   c9                      leaveq \n  31:   c3                      retq   \n```\n\n我们再看一下链接之后的反汇编代码：\n```\nab:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000401000 <main>:\n  401000:\tf3 0f 1e fa          \tendbr64 \n  401004:\t55                   \tpush   %rbp\n  401005:\t48 89 e5             \tmov    %rsp,%rbp\n  401008:\t48 83 ec 10          \tsub    $0x10,%rsp\n  40100c:\tc7 45 fc 64 00 00 00 \tmovl   $0x64,-0x4(%rbp)\n  401013:\t48 8d 45 fc          \tlea    -0x4(%rbp),%rax                                   # 这里还是&a\n  401017:\t48 8d 35 e2 2f 00 00 \tlea    0x2fe2(%rip),%rsi        # 404000 <shared>        # 这个生成的汇编注释都说了，这里是在&shared。至于这里的地址‘404000’，应该是shared这个变量在.data section中的 \n                                                                                            # 地址。也就是说，这里已经发生了重定位了\n  40101e:\t48 89 c7             \tmov    %rax,%rdi\n  401021:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401026:\te8 07 00 00 00       \tcallq  401032 <swap>                                     # 这里重定位之后，也已经替换成<swap>了。401032，恰好就是下面的swap在.text section中的起始地址\n  40102b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401030:\tc9                   \tleaveq \n  401031:\tc3                   \tretq   \n\n0000000000401032 <swap>:\n  401032:\tf3 0f 1e fa          \tendbr64 \n  401036:\t55                   \tpush   %rbp\n  401037:\t48 89 e5             \tmov    %rsp,%rbp\n  40103a:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n  40103e:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n  401042:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  401046:\t8b 10                \tmov    (%rax),%edx\n  401048:\t48 8b 45 f0          \tmov    -0x10(%rbp),%rax\n  40104c:\t8b 00                \tmov    (%rax),%eax\n  40104e:\t31 c2                \txor    %eax,%edx\n  401050:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  401054:\t89 10                \tmov    %edx,(%rax)\n  401056:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  40105a:\t8b 10                \tmov    (%rax),%edx\n  40105c:\t48 8b 45 f0          \tmov    -0x10(%rbp),%rax\n  401060:\t8b 00                \tmov    (%rax),%eax\n  401062:\t31 c2                \txor    %eax,%edx\n  401064:\t48 8b 45 f0          \tmov    -0x10(%rbp),%rax\n  401068:\t89 10                \tmov    %edx,(%rax)\n  40106a:\t48 8b 45 f0          \tmov    -0x10(%rbp),%rax\n  40106e:\t8b 10                \tmov    (%rax),%edx\n  401070:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  401074:\t8b 00                \tmov    (%rax),%eax\n  401076:\t31 c2                \txor    %eax,%edx\n  401078:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  40107c:\t89 10                \tmov    %edx,(%rax)\n  40107e:\t90                   \tnop\n  40107f:\t5d                   \tpop    %rbp\n  401080:\tc3                   \tretq   \n\n```\n\n### 重定位表\nELF文件通过重定位表来说明那些section中的哪些符号需要如何重定位。每个需要被重定位的section都有一个对应的重定位表。而重定位表通常也是ELF文件中的一个单独的section： 举个例子，加入.text section需要重定位，那会存在一个对应的.rel.text section, 这个.rel.text section就是一个重定位表。可以通过命令objdump -r a.o来查看一个目标文件的重定位表信息:\n```\na.o:     file format elf64-x86-64\n\nRELOCATION RECORDS FOR [.text]:                                   // .text说明要被重定位的符号是在.text section中\nOFFSET           TYPE              VALUE \n000000000000001a R_X86_64_PC32     shared-0x0000000000000004     // offset表示了这个要被重定位的符号现在在哪里\n0000000000000027 R_X86_64_PLT32    swap-0x0000000000000004\n\n\nRELOCATION RECORDS FOR [.eh_frame]:\nOFFSET           TYPE              VALUE \n0000000000000020 R_X86_64_PC32     .text\n\n```\n这个命令列出了a.o的所有需要重定位的符号。上面的这个例子中就包括： .text section中的两个外部符号shared和swap，.eh_frame中的一个符号.text。\n\n\n### 符号的解析\n简单来说，就是要让程序找到某个符号存储在哪里。举个例子，上面的重定位过程中，重定位表是记录了重定位前符号的offset的，但是重定位后符号的位置是会发生改变的，因此链接器就需要确定这个符号的地址改变后会在哪里。\n链接器是怎么做的呢？链接器会先去找全局符号表，如果发现有这个符号，但是符号是未定义的，说明这个符号等待被重定位。如果没找到，那链接器就会报错。\n\n### 指令的修正方式\n我们上面通过objdump -r a.o查看重定位表的时候，有一个信息，即TYPE那一栏中，有R_X86_64_PC32/R_X86_64_PLT32这样的信息。这个就是代表指令的修正方式。这部分的内容涉及到CPU指令的寻址方式。\nR_X86_64_PC32： 相对寻址修正 S+A-P。其中，A代表‘保存在被修正位置的值’， P代表‘被修正的位置（即offset）’，S代表‘符号的实际地址（即该重定位入口的符号在符号表中的下标）’\n修正的具体方式，还得参考下芯片手册。\n\n## 链接过程控制\n\n### 链接器控制脚本\n要控制链接器的行为一般有3中方案：\n- 给链接命令设置命令行参数，比如ld链接器的-o, -e参数等等\n- 将链接的命令存放在obj文件中，编译器负责将命令传递给链接器。windows平台的COFF文件中会这么用\n- 使用链接器控制脚本。这是本节重点介绍的内容\n\n### 查看默认的链接器脚本\n使用命令 ld -verbose可以查看默认的链接器脚本内容。这个脚本的内容有点多，一般可以取目录/usr/lib/ldscripts下面看到源文件。\n我们可以在调用ld命令的时候显式声明我们自定义的链接器脚本文件：  ld -T link.script\n\n### 最小的程序\n```\nchar* str = \"Hello World!\\n\";\n\nvoid print() {\n  asm(\"movl $13, %%edx \\n\\t\"\n    \"movl %0, %%ecx \\n\\t\"\n    \"movl $0, %%ebx \\n\\t\"\n    \"movl $4, %%eax \\n\\t\"\n    \"int $0x80 \\n\\t\"\n    ::\"r\"(str):\"edx\", \"ecx\", \"ebx\"\n  );\n}\n\nvoid exit() {\n  asm(\"movl $42, %ebx \\n\\t\"\n    \"movl $1, %eax \\n\\t\"\n    \"int $0x80 \\n\\t\");\n}\n\nvoid nomain() {\n  print();\n  exit();\n}\n```\n编译方法： gcc -fno-builtin -c test.c -m32\n链接方法： ld -static -e nomain test.o -o test -m elf_i386\n\n\n### 链接器脚本编写\n我们现在为上面的代码编写一个TinyHelloWorld.lds链接器脚本。\n```\nENTRY(nomain) \n\nSECTIONS\n{\n  . = 0x08048000 + SIZEOF_HEADERS;\n  tinytext : { *(.text) *(.data) *(.rodata) }\n  /DISCARD/ : { *(.comment) }\n}\n```\n这三句话的含义：\n1. . = 0x08048000 + SIZEOF_HEADERS: 将当前虚拟地址设置成0x08048000 + SIZEOF_HEADERS。SIZEOF_HEADERS这个变量代表输出文件的文件头大小。‘.’表示当前虚拟地址。这样设置之后，下一句话的地址就会变成我们设置过的0x08048000 + SIZEOF_HEADERS了\n2. tinytext: { *(.text) *(.data) *(.rodata) }: 这第二条语句定义了一个section的转换规则，这里是将.text, .data, .rodata三个section依次合并到输出文件的.tinytext section中\n3. /DISCARD/ : { *(.comment) }： 这第三句话定义了一个丢弃规则，这里是将输入文件中名为.comment的section内容丢弃，不拼接到输出文件中。\n\n定义好lds之后，我们就可以这样链接了：\nld -static -T TinyHelloWorld.lds -o test test.o\n\n\n### 链接器脚本语法\n链接器脚本有两种语句：\n1. 命令语句\n2. 赋值语句\n语句之间使用分号作为分隔符。有表达式与运算符，比如+,-,*,/,+=,*=,&,|,>>,<<等等。可以使用注释，与C语言类似，使用/**/注释。\n命令语句略微复杂一些。上面的例子中的ENTRY(nomain)就是一个命令语句。同理，SECTIONS{}也是一个命令语句。\n常用的命令语句包括：\n- ENTRY(symbol)\n- STARTUP(filename)\n- SEARCH_DIR(path)\n- INPUT(file, file,...)\n- INCLUDE filename\n- PROVIDE(symbol): 在链接脚本中定义某个符号，定义的符号可以在程序中被引用。\n\nSECTION命令的语法为：\nSECTIONS\n{\n  ...\n  secname : {contents}\n  ...\n}\n\n其中，secname表示输出section的名字，后面必须接一个空格符，这样可以保证提供的输出section名字不会有歧义。后面必须紧跟着冒号和大括号。大括号里面的contents描述了一套规则和条件： 所有符合这种条件和规则的输入section都会合并到secname中。secname的命名方法必须符合输出文件的格式要求。\n上面出现了一个特殊的输出section名字： /DISCARD/，如果使用这个名字作为输出section的名字，那么所有符合后面定义的规则的输入section都会被丢弃，不编排到输出文件中。\n\n从上面的描述可以看出，关键的内容还是contents这个描述规则和条件的内容。contents中可以包含多个条件，每个条件之间以空格隔开，如果输入section满足任何一个条件都可以被编排到输出文件中。contents的写法如下：\nfilename(sections)\n其中，filename代表输入文件名，sections代表输入section的名字。神奇的是，这个匹配规则可以使用正则:-)\n比如：  [a-z]*(.text*[A-Z])\n\n### BFD库\n简单来说，BFD(Binary File Descriptor library)库是一个GNU项目，目标是希望通过一种统一的接口来处理不同的目标文件格式。BFD本身是binutils项目的一个子项目。目前GNU的多个项目，包括汇编器gas,链接器ld，调试器gdb，binutils底层都是使用的BFD库。Ubuntu下BFD库有一个C语言开发库叫binutils-dev。","tags":["books"]},{"title":"The-GNU-linker","url":"/2021/07/25/The-GNU-linker/","content":"\n- [简介](#简介)\n- [使用方法](#使用方法)\n  - [命令行选项](#命令行选项)\n  - [环境变量](#环境变量)\n- [链接器脚本](#链接器脚本)\n  - [链接器脚本的一些基本概念](#链接器脚本的一些基本概念)\n  - [链接器脚本格式](#链接器脚本格式)\n  - [简单的链接器脚本示例](#简单的链接器脚本示例)\n  - [简单的链接器脚本命令](#简单的链接器脚本命令)\n  - [设置程序入口](#设置程序入口)\n  - [文件处理相关命令](#文件处理相关命令)\n  - [obj文件格式处理命令](#obj文件格式处理命令)\n  - [设置内存区域的别名](#设置内存区域的别名)\n  - [其他的链接器脚本命令](#其他的链接器脚本命令)\n\nGNU链接器\n作者： Steve Chamberlain, Ian Lance Taylor.   @Red Hat Inc\n\n\n# 简介\nld链接器可以组合一组object文件和archive文件，重定位这些文件中的数据，重新绑定这些文件中的符号引用。通常在编译一个程序的最后阶段就是运行ld链接器程序。\n\nld会读取一个‘Linker Command Language’所写的文件作为输入，这个语言是AT&T Linker Editor Command Language的一个语法超集。这个文件会提供控制链接的全部过程。目前版本的ld使用通用的BFD库来操作目标文件。BFD库提供了ld链接器所需要的各种格式（比如COFF、a.out格式）的文件读取、拼接、写obj文件的功能。不同格式的文件也可以链接到一起来产生一个可用类型的obj文件。\n\n相比较与其他链接器，ld不仅使用灵活，还提供了很多很有用的诊断类信息。很多其他的链接器会在遇到error的时候会理解停止执行，但是ld会继续执行，这样可以让你看看后面是不是还会由其他错误。有些时候，尽管出现了错误，最后还是会产生一个输出文件。\n\n# 使用方法\nld注定是要处理各种各样的链接场景，然后还得尽可能的保证和其他链接器兼容。最后的结果就是，你有多种方式来控制它的行为。\n\n## 命令行选项\nld支持非常多的命令行选项，但是实际上只有非常少的一部分是在任何场景中都适用的。举个例子，ld常用来链接标准的Unix obj文件，在Unix系统中，链接一个文件hello.o是这样使用的：\n`ld -o output /lib/crt0.o hello.o -lc`\n\n这个命令会告诉ld产生一个名为ouput的输出文件作为链接的结果，链接的过程是将文件/lib/crt0.o，hello.o和标准搜索目录下的库libc.a链接在一起。\n\nld的一些命令行参数可以在命令的任何位值声明。不过呢，用来修饰文件的参数，比如-l, -T，这些参数会决定ld在什么时候读取文件，因此这些参数的出现顺序和位置是有讲究的。重复的非文件修饰参数，如果有不同的值，那么这些声明的参数要么就都不起效果，由么就是后面的覆盖前面的效果。一些特殊情况的命令行参数会在下面单独说明。\n\n必选的参数是Obj文件或者archive归档文件，这些文件会最终被链接到一起。它们可以跟在命令行参数后面，也可以放在命令行参数前面，也可以交叉着来。但是文件不能放在命令行选项和它们的值之间。\n\n通常至少提供了一个obj文件链接器彩绘启动，但是你可以通过-l, -R参数来声明其他类型的二进制文件来作为输入文件，然后通过链接脚本来控制链接过程。如果没有一个二进制文件作为输入，那链接器不会产生任何输出文件，并且会声明一个错误： no input files.\n\n如果链接器不能识别obj文件的格式，那么ld会将这个文件识别为一个链接器参数脚本。链接器参数脚本声明了链接过程中使用的各种参数（注意区别下链接器参数脚本和默认的链接器脚本，以及由参数-T声明的链接器脚本）。有了这样的机制，链接器就可以链接那些只定义了一些符号，或者通过INPUT和GROUP来引入其他Obj文件的obj文件或archive文件。这种方式只提供给链接脚本一些使用的参数，然后使用-T选项来替换整个默认的链接脚本，但是需要注意INSERT命令的副作用。\n\n对于那些单个字母的命令行参数，可以使用一个短横线或者两个短横线来标识，比如，--trace-symbol和-trace-symbol是等价的。注意，这个规则有一个例外情况：以小写的o打头的多个字母的命令行选项必须以两个短横线来标识。这个是为了避免和-o选项弄混淆。举个例子,-omagic选项是声明输出文件名为magic，但是--omagic选项的作用是设置输出文件中的NMAGIC flag。\n\n多个字母的命令行选项的参数必须用等号来和选项自身分隔开，或者让参数紧跟着命令行选项。比如，--trace-symbol foo和 --trace-symbol=foo 是等价的。多个字母的命令行选项一般可以缩写为一个没有歧义的选项。\n\n注意： 如果链接器是被间接调用的，比如通过一个编译器(gcc)驱动，那么所有的链接器命令行选项都必须以-Wl为前缀，举个例子： gcc -Wl,--start-group foo.o bar.o -Wl,--end-group\n这个规则很重要，因为如果不通过这种方式声明的话，编译器驱动的程序可能会悄悄地丢掉一些链接器参数，造成链接失败。在通过编译器传递一些选项参数的值的时候，有些时候会让人产生疑惑，甚至可能会将选项传递给链接器，但是选项的参数却传递给编译器了。在这种情况下，最简单的解决办法是使用单个短横线和多字母选项混合的方式，比如这样： gcc foo.o bar.o -Wl,-eENTRY -Wl,-Map=a.map\n\n下面是一些GNU链接器的通用命令行选项列表：\n@file: 从文件file中读取命令行选项。读入的命令行选项会插入到@file参数所在的位置。如果声明的文件不存在，或者无法读取，那这个@file选项会被当作字面量解释，而且不会自动被移除。\n文件file中的命令行选项以空白符隔开。单引号和双引号引起来的选项两边可以有空白字符。任何字符（包括反斜杠）都可以通过在字符前添加反斜杠的方式引入。参数file指定的文件中可以再包含file参数，这样的引用方式会以递归的形式展开\n\n-A architecture\n--architecture=architecture\n    目前版本的ld中，这个选项只在Intel 960系列CPU架构中有用。在使用这种参数的ld配置中，architecture参数声明了960系列中的具体CPU架构。\n\n-b input-format\n--format=input-format\n    ld可以通过配置来支持多种obj文件。如果你的ld通过这个参数进行配置的话，那-b选项可以声明输入的二进制Obj文件的格式。即使在需要ld支持多种obj格式的情况，你一般也不需要手动通过这个-b参数来显式地声明这些输入Obj的格式，这是因为ld的默认配置会根据各个机器的不同自动识别这个机器上常见的Obj格式。input-format参数是一个string文本，代表一个BFD库支持的特定的格式。你可以通过命令objdump -i命令来获取当前机器支持的所有二进制格式。\n\n...\n(选项太多，候选再补充)\n\n## 环境变量\n你可以通过环境变量GNUTARGET, LDEMULATION和COLLECTION_NO_DEMANGLE来改变ld的行为。\n\nGNUTARGET可以决定输入文件的格式，前提是你没有通过-b或者--format选项来声明输入文件的格式。这个环境变量的值必须是BFD中input format的一种。如果没有设置GNUTARGET环境变量的话，ld会使用默认的目标文件格式。如果GNUTARGET的值为default，那么BFD库会尝试自己检查二进制输入文件的格式；这种自动检查一般来说都是可以成功的，但是有些时候还是会失败，因为用来标识文件格式的magic number并不是统一和确定的。不过呢，BFD库中内置了各个系统中常见的格式，所以这种歧义一般可以通过约定俗成的规定来避免。\n\nLDEMULATION环境变量决定了默认的仿真功能（如果你不使用-m选项的话）。仿真功能可以影响链接器各个方面的行为，特别是默认的链接器脚本。你可以通过--verbose和-V选项来列出可用的仿真功能。如果没有使用-m选项，同时又没有设置LDEMULATION环境变量的话，仿真功能默认是由链接器自身的配置决定。\n\n正常情况下，链接器由默认的识别符号的方式。然而，如果设置了COLLECT_NO_DEMANGLE环境变量，那链接器默认会不自己识别符号。这个环境变量的gcc链接器wrapper程序中被广泛的使用。这个环境变量的值可以被--demangle和--no-demangle选项覆盖。\n\n# 链接器脚本\n链接过程由链接器脚本控制。链接器脚本是用‘链接命令语言’(the linker command language)撰写的。\n\n链接器脚本的主要目的是描述输入文件中的各个section怎么映射到输出文件中，然后如何控制输出文件中的内存布局。大多数的链接器脚本就干这两件事情。不过呢，在必要的时候，链接器脚本也可以使用下面的命令来指导链接器做一些其他的操作。\n\n一般来说，链接器都会使用一个链接器脚本。如果你没有自定一个链接器脚本的话，它会使用一个默认的脚本，这个脚本已经编译在ld命令的二进制程序中。你可以通过--verbose选项来展示默认的链接器脚本。一些命令行选项，比如-r和-N，可以影响默认的链接器脚本。\n\n你可以使用命令行选项-T来声明自定义的链接器脚本。当你这样声明的时候，你提供的链接器脚本会覆盖默认的链接器脚本。\n\n你可以通过将链接器脚本当作要被链接的输入文件这样的方式来隐式使用。\n\n## 链接器脚本的一些基本概念\n为了描述链接器脚本语言，我们需要定义一些基本的概念和词汇。\n\n链接器会将输入文件组合到一个单独的输出文件中。输出文件和各个输入文件都是obj格式文件。输入输出文件都可以被称为Obj文件，输出文件往往被称为可执行文件，不过我们的文档中也会将输出文件称为obj文件。每个obj文件都包括了一系列sections和一些其他东西。输入文件中的section称为输入section，输出文件中的section称为输出section。\n\nobj文件中的每个section都包含一个名字和一个大小。大多数section还包含一个相关的数据块，一般称为sectoin内容。section可以标记位‘可加载的’，这个是指当输出文件运行的时候这部分内容可以加载至内存中。一个没有任何内容的section可以是‘可分配的’，这是指内存中的这块区域需要单独设置，但是没有特别说明需要设置什么内容（一些情况下需要设置成0）。一个既不是可加载的也不是可分配的section一般都是包含一些调试信息。\n\n每个可加载的或者可分配的输出section都有两个地址。第一个地址称为VMA，即virtual memory address（虚拟内存地址）。这个地址定义了输出文件在运行的时候，这个section应该在哪个内存地址处。第二个地址是LMA，也称为load memory address。这个地址描述了这个section会被加载到哪个地址那里。大多数情况下这两个地址是相同的。它们俩不同的一种情况是： 当一个程序启动的时候，它的data section加载到ROM，然后又被加载到RAM中，就会出现这种情况。这个技术常常被一些基于ROM的系统用来初始化全局变量。这个案例中，ROM的地址应该是LMA，RAM的地址应该是VMA。\n\n可以使用objdump命令的-h选项来查看obj文件的各个section。每个Obj文件都有一个符号列表，即符号表。符号可以是定义的也可以是未定义的。每个符号都有一个名字，每个定义的符号都有一个地址以及一些其他信息。如果你是将一个C或者C++程序编译成obj文件，每个定义的函数和全局的或者静态变量都对应一个定义的符号。输入文件中的每个未定义的函数或者未定义的全局变量都会对应一个未定义符号。\n\n你可以使用nm程序来查看一个obj文件中的符号，或者使用objdump的-t选项来查看。\n\n## 链接器脚本格式\n链接器脚本是一个文本文件。\n\n你可以像写一系列命令一样来写一个链接器脚本。每个命令同时也是一个关键字，可以带参数，或者定义一个符号。可以通过分号分隔命令，空白字符一般会被忽略。\n\n文件名和格式名可以当作字符串直接输入。如果一个文件名中包含像逗号这样会切分字符串的字符，你需要将这个特殊的文件名通过双引号引起来。文件名中不能包含双引号。\n\n和C语言一样，你可以在链接器脚本中使用\"/*\"和\"*/\"来声明一段注释，同样的，注释也是会当作空白字符一样处理。\n\n## 简单的链接器脚本示例\n一般链接器脚本都相当简单。\n\n最简单的链接器脚本是只有一个命令的脚本： 'sections'。你可以使用sections命令来描述输出文件的内存布局。\n\nsections命令是一个很强的命令。我们简单演示一下它的用法。假设你的程序只包含代码、初始化数据和未初始化数据，它们分别放在.text，.data，和.bss sections中。\n\n这个例子中，我们假设代码需要在地址0x100000处加载，数据需要从0x8000000处开始。那我们可以写个这样的链接器脚本：\nsections\n{\n    . = 0x100000;\n    .text : {.*(.text)}\n    . = 0x8000000;\n    .data : {*(.data)}\n    .bss : {*(.bss}\n}\n首先，我们使用了命令section，紧接着我们在一对大括号内写了一系列符号的定义以及输出文件的secton描述。\n\n第一行section命令内部的设定了特殊符号“.”的值，这个“.”也被称作位置计数器。如果你没有使用一些其他的方法来声明输出section的地址的话，那这个地址会被设置成当前位置计数器的值。然后位置计数器的值会往上增加这个输出section大小的数值。在命令sections使用的地方，位置计数器的值是0.\n\n第二行定了一个输出section: .text。冒号是必须的。大括号内，你定义了需要放置在输出section内的输入section。“*”一个通配符，代表可以匹配任何名字。表达式“*(.text)”代表任何输入文件中的\".text\"输入section。\n\n由于\".text : {.*(.text)}\"这句话这里的位置计数器的值是“0x10000”，链接器会设置输出.text section的地址为0x100000。\n\n剩下的代码定义了输出文件的.data和.bss section。链接器会将输出文件中的.data section放在地址0x8000000处。之后，位置计数器的值会自动变为0x8000000加上.data输出section的大小。这样，.bss输出sectoin会立马紧接着放在.data输出section的内存地址后面。\n\n链接器通过自动增加位置计数器的方式来保证每个输出section都按要求对齐。这个例子中，.text和.data section会按照声明的方式进行对齐，但是链接器可能必须要在.data和.bss section中间预留一段间隙。\n\n就是这样！这就是一个简单但是完整的链接器脚本。\n\n## 简单的链接器脚本命令\n下面我们简单介绍一下连接器脚本中的命令。\n\n## 设置程序入口\n程序中执行的第一个指令称为程序的入口点(entry point)。你可以使用ENTRY链接器脚本命令来设置入口点。这个命令的参数是一个符号名：\nENTRY(symbol)\n有多种方式可以设置入口点。对于链接器来说，他会一个个按顺序的尝试下面的方法，直到有一个方法成功了：\n- 命令行选项: -e\n- 链接器脚本中的 ENTRY(symbol)命令\n- 符号start的值，如果没有设置那这个方法就不行\n- .text段的第一个字节的地址\n- 地址0\n\n## 文件处理相关命令\n下面几个命令是文件处理相关的：\n- INCLUDE filename: 在当前位置包含一个链接器脚本filename进来。文件的搜索路径为当前路径，以及通过命令行选项-L声明的文件路径。你可以嵌套执行INCLUDE命令，但是最多嵌套10层。\n你可以将INCLUDE命令放置在最外层： 在MEMORY或者SECTIONS命令中，或者在输出section的描述区域中。\n\n- INPUT(file, file, ...) / INPUT(file file ...): INPUT命令告诉链接器需要链接的文件列表。\n  举个例子，如果你想在链接的时候包含一个名为‘subr.o’的文件作为输入文件，但是呢，每次在命令行中写又太麻烦了，那么你就可以在链接器脚本中定义： INPUT(subr.o)\n  事实上，只要你愿意，你可以在链接器脚本中列出所有的输入文件，然后在命令行写命令的时候可以简单的使用-T选项就完事了。\n  在配置了sysroot prefix系统根目录前缀的情况下，如果你声明的文件名以'/'开头，并且当前链接器脚本又在根目录下，那列出的文件会被认为是在根目录下的。负责，链接器会尝试在当前目录下找文件。如果没有找到，链接器会尝试在默认的库搜索路径下搜索文件。可以参考下参数-L的行为。\n  如果你这样使用INPUT命令： INPUT(-lfile)，那ld链接器会将文件名翻译为libfile.a，这个是参数-l的行为\n  当你显式地在链接器脚本中使用INPUT命令时，当这些文件会在当前链接器脚本生效的时刻引入到链接过程。这个可能会对文件搜索又一点影响。\n\n- GROUP(file, file, ...) / GROUP(file file ...): GROUP命令鹤INPUT命令类似，就是参数中的文件必须是归档文件，并且这些文件会反复搜索直到没有新的未定义的符号引用被创建出来。\n\n- AS_NEEDED(file, file, ...) / AS_NEEDED(file file ...): 这个用法只能和其他文件名一起出现在INPUT或者GROUP命令中间。列出的文件会被当作INPUT和GROUP命令列出的文件一样被处理，除了EFL的共享链接库，共享链接库只会在它们被需要的时候才会加载。这个命令本质上是在命令行选项上启用了--as-needed选项，然后列出所有的文件名，之后启用--no-as-needed选项。\n\n- OUTPUT(filename): OUTPUT命令可以给输出文件命名。在链接器脚本中使用OUTPUT(filename)命令等价于在命令行中使用-o filename选项。如果两者都使用了的话，命令行选项的优先级更高。\n  你可以使用OUTPUT命令来设置一个默认的输出文件名，如果常见的a.out默认输出文件名就是这么设定的。\n\n- SEARCH_DIR(path): SEARCH_DIR命令会将参数path添加到链接器搜索归档库的路径中。SEARCH_DIR(path)的原理和命令行选项-L path的原理是一样的。如果两者都使用了的话，命令行选项的优先级更高。\n\n- STARTUP(filename): STARTUP命令和INPUT命令类似，但是STARTUP命令声明的文件filename会是第一个被链接的输入文件，就好像它是命令行参数中第一个被声明的文件一样。这个在那些默认入口点是第一个被链接的文件的系统中是很有用的。\n\n## obj文件格式处理命令\n有一对链接器脚本命令可以用来处理obj文件格式。\n- OUTPUT_FORMAT(bfdname) / OUTPUT_FORMAT(default, big, little): OUTPUT_FORMAT这命令声明了输出文件使用的BFD格式。使用OUTPUT_FORMAT(bfdname)的效果和使用‘--oformat bfdname’命令行选项的效果是一样的。如果两者都使用了的话，命令行选项的定义优先级更高。\n你可以在命令OUTPUT_FORMAT命令后加3个参数来声明不同的输出格式，对应于命令选项中的-EB和-EL选项。这个用法让链接器可以根据系统不同的大小端情况来选择不同的输出格式。\n如果-EB和-EL选项都没有使用的话，那么输出文件的格式会是第一个参数default声明的格式。如果使用了-EB选项，那么输出格式会是第二个参数big声明的格式。如果使用了-EL选项，那么输出文件的格式会是第三个参数litte声明的格式。\n举个例子，MIPS架构下的ELF目标文件的格式在默认的链接器脚本中是这么定义的： OUTPUT_FORMAT(elf32-bigmips, elf32-bigmips, elf32-littlemips)\n这个定义时说，默认的输出文件格式是‘elf32-bigmips’，但是如果在链接的时候使用了-EL命令行选项，那么输出文件的格式将会是elf32-littlemips格式。\n\n- TARGET(bfdname): TARGET命令声明了解析输出文件时的BFD格式，这个设置同时也会影响到INPUT和GROUP命令。这个命令的效果和'-b bfdname'命令行选项的效果是一样的。如果使用了TARGET命令但是没有使用OUTPUT_FORMAT命令，那么最后一个TARGET设置的格式也会作为输出文件的格式。\n\n## 设置内存区域的别名\n通过创建命令动态创建出来的内存区域可以设置一个别名。每个别名最多可以对应一个内存区域。\n使用方法： REGION_ALIAS(alias, region)\nREGION_ALIAS函数为参数region指定的内存区域创建出一个名为alias的别名。这种用法可以灵活的为输出文件中的内存区域设置一个映射表。下面是一个具体的例子。\n假设我们有一个嵌入式系统的应用，它包含多个内存存储设备。和其他系统一样，随机访问存储器RAM允许代码的执行或者数据的存储。有一些系统可能会有一个只读的、非随机访问的存储器ROM，它允许代码指令和只读数据的访问。然后可能还会有一个只读的、非随机访问的的存储设备ROM，它只允许读取只读数据，并且不允许代码执行。这样我们就需要4个输出section:\n - .text: 程序的代码\n - .rodata: 只读数据\n - .data: 已初始化的可读可写数据\n - .bss: 用0初始化过的可读可写数据\n我们的目标是提供一个链接器命令文件，这个文件包含一个系统无关的部分，这个部分需要定义output section；还需要定义一个系统相关的部分，这个部分定义了输出section和系统可用内存区域的映射关系。我们的嵌入式系统有3中不同存储设置方案A, B 和 C，这3种方法分别如下：\nSection      Variant A      Variant B        Variant C                         \n.text          RAM             ROM             ROM                         \n.rodata        RAM             ROM             ROM2                         \n.data          RAM           RAM/ROM           RAM/RO                         \n.bss           RAM             RAM             RAM                          \n这里的RAM/ROM或者RAM/ROM2意思是这个section可以依次加载到ROM或者ROM2中。请注意，这3种方法中的.data section都是紧接着.rodata的末尾的。\n\n下面是生成输出section的一个链接器脚本的示例。这个脚本中包含一个linkcmds.memory文件，这个文件与系统相关，它描述了具体的内存布局。\n\n```\nINCLUDE linkcmds.memory\n\nSECTIONS\n{\n  .text: \n  {\n    *(.text)\n  } > REGION_TEXT\n  .rodata:\n  {\n    *(.rodata)\n    rodata_end = .;\n  } > REGION_RODATA\n  .data : AT (rodata_end)\n  {\n    data_start = .;\n    *(.data)\n  } > REGION_DATA\n  data_size = SIZEOF(.data);\n  data_load_start = LOADADDR(.data);\n  .bss :\n  {\n    *(.bss)\n  } > REGION_BSS\n}\n```\n\n链接器脚本已经有了，现在我们需要提供3种不同的链接器命令文件linkcmds.memory来定义不同的内存布局和别名。A, B, C三种方法对应的文件分别如下：\n\nA方案：所有的内容都存储在RAM中。\n```\nMEMORY\n{\n  RAM : ORIGION = 0, LENGTH = 4M\n}\n\nREGION_ALIAS(\"REGION_TEXT\", RAM);\nREGION_ALIAS(\"REGION_RODATA\", RAM);\nREGION_ALIAS(\"REGION_DATA\", RAM);\nREGION_ALIAS(\"REGION_BSS\", RAM);\n```\n\nB方案：程序代码和只读数据存储在ROM中，可读写数据存储在RAM中。ROM中会存储一份用于初始化的数据，并且会在系统启动的时候拷贝到RAM中。\n```\nMEMORY\n{\nROM : ORIGIN = 0, LENGTH = 3M\nRAM : ORIGIN = 0x10000000, LENGTH = 1M\n}\nREGION_ALIAS(\"REGION_TEXT\", ROM);\nREGION_ALIAS(\"REGION_RODATA\", ROM);\nREGION_ALIAS(\"REGION_DATA\", RAM);\nREGION_ALIAS(\"REGION_BSS\", RAM);\n```\n\nC方案：程序代码存储在ROM中，只读数据存储在ROM2中。可读写数据存储在RAM中。ROM2中存储有一份用于初始化的数据，并且会在系统启动的时候加载到RAM中。\n```\nMEMORY\n{\nROM : ORIGIN = 0, LENGTH = 2M\nROM2 : ORIGIN = 0x10000000, LENGTH = 1M\nRAM : ORIGIN = 0x20000000, LENGTH = 1M\n}\nREGION_ALIAS(\"REGION_TEXT\", ROM);\nREGION_ALIAS(\"REGION_RODATA\", ROM2);\nREGION_ALIAS(\"REGION_DATA\", RAM);\nREGION_ALIAS(\"REGION_BSS\", RAM);\n```\n\n如果有必要的话，我们可以写一段可以通用的处理程序，用来在系统初始化的时候将数据从ROM或者ROM2的.data section拷贝到RAM中。这段程序可以这么写：\n```\n#include <string.h>\nextern char data_start [];\nextern char data_size [];\nextern char data_load_start [];\nvoid copy_data(void)\n{\n  if (data_start != data_load_start)\n  {\n    memcpy(data_start, data_load_start, (size_t) data_size);\n  }\n}\n```\n\n## 其他的链接器脚本命令\n还有一些其他的链接器脚本命令。\nASSERT(exp, message): 使用的时候必须保证exp的值不为0.如果是0的话，那链接器会将参数message的内容打印出来，并且抛出错误码，然后退出。\n\nEXTERN(symbol symbol ...): 强制将符号symbol作为一个undefined符号放入到输出文件中。有一些情况需要这样操作，比如想要触发链接器将一些标准库链接进来。你可以使用EXTERN来列出多个符号，也可以多次使用EXTERN命令。这个命令的效果和命令行参数-u是一样的。\n\nFORCE_COMMON_ALLOCATION: 这个命令和命令行选项-d的效果是一样的： 让ld链接器给通用符号预留空间，即使已已经通过-r选项声明了一个可重定位输出文件。\n\nINHIBIT_COMMON_ALLOCATION: 这个命令和命令行选项--no-define-common的效果是一样的： 让ld链接器忽略对通用符号的地址分配，即使声明了是一个不可重定位输出文件。\n\nINSERT [AFTER | BEFORE] output_section: 这个命令的典型使用场景是在一个-T声明的链接器脚本中，用来修饰SECTIONS命令的行为(比如overlays覆盖行为)。这个命令会将所有前面的链接器脚本语句插入到output_section参数声明的section之前（或者之后），同时会引起-T声明的链接器脚本不覆盖默认的链接器脚本。插入行为会发生在链接器将输入文件的section映射到输出文件的section完成之后。在插入之前，由于-T声明的链接器脚本会在默认的链接器脚本前面进行解析，因此-T声明的脚本中的语句会在默认的链接器脚本中的语句之前执行。特别的，-T声明的脚本中的输入section的分配会发生在默认链接器脚本的输入section分配之前。下面是一个例子，用来说明-T脚本是如何使用INSERT命令的。\n```\nSECTIONS\n{\n  OVERLAY :\n  {\n    .ov1 { ov1*(.text) }\n    .ov2 { ov2*(.text) }\n  }\n}\nINSERT AFTER .text;\n```\n"},{"title":"using as","url":"/2021/06/29/using-as/","content":"> Translated by zivyou. All rights reserved.\n> 由zivyou翻译，保留所有权利。\n\n\n- [Using as(The GNU Assembly)](#using-asthe-gnu-assembly)\n- [概要](#概要)\n  - [obj文件格式](#obj文件格式)\n- [语法](#语法)\n  - [预处理](#预处理)\n  - [符号](#符号)\n  - [表达式](#表达式)\n  - [常量](#常量)\n  - [字符常量](#字符常量)\n      - [字符串](#字符串)\n- [段(section)和重定位（relocation）](#段section和重定位relocation)\n  - [链接器专属section](#链接器专属section)\n  - [汇编器专属section](#汇编器专属section)\n  - [sub-sections](#sub-sections)\n  - [bss section](#bss-section)\n- [符号（Symbols）](#符号symbols)\n  - [标号（labels）](#标号labels)\n  - [给符号赋其他值](#给符号赋其他值)\n  - [符号名](#符号名)\n  - [特殊符号Dot（the special dot symbol）](#特殊符号dotthe-special-dot-symbol)\n  - [符号属性](#符号属性)\n    - [value属性](#value属性)\n    - [type属性](#type属性)\n    - [a.out的符号属性](#aout的符号属性)\n      - [descriptor](#descriptor)\n      - [其他](#其他)\n    - [COFF的符号属性](#coff的符号属性)\n      - [primary属性](#primary属性)\n      - [辅助性属性](#辅助性属性)\n- [表达式](#表达式-1)\n  - [空表达式](#空表达式)\n  - [整数表达式](#整数表达式)\n    - [参数(argument)](#参数argument)\n    - [操作符](#操作符)\n    - [前缀操作符](#前缀操作符)\n    - [中缀操作符](#中缀操作符)\n- [汇编器命令](#汇编器命令)\n  - [.abort](#abort)\n  - [.ABORT](#abort-1)\n  - [.align abs-expr, abs-expr, abs-expr](#align-abs-expr-abs-expr-abs-expr)\n  - [.ascii \"string\"...](#ascii-string)\n  - [.asciz \"string\"...](#asciz-string)\n  - [.balign[wl] abs-expr abs-expr, abs-expr](#balignwl-abs-expr-abs-expr-abs-expr)\n  - [.byte expressions](#byte-expressions)\n  - [.comm symbolX, lengthX](#comm-symbolx-lengthx)\n  - [.data subsectionX](#data-subsectionx)\n  - [.def nameX](#def-namex)\n  - [.desc symbolX, abs-expression](#desc-symbolx-abs-expression)\n  - [.dim](#dim)\n  - [.double flonums](#double-flonums)\n  - [.eject](#eject)\n  - [.else](#else)\n  - [.elseif](#elseif)\n  - [.end](#end)\n  - [.endef](#endef)\n  - [.endfunc](#endfunc)\n  - [.endif](#endif)\n  - [.equ symbolX, expression](#equ-symbolx-expression)\n  - [.equiv symbolX, expression](#equiv-symbolx-expression)\n  - [.err](#err)\n  - [.exitm](#exitm)\n  - [.extern](#extern)\n  - [.fail expression](#fail-expression)\n  - [.file stringX](#file-stringx)\n  - [.fill repeat, size, value](#fill-repeat-size-value)\n  - [.float flonums](#float-flonums)\n  - [.func name[, label]](#func-name-label)\n  - [.global symbolX / .globl symbolX](#global-symbolx--globl-symbolx)\n  - [.hidden names](#hidden-names)\n  - [.hword expressions](#hword-expressions)\n  - [.ident](#ident)\n  - [.if absolute expression](#if-absolute-expression)\n  - [.incbin \"file\"[, skip[, count]]](#incbin-file-skip-count)\n  - [.include \"file\"](#include-file)\n  - [.int expression](#int-expression)\n  - [.internal names](#internal-names)\n  - [.irp symbolX, values...](#irp-symbolx-values)\n  - [.irpc symbolX, values...](#irpc-symbolx-values)\n  - [.lcomm symbolX, length](#lcomm-symbolx-length)\n  - [.lflags](#lflags)\n  - [.line line-number](#line-line-number)\n  - [.linkonce [type]](#linkonce-type)\n  - [.ln line-number](#ln-line-number)\n  - [.mri val](#mri-val)\n  - [.list](#list)\n  - [.long expression.](#long-expression)\n  - [.macro](#macro)\n  - [.nolist](#nolist)\n  - [.octa bignums](#octa-bignums)\n  - [.org new-lc, fill](#org-new-lc-fill)\n  - [.p2align[wl] abs-expr, abs-expr, abs-expr](#p2alignwl-abs-expr-abs-expr-abs-expr)\n  - [.previous](#previous)\n  - [.popsection](#popsection)\n  - [.print string](#print-string)\n  - [.protected names](#protected-names)\n  - [.psize lines, columns](#psize-lines-columns)\n  - [.purgem name](#purgem-name)\n  - [.pushsection name, subsection](#pushsection-name-subsection)\n  - [.quad bignums](#quad-bignums)\n  - [.rept count](#rept-count)\n  - [.sbttl \"subheading\"](#sbttl-subheading)\n  - [.scl class](#scl-class)\n  - [.section name](#section-name)\n  - [.set symbol, expression](#set-symbol-expression)\n  - [.short expressions](#short-expressions)\n  - [.single flonums](#single-flonums)\n  - [.size](#size)\n  - [.sleb128 expressions](#sleb128-expressions)\n  - [.skip size, fill](#skip-size-fill)\n  - [.space size, fill](#space-size-fill)\n  - [.stabd, .stabn, stabs](#stabd-stabn-stabs)\n  - [.string \"str\"](#string-str)\n  - [.struct expression](#struct-expression)\n  - [.subsection name](#subsection-name)\n  - [.symver](#symver)\n  - [.tag structname](#tag-structname)\n  - [.text subsection](#text-subsection)\n  - [.title \"heading\"](#title-heading)\n  - [.type](#type)\n  - [.uleb128 expressions](#uleb128-expressions)\n  - [.val addr](#val-addr)\n  - [.version \"string\"](#version-string)\n  - [.vtable_entry table, offset](#vtable_entry-table-offset)\n  - [.vtable_inherit child, parent](#vtable_inherit-child-parent)\n  - [.weak names](#weak-names)\n  - [.word expressions](#word-expressions)\n- [80386架构相关的特性](#80386架构相关的特性)\n  - [命令行选项](#命令行选项)\n  - [AT&T汇编语法 vs Intel汇编语法](#att汇编语法-vs-intel汇编语法)\n  - [指令命名](#指令命名)\n  - [寄存器命名](#寄存器命名)\n  - [指令前缀](#指令前缀)\n  - [内存寻址](#内存寻址)\n  - [跳转类指令的处理](#跳转类指令的处理)\n  - [浮点数](#浮点数)\n  - [Intel的MMX指令集，以及AMD的 3DNow! SIMD操作](#intel的mmx指令集以及amd的-3dnow-simd操作)\n  - [用as写16位的汇编代码](#用as写16位的汇编代码)\n  - [AT&T的语法bug](#att的语法bug)\n  - [声明CPU架构](#声明cpu架构)\n  - [备注](#备注)\n# Using as(The GNU Assembly)\n\nBy Dean Elsner, Jay Fenlason & friends- [Using as(The GNU Assembly)](#using-asthe-gnu-assembly)\nEdited by Cygnus Support\n\n\n# 概要\n这是手册是一个GNU汇编器as的使用手册。\n下面是一个如何使用as的简要说明。具体的使用细节，可以在第二章[Command Line Options]中看到。\n\n\nas [-a[cdhlns]] [=file] [-D] [-defsym sym=val] [-f] [-gstabs] [-gdwarf2] [-help] [-I dir] [-J] [-K] [-L] [-listing-lhs-width=NUM] [-listing-lhs-width2=NUM] [-listing-rhs-width=NUM] [-listing-cont-lines=NUM] \n[-keep-locals] [-o objfile] [-R] [-statistic] [-v] [-version] [-W] [-warn] [-fatal-warnings] [-w] [-x] [-Z] [-target-help] [target-options] [-|files ...]\n\nAlpha平台选项：\n [-mcpu]\n [-mdebug | -no-mdebug]\n [-relax] [-g] [-Gsize]\n [-F] [-32addr]\n\n\nARC平台选项:\n[-marc[5|6|7|8]]\n[-EB|-EL]\n\nARM平台选项:\n[-mcpu=processor [+extension ...]]\n[-march=architecture [+extension ...]]\n[-mfpu=floating-point-fromat ]\n[-mthumb]\n[-EB|-EL]\n[-mapcs-32|-mapcs-26|-mapcs-float|\n-mapcs-reentrant]\n[-mthumb-interwork] [-moabi] [-k]\n\nCRIS 平台选项:\n[–underscore | –no-underscore]\n[–pic] [-N]\n[–emulation=criself | –emulation=crisaout]\n\nD10V 平台选项:\n[-O]\n\nD30V 平台选项:\n[-O|-n|-N]2\n\ni386 平台选项:\n[–32|–64]\n\ni960 平台选项:\n[-ACA|-ACA A|-ACB|-ACC|-AKA|-AKB|\n-AKC|-AMC]\n[-b] [-no-relax]\n\nTarget IP2K 平台选项:\n[-mip2022|-mip2022ext]\n\nTarget M32R 平台选项:\n[–m32rx|–[no-]warn-explicit-parallel-conflicts|\n–W[n]p]\n\nTarget M680X0 平台选项::\n[-l] [-m68000|-m68010|-m68020|...]\n\nTarget M68HC11 平台选项::\n[-m68hc11|-m68hc12|-m68hcs12]\n[-mshort|-mlong]\n[-mshort-double|-mlong-double]\n[–force-long-branchs] [–short-branchs]\n[–strict-direct-mode] [–print-insn-syntax]\n[–print-opcodes] [–generate-example]\n\nTarget MCORE 平台选项::\n[-jsri2bsr] [-sifilter] [-relax]\n[-mcpu=[210|340]]\n\nTarget MIPS 平台选项::\n[-nocpp] [-EL] [-EB] [-n] [-O[optimization level ]]\n[-g[debug level ]] [-G num ] [-KPIC] [-call shared]\n[-non shared] [-xgot] [–membedded-pic]\n[-mabi=ABI ] [-32] [-n32] [-64] [-mfp32] [-mgp32]\n[-march=CPU ] [-mtune=CPU ] [-mips1] [-mips2]\n[-mips3] [-mips4] [-mips5] [-mips32] [-mips32r2]\n[-mips64]\n[-construct-floats] [-no-construct-floats]\n[-trap] [-no-break] [-break] [-no-trap]\n[-mfix7000] [-mno-fix7000]\n[-mips16] [-no-mips16]\n[-mips3d] [-no-mips3d]\n[-mdmx] [-no-mdmx]\n[-mdebug] [-no-mdebug]\n\nTarget MMIX 平台选项:\n[–fixed-special-register-names] [–globalize-symbols]\n[–gnu-syntax] [–relax] [–no-predefined-symbols]\n[–no-expand] [–no-merge-gregs] [-x]\n[–linker-allocated-gregs]\n\nTarget PDP11 平台选项::\n[-mpic|-mno-pic] [-mall] [-mno-extensions]\n[-mextension |-mno-extension ]\n[-mcpu ] [-mmachine ]\n\nTarget picoJava 平台选项::\n[-mb|-me]\n\nTarget PowerPC 平台选项::\n[-mpwrx|-mpwr2|-mpwr|-m601|-mppc|-mppc32|-m603|-m604|\n-m403|-m405|-mppc64|-m620|-mppc64bridge|-mbooke|\n-mbooke32|-mbooke64]\n[-mcom|-many|-maltivec] [-memb]\n[-mregnames|-mno-regnames]\n[-mrelocatable|-mrelocatable-lib]\n[-mlittle|-mlittle-endian|-mbig|-mbig-endian]\n[-msolaris|-mno-solaris]\n\nTarget SPARC 平台选项::\n[-Av6|-Av7|-Av8|-Asparclet|-Asparclite\n-Av8plus|-Av8plusa|-Av9|-Av9a]\n[-xarch=v8plus|-xarch=v8plusa] [-bump]\n[-32|-64]\n\nTarget TIC54X 平台选项::\n[-mcpu=54[123589]|-mcpu=54[56]lp] [-mfar-mode|-mf]\n[-merrors-to-file <filename>|-me <filename>]\n\nTarget Xtensa 平台选项::\n[–[no-]density] [–[no-]relax] [–[no-]generics]\n[–[no-]text-section-literals]\n[–[no-]target-align] [–[no-]longcalls]\n\n\n下面依次解释各个参数的含义：\n-a[cdhlmns]\n   可以以多种方式展开这个参数列表：\n   -ac 忽略值为false的条件分支\n   -ad 忽略debug指令\n   -ah 包含高级语言的源代码\n   -al 包含汇编代码\n   -am 包含宏展开\n   -an 包含格式处理\n   -as 包含符号\n   =file 设置文件列表名\n  你可以组合使用这些选项。比如说，可以使用‘-aln’可以不启用格式处理来汇编一系列文件。如果使用了‘=file’这个选项，就必须保证这个选项是参数的最后一个。另外，‘-a’选项默认等于‘-alhs’选项。\n\n-D 这个选项会直接被忽略。这个选项只是为了在脚本中使用汇编器的时候可以兼容其他汇编器的语法。\n\n--defsym sym=value\n  在汇编器读入源文件之前，将符号sym的值设置成value。其中，value的值必须是一个整数常量。在C语言中，通常通过0x打头来表示一个十六进制数值，以O打头来表示一个八进制数值。\n\n-f\n  就是“fast”的意思。跳过空白字符和注释的预处理过程（通常编译器输出的汇编文件会用这个选项）。\n\n--gstabs\n  为汇编代码的每一行生成stabs的debug信息。在debugger支持的情况下，这些信息对于debug可能有点帮助。\n\n--gdwarf2\n  为汇编代码的没一行生成DWARF2调试信息。在debugger支持的情况下，这些信息对于debug可能有点帮助。不过要注意，这些信息并不是所有平台都支持，只支持一部分。\n\n--help\n  打印一个简略的命令行选项帮助信息。\n\n--target-help\n  打印一些声明的目标平台的选项的帮助信息。\n\n-I dir\n  将目录dir加入到.include指令的搜索列表中\n\n-J\n  忽略带符号数计算时的溢出错误\n\n-K\n  Issue warnings when difference tables altered for long displacements.\n\n-L\n  --keep-locals\n    在符号表中保留本地符号。在传统的输出a.out的系统上，这些符号都以-L打头，当然不同的平台会有不同的local变量前缀方法。\n  --listing-lhs-width=number\n    设置输出数据的列最多可以有number个字长\n  --listing-lhs-width2=number\n    设置输出数据的列最多可以有number个字长(允许通过\\换行)\n  \n-o objfile\n  指定输出的目标文件的文件名\n\n-R\n  将data段打包进text段\n\n--statistics\n  统计下汇编器最大使用了多少空间（字节为单位）、最长使用了多长时间（秒为单位）\n  \n--strip-local-absolute\n  从outgoing符号表中去除纯local变量的符号\n\n-V/-version/--version\n  打印as的版本\n\n-W\n  --no-warn\n    隐瞒warn消息\n  --fatal-warnings\n    将warning信息当作错误信息\n  --warn\n    不要隐瞒warning信息或者将这些信息当作错误信息\n\n-w\n  忽略\n\n-x\n  忽略\n\n-Z\n  即便是有error信息也生成一个object文件\n\n-- | files ...\n  使用标准输入，或者说文件当作汇编器的输入。\n\n\nGNU as实际上一个汇编器家族。如果你在某一个计算机架构下使用（或者已经用过）GNU汇编器，那你在其他计算机架构下应该对这套环境很熟悉。每个架构下的版本的大体功能是一样的，包括obj文件格式、大多数的汇编器命令（通常也会被称作伪指令）以及汇编语法。\n\nas最早是用来给GCC编译器的输出文件作汇编，然后将结果提供给链接器ld使用的。但是不管怎样，我们都致力于使as能够正确的汇编其他汇编器能够编译的所有东西。任何意外情况都会在文档中显式说明。这并不是说as通常会使用和其他汇编器一样的语法（在同一架构下）； 比如说，我们现在都指导680x0系列的语法存在好几个不兼容的版本。\n\n跟其他更老一些的汇编器不同，as的设计目标是用来在源代码文件的编译过程中的一个步骤来应用的，这对它的.org命令有一些细微的影响。\n\n## obj文件格式\nGNU汇编器可以自己配置来产生几种不同类型的obj文件格式。大多数情况下，这个并不会影响你怎么写你的汇编源代码； 但是在不同的obj文件格式下一些命令和debug符号会有不同。\n\n# 语法\n\n这章介绍下和机器架构无关的汇编语法。as的语法和其他的一些汇编器的语法差不太多。这个汇编器是受BSD 4.2的汇编器启发开发的，和BSD 4.2的汇编器差不太多，除了as不会编译Vax这个位域。\n\n## 预处理\nas的内置预处理器：\n- 调整和移除多与的空白字符。它会在每行的每个关键字前留下一个空格或tab，然后把这行其他的连起来的空格变成一个空格\n- 移除所有的注释，将这些注释替换成一个空格，或者是换成空白的新行\n- 将字符常量回程对应的数字值\n\n预处理器并不会像C语言的预处理器那样做宏展开、或者include文件。你可以使用.include命令来作文件引入。你可以使用GCC编译器来获取“CPP”风格的预处理器功能---只需要将文件名以.S结尾就行。\n\n不能在代码的正文中使用太多的空格、tab、注释或者字符常量。\n\n如果源码文件的第一行是 #NO_APP 或者如果在命令行中使用-f选项，那么空白和注释不会从源码文件中移除。你也可以在源码文件想移除空格和注释的地方手动写上#APP来手动移除。\n\n## 符号\n符号由字符、数字和‘_.$’三个特殊字符组成。大多数的架构下，你可以在符号名中使用$；数字符号可以以数字开头。区分大小写。符号没有长度限制：所有的字符都有意义。符号以单词作为分隔。\n\n## 表达式\n表达式以新行或者行分隔符结尾。行分隔符通常是分号，除非与注释符号相冲突的情况。新行和行分隔符是表达式的一部分。字符常量中的新行或者分隔符会被视作一场。\n\n表达式不会以文件末尾作为结尾： 任何源代码的末尾必须是一个新行。\n\n以0或者其他的标识符开始的表达式，可以自我声明自己是一个什么表达式。这些标识符会决定剩余表达式的语法。如果标识符以小数点.开始，则说明这个表达式是一个汇编命令：通常这些命令在其他计算机上也是适用的。如果这个标识符是以一个字母开始的，那通常是一个汇编语言的指令：是会汇编成机器语言的指令。不同计算机的不同版本的as汇编器可以识别出不同的指令集。事实上，有可能同一个表达式在不同的机器上会代表不同的指令。\n\n标签通常是一个符号紧接着一个冒号。标签前面的空格和冒号后面的空格是允许的，但是标签和冒号间的空格不行。\n\n## 常量\n常量是一个数字，直接写出来这样它的值不会随上下文变化。比如下面这些都是常量： \n.byte 74, 0112, 092, 0x4A, 0X4a, 'J, '\\J\n.ascii \"Ring the bell\\7\"\n.octa 0x123456789abcdef\n.float 0f-31415926394058E-4\n\n\n## 字符常量\n字符常量有两种：一种就是代表一个字符的数字值； 另一种是字符串字面量。\n\n#### 字符串\n\n\n# 段(section)和重定位（relocation）\n*英文中的很多词汇在中文中很难找到一个非常准确的词来与之对应。可能因为中文中词语表意丰富的原因，一个词对应英文中多个词的情况比比皆是，在专业词汇中，这种情况尤为常见。“段”在这里也面临这种情况。通常“段”这个词汇可以有两个英文词汇与之对应：section和segment。这两个英文词汇如此常用，为了避免混淆，下面在翻译的时候直接略过对这两个词的翻译，直接使用英文来描述*\n\n简单粗暴的来说，一个section就是描述的一个连续的地址范围； 在这个地址范围内的所有数据都是同样一种用途的。比如说，我们常说的“read only” section。\n\n链接器ld会读入很多obj文件（这些文件都是一些程序片段），然后将他们的内容组织成一个可以执行的程序。当汇编器as产生一个obj文件，这个‘程序片段’（也就是obj文件）都是以地址0开始的。ld链接器会为这些程序片段分配最终的地址，也就是这样，这些一个个的程序片段才不会出现地址交错的情况。当然以上一个相当简化的过程描述，但是可以很粗暴的解释as是如何使用section的。\n\nld链接器将你的程序的字节块移动到它们的运行时的地址上去。这些字节块是以一个严格的整体拷贝到他们的运行时地址上去的；这些块的长度不会改变，然后块内的字节的顺序也不会改变。这样一个严格的整体称为section。给section分配运行时地址的过程称为重定位（relocation）。这个过程包括将obj文件的地址调整到他们对应的运行时地址上去。\n\nas汇编器产生的obj文件至少包含3个section，这3个section的任何一个都有可能为空。这3个section是.text，.data和.bss section\n\n当生成COFF或者ELF格式的输出文件时，as也可以生成各种各样其他名字的section，你可以通过.section命令来自己命令这些section。如果你不使用任何命令来指明.text和.data section，这些section依然会存在，但是会是空的。\n\n在obj文件内部，.text section以地址0开始，紧接着是.data setion，然后是.bss section。\n\n为了让ld链接器知道section重定位的时候要改哪些东西以及怎么改这些东西，as汇编器得在obj文件中写一些重定位所需要的细节信息。为了让ld能完成重定向，obj文件中的每一处地址引用（reference）都得提到以下信息：\n - 这个reference指向的是obj文件从开头开始的偏移多少？\n - 这个reference指向多长的空间（以字节为单位）？\n - 这个reference指向的是哪个section？这个地址的数值值是多少？ \n - 这个reference是不是指向一个“程序计数器相关”的地址？\n\n\n事实上，as中使用的每一个地址都可以用这个公式表述：\n  （section）+ (offset into section)\n展开来说的话，每一个as处理的表达式都有和它所在的secton相关的特性。\n\n在下文中，我们使用{secname N}这种描述方法来表述『section secname中N偏移量』这样一个概念\n\n除了我们提到的.text, .data和.bss 这几个section，还有一个你得了解的sectoin是absolute section。当ld链接器在处理多个程序片段的时候，absolution section的地址是要求保留不动的。举个例子，地址{absolute 0}会被链接器重定位到程序运行时地址的0地址处。尽管链接器不会在链接多个程序片段的时候让两个section的地址区域重叠，但是你在两个程序片段中定义了重叠的absolute sectioin的时候它们就必须要重叠了。一个程序片段中的地址{absolute 239}通常也是链接完成后的程序中的{absolute 239}位置，对于其他参与链接过程的程序片段来说他们看到的{absolute 239}也是这个。\n\n既然有section就会有对应的undefined section。任何在汇编时无法确定的地址都会被汇编成{undefined U} --- 这里的U后面会填上的。由于数字常量肯定都是确定值的，因此唯一能够生成undefined地址的方法是声明一个undefined符号。一个指令已经确定的公共代码块的地址引用通常就是一个undefinded符号： 在编译期间它的值是无法确定的，因此这个地址引用会被放在undefined section中。\n\n同样地，类比一下，在链接后的程序中，一组section我们也用section这个词来描述。ld链接器会将所有参与链接的程序片段中的所有.text section组成一个连续的section，这个连续的section一样的被称为这个程序的.text section，它包含了所有程序片段的.text section的所有地址。.data和.bss是一个道理。\n\n有一些section是ld链接器掌控和管理的；还有一些section纯粹是as汇编器在编译时候用的，没什么其他作用。\n\n\n\n## 链接器专属section\nld只会处理4中类型的专属section，他们大致介绍如下：\n - text section/data section/named section:  这3个section和起来保存了你的程序。as和ld会区分这几个section，但是它们的性质几乎是一样的。你用来描述这3个中任何一个section的概念都适用于另外两个。不过呢，通常在程序运行的时候，text section的内容是不能更改的。一般进程之间会共享同样一份text section内容：这个section里面包含了程序对应的指令、常量等等。data section通常在程序运行的时候内容是可以更改的。比如说，C语言的变量就会放在data seection中。\n\n - bss section：这个section包含的内容是程序启动的时候用0填充的字节内容。一般bss section是用来存储未初始化的变量或者全局共享的存储。每个程序片段的bss section的长度是一个重要的指标，但是呢，因为这个section的内容全是0填充的字节，因此一般在obj文件中并不会显式地去存储等量的0字节。bss section被发明出来就是为了在obj文件中去除这些显式的0字节。\n - absolute section： 这个section内的地址0通常在重定位之后也会是程序的地址0.这个性质在你想被ld链接之后地址也不发生改变的时候很有用。也就是说，absolute section内的地址是‘不可重定位’的：这个section里面的地址值在重定位之后也不会发生改变。\n - undefined section： 这个section是一个兜底方案，用来记录那些没法在上述几个section填入的地址引用。\n\n一个链接过程的简单示意：\n\n////     程序片段#1                                     \\\n////     text             data             bss         \\\n////     |-----------------------------------------    \\\n////     |      ttttt    |     dddd       |   00  |    \\\n////     ------------------------------------------    \\\n////     程序片段#2                                     \\\n////     text             data            bss          \\\n////     |---------------------------|                 \\\n////     |  TTT  |    DDDD  |  000   |                 \\\n////     -----------------------------                 \\\n////     链接后的程序                                    \\\n////          text                        data                bss           \\\n////     |----|------|--------------|----|----------|--------|---------|    \\\n////     |    | TTT  |   ttttt      |    |  dddd    | DDDD   | 00000   |    \\\n////     ---------------------------------------------------------------    \\\n\n\n## 汇编器专属section\n这些section都是汇编器as内部使用的，因此在运行时毫无意义。通常你不需要了解这些sectioin到底是做什么用的； 不过这些section有可能会在as汇编过程的warning提示中出现，所以如果你知道这些section对as汇编器有什么作用的话还是挺有帮助的。这些section让你可以将汇编代码程序中的每个表达式的值对应到一个‘section-relative’地址。\n\nASSEMBLER-INTERNAL-LOGIC-ERROR!   ：  这代表一个一直的汇编器内部的逻辑错误，也就是说，这个as汇编器目前确实有这个bug。\n\n - expr sectoin： 汇编器会将一些复杂的表达式以一组符合的组合存储在这里。当某个符号确实需要对应一个表达式的时候，它会被放在这个section中。\n\n## sub-sections\n汇编后生成的文件中的内容一般会以字节为单位，大部分的内容在.text和.data section。你可能会有这样的需求：将一组单独的section在obj文件末尾一个接一个排开，并且它们在汇编源码文件中可能不是连这些的。as汇编器提供了subsection来满足这个需求。在每个section内，可以使用0-8192来标识subsection。同一个subsection内的内容会被汇编到同一个obj文件中。举个例子，编译器可能会将常量放入text section，但是可能会不希望它们和被汇编的程序分散开。在这种情况下，编译器会声明一个‘.text 0’来标识每个源码中的代码程序，然后用‘.text 1’来标识每个源码中的常量部分。\n\nsubsection是一个可选的功能。如果你不使用subsection，那默认所有的东西都是放在subsection 0中。\n\nsubsection按数字从小到大顺序出现在你的obj文件中。obj文件中不包含subsection的任何表征信息，ld以及其他任何操作obj文件的程序也看不到subsection的痕迹。它们只将你所有的text subsection当作一个text section，将你所有的data subsection当作一个data section。\n\n为了区分你接下来的语句要被汇编到哪个subsection，你可以使用一个数字参数来显式地声明，语法是‘.text expression’或者'.data expression'（expression是subsection的编号，或者一个常量表达式）。在生成COFF或者ELF文件的时候，你也可以用语法‘.section name, expression’来声明一个带名字的subsection。如果你只写一个‘.text’，那么和'.text 0'是一个意思。同样的道理，‘.data’和‘.data 0’是一个意思。汇编后的程序都是以.text 0开始。举个例子：\n\n.text 0 # The default subsection is text 0 anyway.\n.ascii \"This lives in the first text subsection. *\"\n.text 1\n.ascii \"But this lives in the second text subsection.\"\n.data 0\n.ascii \"This lives in the data section,\"\n.ascii \"in the first data subsection.\"\n.text 0\n.ascii \"This lives in the first text section,\"\n.ascii \"immediately following the asterisk (*).\"\n\n每个section都有一个位置计数器(location counter)，它会以字节为单位一个个往上累加，这个section汇编进取的内容每多一个就加一。由于subsection的概念几乎是as汇编器使用范围内的优化，因此并没有一个‘subsectin位置计数器’的概念。也就是说没有方法直接去操作一个位置计数器。但是呢，有一个汇编命令.align可以做这个事情，并且汇编语言中的任何一个自定义的标签都可以捕获它当前的位置计数器。这种正在被汇编的section的位置计数器被称作active位置计数器。\n\n## bss section\nbss section用来作本地变量的存储。你可以在bss section中分配地址空间，但是你一般不能在程序跑起来之前往这个section中塞入数据。当你的程序跑起来之后，bss section的内容会被用0字节填充。\n\n.lcomm汇编命令可以在bss section定义符合。（后面会讲）\n\n.comm汇编命令可以用来定义另一种形式的为初始化符号。（后面会讲）\n\n在汇编像ELF和COFF这样的支持多个section的目标文件时，你也可以正常的切换到bss section去定义符号。但是一般你只能在这个section中填充0字节值。典型的使用方法是这个section中只包含符号定义或者使用.skip汇编命令。\n\n\n# 符号（Symbols）\n符号是是一个非常核心的概念：程序员会使用符号来给东西命名，链接器使用符号来链接，调试器使用符号来调试。\n\n注意！！： as汇编器并不一定会按照符号定义的顺序将这些符号放入到obj文件中。因为这样做可能会使一些调试器没法正常工作。\n\n## 标号（labels）\n标号的写法是在一个符号后面直接加一个冒号（：）。这种符号就可以表示active位置计数器的当前值（比如说一个对应的指令操作符）。如果你在两个不同的地方使用了同一个标号，汇编器会告警：第一个定义的标号被后面的其他定义给覆盖了。\n\n## 给符号赋其他值\n一个符号可以通过在后面添加一个等号来赋任意值。这个和使用.set汇编命令是等价的。\n\n## 符号名\n符号名一般以字母或者‘._’两个字符中的一个打头。在大多数的机器上，你也可以在符号名中使用‘$’字符。这些打头的字符后面可以跟任何数字、字母、$、_等组成的字符串。\n\n字母是区分大小写的：foo和Foo是两种不同的符号名。\n\n每个符号都有一个与与之对应的独一无二的名字。汇编程序中的每个名字都指向一个与之对应的唯一的符号。你可以在程序中无次数限制地使用任何一个符号名。\n\n本地符号名（Local Symbol names）\n\n本地符号可以让汇编器和编程者临时地使用符号名。汇编器和编程者在一定源代码范围内创建一些唯一的符号。定义本地符号的方法是“N：”（这里N代表一个正整数）。可以使用“Nb”来指代最近的上一个定义的本地符号，这里的N是你想指向的本地符号。同样的，你可以使用“Nf”来指代这一行之后的下一个本地符号N。这里面，“b”代表“backwards”，即向后查找； “f”代表“forwards”，即向前查找。\n\n至于你如何使用这些标号，实际上并没有什么严格的限制。也就是说，有可能会重复地定同一个本地符号（即两个地方使用同一个“N”）。尽管如此，你使用“Nb”或者“Nf”的时候也只可能指向一个唯一的向后查找或者向前查找的本地符号。此外，值的注意的是，前十个本地标号（0:, 1:, ...., 9:）相对于其他的本地标号是以一种略微优化了的方式实现的。\n\n举个例子：\n1: branch 1f\n\n2: branch 1b\n\n1: branch 2f\n\n2: branch 1b\n\n上面的语句等价于：\nlabel_1: branch label_3\n\nlabel_2: branch label_1\n\nlabel_3: branch label_4\n\nlabel_4: branch label_3\n\n本地符号名仅仅是一个标记的工具。它们在被汇编器使用之前会直接转化成更方便使用的符合名。符号名存储在符号表中，在汇编错误时的错误信息里会出现，也有可能会记在obj文件中。这些转化后的符号名会由下面的部分组成：\n\nL：所有的本地符号名都以‘L’打头。正常情况下as汇编器和ld链接器都会跳过对以”L“打头的符号的处理。这些标号都是用来标识那些你永远都不想看到的符号。如果你在汇编的时候使用”-L“选项，那边汇编器会在obj文件中保留这些符号。如果你以同样的方式要求ld链接器也保留这些符号，那么你在debug的时候还可以看到和使用它们。\n\nnumber： 这里的number是说你在定义本的符号的时候使用的数字。因此，如果你的标号写的是”55：“，那么这里的number指的就是55\n\nC-B：这个特殊的字符也会被包含在转化后的符号名中，这样可以保证你不会无意间在代码中写出一个转化后的符号名。（这个C-B其实指的是“control-B”,即control键+B输入的字符，它的asscii码是\\002）\n\nordinal number: 这个是一个数字序列，用来确保转化后的符号名是唯一的。第一个定义的符号名，转化后这个数字是1，第15个定义的符号名转化后这个数字是15，依次往下编。\n\n举个例子，我们自定义的本地符号名“1：”，在转化后会得到符号名“L1C-B1”。我们定义的第44个符号名“3：”在转化后会得到符号“L3C-B44”\n\n$本地标号(dollar local labels)\n\nas也支持一种比本地标号更加‘本地’的标号形式，称为dollar labels。一旦定义了一个非本地标号，这些$本地标号就会在作用范围内立马实效（比如它们变成undefined）。因此它们只会在源码的一小段区域内保持可用。与此相反，正常的本地标号，会在源码文件中的整个文件内保持可用，或者是有其他地方定义了一个同样名字的正常本地标号，这个正常的本地标号才会失效。\n\ndollar标号的定义和正常的本地标号是一样的方式定义，不过dollar标号的末尾不是一个冒号“：”，而是一个dollar符。比如这样的：“55$”。\n\n还有一种区分普通的本地标号和dollar本地标号的方法是：dollar本地标号的转化后的标号中使用的是ascii字符‘\\001’(也就是contorl-A)。因此第5个dollar本地标号‘6$’会被转化成'L6C-A5'。\n\n## 特殊符号Dot（the special dot symbol）\n特殊符号‘.’指代as在作汇编时当前行的地址。因此，表达式‘melvin: .long .’定义了一个符号‘melvin’来指代这个符号自己的地址。给‘.’符号赋值等价于‘.org’汇编命令。因此，表达式'.=.+4'等价于‘.space 4’\n\n## 符号属性\n每个符号除了名字外，还有‘value’和‘type’两个属性。符号还可以有一些额外的辅助属性，这取决于输出的格式。\n\n如果直接使用一个为定义的符合，as汇编器会默认这个符号的所有属性都是0，而且这种情况下是有可能并不会通知你的。这种情况下as汇编器会把这个符号当作是一个外部定义的符号。\n\n### value属性\n一个符号的值通常都是32位的。对于一个在text、data、bss或者absolute section内标识位置的符号来说，它的值等于这个符号从section开始的相对地址。自然而然的，text、、data、bss sectoin内的符号的值会在ld链接器拦截的时候被改变，因为链接器会改这些section的基址地址。absolute section内的符号的值不会在链接的时候发生改变： 这也是它们被称为absolute的原因。\n\n一个未定义的符号的value会以一种特殊的方式处理。如果value是0，这就说明在汇编的源代码中这个符号没有被定义，ld链接器在将这个符号链接至目标程序的时候尝试决定这个符号的value。这种用法很简单，你只需要简单的在不定义一个符号的情况下使用这个符号就行，ld链接器会自己去找。如果一个符号的value属性不为0，说明这个符号是使用.comm的方式声明过，这里的value值说明了这个符号需要预留多少字节的存储空间。而符号则指代这片存储区域的开始地址。\n\n### type属性\n一个符号的type属性包含了这个符号的重定位/section信息、以及一系列说明这个符号是否是外部声明的，以及其他一些链接器和调试器需要使用的信息。这些信息的确切格式与输出的obj文件格式相关。\n\n### a.out的符号属性\n\n#### descriptor\n这个属性是一个任意的16bit的值。你可以自己使用.desc汇编器命令来声明一个符号的descriptor。不过呢，as汇编器对于descriptor的值并不关系，as不会使用这个值。\n\n#### 其他\n这是一个任意的8bit的值。同样的，as汇编器并不关系这个东西。\n\n### COFF的符号属性\nCOFF格式支持大批的辅助性符号属性； 像primary符号属性等。这些属性是通过.def/.defend汇编命令设置的。\n\n#### primary属性\n使用.def设置符号名； 对应的，符号的value和type通过.val和.type命令定义\n\n#### 辅助性属性\nas汇编器命令.dim, .line, .scl, .size和.tag可以生成COFF文件的辅助性符号表信息。\n\n# 表达式\n表达式指代了一个地址或者一个数值。表达式的前后都可以跟空白字符。\n\n表达式的运算结果必须是一个确定的数值、或者是一个section中的地址偏移量。如果一个表达式不是绝对确定的值，并且当as汇编器看到这个表达式的时候没有足够的信息来确定它的section，那么就需要第二轮重新扫一遍程序来解释这个表达式了。不过呢，这个第二轮的扫描as汇编器目前并没有实现，因此as汇编器会直接抛一个错误信息，然后结束这次汇编。\n\n## 空表达式\n一个空的表达式没有值：仅仅是空白符号或者null。任何需要一个确定表达式的定方，你都可以用空表达式，并且as汇编器会将空表达式解析成数值0.这一点和其他的汇编器是兼容的。\n\n## 整数表达式\n一个整数表达式是由操作符界定的一个或者多个参数。\n\n### 参数(argument)\n参数可以是符号(1)、数字(2)或者子表达式(3)。在一些其他的上下文中‘参数’有时会被称为‘arithmetic operands(算术操作数)’。在这个手册中，为了避免和机器语言的‘指令操作数’混淆，我们使用了‘argument’这个词来专门代表一部分表达式，保留了‘operand’这个词来代表及其指令的操作数。\n\n符号(1)在计算和估值之后会产生{section NNN}这样的表达式，这里的section可以是text, data, bss, absolute和undefined中的一个，NNN是一个有符号的，补码形式的32位整数\n\n数字(2)通常都是整数。\n\n一个数值(2)可以是浮点型或者bignum大整数。在这种场景中，汇编器会提示你这个数值内容只有低32位会被使用，而且as汇编器会将这低32位当作一个整数。如果要和外部的常量运算，或者保持和其他汇编器的兼容性，你可能得自己写一个整数操作的指令。\n\n子表达式（3）一般是一个左括号'('接上一个整数表达式，然后接上一个右括号')'； 或者是一个前缀操作符加上另一个参数（argument）\n\n### 操作符\n操作符是一种算术运算函数，像 + 或者 % 等等。前缀操作符后面都会跟一个参数。中缀操作符两边都有参数。操作符左右两边都可以有空白字符。\n\n### 前缀操作符\nas汇编器有下面几种前缀操作符。它们都只带一个参数，而且参数必须是常量。\n - ‘-’： 负号\n - ‘～’： 非\n\n### 中缀操作符\n中缀操作符有两个参数，一边一个。操作符有优先级区分，但是相同优先级的操作是从左至右计算的。除了 + 和 - ， 每个参数都必须是常量，并且结果也会是一个常量\n1. 最高优先级\n - '*': 数乘\n - '/': 数除\n - '%'： 取余\n - '<<'， '<': 左移\n - '>>', '>': 右移\n2. 中优先级\n - '|': 按位或\n - '&': 按位与\n - '^': 按位异或\n - '!': 按位或非\n3. 低优先级\n  - '+': 数字加。如果有一个参数(A)是常量，另一个(B)不是，那结果的section会是B的section。如果两个参数属于不同的section，你不能对它们使用加法。\n  - ‘-’： 数字减。如果右参数是常量，那结果的section会是左参数的section。如果两个参数来自同一个section，那结果会是一个常量。如果两个参数属于不同的section，你不能对它们使用减法。\n  - ‘==’：判断两个参数是否相等。\n  - '<>': 判断两个参数是否不相等。\n  - ‘<': 小于\n  - '>'\n  - '>='\n  - '<='\n  上面这些比较类的操作符可以当作中缀操作符使用。如果比较的结果是真，那么会返回值-1； 如果比较的结果是假，那么返回值是0。这些比较操作都是带符号的比较。\n\n4. 最低优先级\n  - '&&': 逻辑与\n  - '||': 逻辑或\n  这两个逻辑操作符都可以用来组合自表达式的结果。需要注意的是，与比较类操作符不同，这里如果结果是真，那么返回1；如果结果是假，那么返回0。另外需要说明的是逻辑或的优先级比逻辑与要低。\n\n  总结一下，只有对地址的offset作加法和减法有意义；你只能在一个参数中确定section，或者两个参数来自同一个section。\n\n# 汇编器命令\n所有的汇编器命令都是以点.开头。剩下的名字部分是一个单词，通常都是小写的。\n\n这一章我们会讨论GNU汇编器内置的与目标机器架构无关的汇编器命令。有一些机器会提供其他额外的汇编器命令，这个我们在下一章讲。\n\n## .abort\n这个命令会立即停掉汇编程序。这个命令和其他汇编器是兼容的。最原始的设计想法是，汇编的源码是通过类似与管道的方式流入到汇编器中，然后如果发送方（也就是源码）想停下来，就用这个命令来告诉as汇编器一起停下来。现在在逐步考虑废弃.abort命令了。\n\n## .ABORT\n如果是在汇编COFF文件，as汇编器会将它当作.abort命令\n如果是在汇编b.out文件，as汇编器会直接忽略这个命令。\n\n## .align abs-expr, abs-expr, abs-expr\n这个命令将位置计数器（location counter）限定在一个特定的存储空间范围内。参数中的第一个个表达式必须是一个常量，它声明了对齐要求，下面还会介绍。\n\n参数的第二个表达式也得是一个常量，它给出了在限定的存储范围内的填充值。这个参数可以被省略。如果省略的花，那填充的字节一般是0.不过呢，在一些系统里面，如果这个section内有代码内容在的话，那你给出的填充值是会被忽略的，它们会使用no-op指令来填充这些个空间。\n\n\n参数的第三个表达式也得是一个常量，并且也是可选的。如果写了第三个参数的话，那它声明了这条内存对齐命令可以跳过的最大字节数。如果在作对齐的时候发现需要跳过的字节数大于这个参数声明的值，那这次对齐压根就不会触发。你可以用两个逗号',,'来省略第二个参数而不省略第三个参数。\n\n内存对齐的方式依着各种各样的系统有着各种各样的方式。ℹ386系统使用的是ELF格式的，这种格式的第一个表达式声明了按多少字节对齐。举个例子，命令'.align 8'会让location counter往前走，一直到当前值是一个8的倍数。如果location counter当前值已经是8的倍数，那么什么都不会发生。\n\n在其他的一些系统里，比如i386的a.out格式，以及arm架构等，第一个参数声明了location counter的低多少位需要是0。举个例子，‘.align 3’声明了location counter的低3位必须是0，也就是说，location counter会一直往前走，直到location counter是8的倍数（这样能保证低3位是0）。如果当前location counter的低3位已经是0了，那么什么都不会发生。\n\n这种不一致性是因为这些系统下面自带的汇编器本身的行为就不一样，as汇编器为了模拟它们的行为只能这么做。as汇编器同时还提供了.balign和.p2align命令，这两个命令在不同的架构下面行为是一致的，这个我们后面还会有介绍。\n\n## .ascii \"string\"...\n.ascii命令后面可以接0或者多个字符串字面量，以逗号分隔。汇编器会将这些字符串汇编到连续的地址内，需要注意的是，汇编器不会自动地给这些字符串末尾加0.\n\n## .asciz \"string\"...\n.asciz和.ascii差不多，但是汇编器会给每个字符串后面加0。.asciz里面的z就是'zero'0的意思。\n\n## .balign[wl] abs-expr abs-expr, abs-expr\n将位置计数器(location counter)限定在一定的存储范围内。第一个表达式必须是常量，它声明了需要按多少字节对齐。举个例子，‘.balign 8’会让location counter一直往前走，直到它的值是8的倍数。如果它的值已经是8的倍数了，那么什么都不会发生。\n\n第二个参数也必须是一个常量，它给出了内存对齐时需要用什么内容来填充字节。这个参数可以忽略，如果忽略的话，填充的字节通常是0。但是在一些系统中，如果当前section内有代码，那么这个参数给出的填充内容会直接被忽略，然后使用no-op指令来填充。\n\n第三个参数也得是一个常量，它也是可选的。如果给了这个参数的话，那它描述了这个对齐命令允许跳过的最大字节数。如果对齐过程中跳过的字节数大于了这个给出的参数值，那此次对齐压根就不会做。你可以使用两个逗号‘,,’来忽略第二个参数而使用第三个参数，这种用法在你想要使用no-op指令来填充内存对齐产生的空档的时候很有用。\n\n.balignw 和 .balignl命令是.balign命令的两个衍生。.balignw会按照两字节的模式对齐。.balignl命令按照4字节的模式对齐。举个例子， '.balignw 4, 0x368d'会按照4的倍数进行对齐。如果对齐过程中跳过了2个字节，那这两个字节会使用0x368d进行填充。如果跳过了1个或者3个字节，那就不会用0x368d来填充。\n\n## .byte expressions\n.byte命令可以带0个或者多个表达式作为参数，参数之间通过逗号作分隔。每个表达式都会被汇编到下一个字节中去。\n\n## .comm symbolX, lengthX\n.comm定义了一个通用的符号，符号名为symbolX。在链接的时候，一个obj文件内的通用符号可能会和在另一个obj文件中定义的通用符号合并。如果ld链接器没有找到这个符号的定义，那么链接器会给这个符号分配lengthX个字节的未初始化内存。lenghtX必须是一个常量表达式。如果ld链接器看到多个同名的符号，并且这些符号没有统一的大小，那链接器会按照声明的最大大小来分配空间。\n\n在ELF文件中，.comm命令可以有第三个参数，它是一个可选参数。这个参数声明了这个符号的按多少字节对齐。这个对齐参数必须是一个常量表达式，并且必须是2的直属。如果ld链接器为这个符号分配了未初始化内存，那ld链接器会考虑在放置这个符号的时候按声明的方式进行对齐。如果没有声明对齐方式，as汇编器会将对齐方式设置成小于等于这个符号的大小的最大的2的指数值，这个值最大是16.\n\n## .data subsectionX\n.data命令告诉as汇编器将下面的语句汇编到 .data subsectionX这个subsection的空间后面。如果subsectionX被忽略了，那这个值默认是0.\n\n## .def nameX\n从这里开始为nameX这个符合定义调试信息。这个定义一直有效知道.endef命令出现。\n\n这个命令只有在输出COFF文件的时候有用。当输出b.out文件的时候，‘.def’命令会被识别，但是会直接被忽略。\n\n## .desc symbolX, abs-expression\n这个命令设置了一个符号的descriptor属性，第二个参数常量表达式的值会被设置到descriptor的低16位。\n\n.desc这个命令在as输出COFF格式文件的时候是无效的。只有在输出a.out和b.out obj文件的时候有用。\n\n## .dim\n这个命令只能是编译器生成出来的，它是用来在符号表中设置一些辅助性的调试信息的。这个命令只能在.def/.endef命令包含的区域内使用。\n\n.dim只有在生成COFF格式文件的时候有意义。在as生成b.out文件的时候，as可以识别这个命令，但是会直接忽略。\n\n## .double flonums\n.double命令可以接受0个或者多个浮点数作为参数，各个参数通过逗号隔开。它会将浮点数一个接一个地汇编到目标文件中。\n\n## .eject\n强制在当前点产生一个‘分页符’(page break)。\n\n## .else\nas汇编器支持的条件汇编命令的一部分。\n\n## .elseif\nas汇编器支持的条件汇编命令的一部分。\n\n## .end\n.end命令标识了这个汇编文件的末尾。as汇编器不会处理.end命令后面的任何内容。\n\n## .endef\n这个命令标识了以.def命令开始的符号定义范围的结束。\n\n这个命令只有在生成COFF格式文件的时候有意义。在as生成b.out文件的时候，as可以识别这个命令，但是会直接忽略。\n\n## .endfunc\n.endfunc命令标识了.fuc命令提示的函数定义范围的结束。\n\n## .endif\nas汇编器支持的条件汇编命令的一部分。\n\n## .equ symbolX, expression\n这个命令将symbolX的值设置成表达式代表的值。这个命令和.set命令是同语义的。\n\n## .equiv symbolX, expression\n.equiv命令有点像.equ命令和.set命令。不过呢，汇编器如果发现symbolX已经被定义了的话会抛错。需要提醒的是，已经引用过但是没有显示定义的符合同样会被当作未定义看待。\n\n除去抛错这部分的功能，这个命令的语义有点类似于下面的命令组合：\n.ifdef SYM\n.err\n.endif\n.equ SYM,VAL\n\n## .err\nas汇编器在汇编.err命令是，它会打印出一个错误消息。使用了.err命令会阻止汇编器生成obj文件，除非在汇编的时候声明了‘-Z’选项。这个功能可以用来作代码的条件编译。\n\n## .exitm\n从当前的宏定义中提前退出\n\n## .extern\n为了兼容其他的汇编器，源码中的.extern命令会被as汇编器识别，但是会被as直接忽略。as汇编器会将所有未定义的符号当作外部符号。\n\n## .fail expression\n.fail命令用来产生一个error或者warning。如果参数expression表达式的值大于500，as汇编器会打印一条告警信息。如果expression表达式的值小于500，as汇编器会抛出一条error错误信息。信息中包含有expression表达式的值。这个东西在复杂的嵌套宏或者条件编译中十分有用。\n\n## .file stringX\n.file命令告诉as汇编器我们马上要开始一个新的逻辑文件。stringX是这个新的文件的文件名。一般来说，文件名会通过双引号引起来。如果你想声明一个空文件名，你可以直接使用“”这样的方式。这个语法以后可能会被移除掉，所以现在不推荐使用。\n\n## .fill repeat, size, value\n这里的三个参数repeat, size和value都必须是常数表达式。这个命令用来重复拷贝repeat次size大小的字节。repeat参数大于等于0.szie参数大于等于0，但是如果size>8，那么会强制size=8，这个也是为了和别的汇编器保持兼容。每块重复的字节块的内容都是一个8字节大小的数字，高位的4个字节是0，低位的4个字节是参数value的值。每个size这么大的字节块是一个重复单元。这种奇怪的行为是也为了和其他的汇编器保持兼容。\n\nsize参数和value参数都是可选的。默认情况下，size的值是1，value的值是0.\n\n## .float flonums\n这个命令可以汇编0个或者多个浮点数到目标文件中，这些数以逗号隔开。这个命令和.single命令的效果是一样的。\n\n## .func name[, label]\n.func命令会触发一段调试信息来指示函数名，因此，这个命令只有在只有在汇编器开启了调试时才有用，否则会被直接忽略。到目前为止，只有as汇编器的--gstabs开启调试选项还支持这个功能。label参数是这个函数的入口。name参数可以省略，或者是一个以下划线开始的单词。目前所有函数返回值类型都是void。函数定义必须以.endfunc来结束。\n\n## .global symbolX / .globl symbolX\n.global命令将一个符号暴露给ld链接器。通常情况下，如果你在你的程序片段中定义了一个符号，那么这个符号的值在链接的时候是可以被其他程序片段看到的。不然的话，一个定义的符号就需要从其他程序片段的同名符号中获取属性值了。\n\n两种拼写方式(.global 和 .globl)都是可以的，这个也是为了兼容其他的汇编器。\n\n## .hidden names\n这个是ELF格式可见的命令（另外两个EFL格式可见的命令是.internal和.protected，后面会介绍）。\n\n这个命令重新设置了这个names符号的可见性（通常符号的可见性可以被设置成： local, global和weak）。这个命令将符号的可见性设置成hidden，这意味着这个符号不能被其他的模块看到。这种符号通常也会被称为protected符号。\n\n## .hword expressions\n这个命令接受0个或多个表达式作为参数，并且每个表达式代表一个16位的数字。\n\n这个命令和'.short'命令是同一个语义。\n\n## .ident\n这个命令会被一些汇编器用来给obj文件中放置tag。as汇编器仅仅是为了和其他汇编器保持兼容，实际上as并不会作任何事情。\n\n## .if absolute expression\n.if命令以一个开关的形式确定某个section中的一段代码是否最终会汇编到目标程序中，.if命令标识了这段代码的开始，而且只有.if命令的参数（必须是一个常量表达式）的值是非0值的时候，才会将这段代码汇编到目标程序中。这段代码的结束必须通过命令.endif来标识。另外作为可选项，你可以使用.else命令来标识出另外一个选项。如果你有多个条件要检查，你可以使用.elseif命令来避免.if/.else的嵌套。\n\n下面几种.if命令的衍生命令也是支持的：\n\n.ifdef symbolX\n  如果给定的参数symbolX被定义过了，那么就汇编这个命令敲定的代码片段。注意，如果一个符号没有被显式地定义过而你直接拿去用了，那这个符号还是会被看作未定义的。\n\n.ifc string1, string2\n  如果给定的两个参数，即string1和string2相同，那么就汇编选定的代码片段。两个字符串需要用单引号引起来，如果没有用引号引起来的话，那么逗号前的一个串会被认为是第一个字符串，逗号后的串一直到行的末尾会被认为是第二个字符串。包含空白字符的字符串必须要引起来。字符串的比较是区分大小写的。\n\n.ifeq absolute expression\n  如果给定的常量表达式的值是0的话，就汇编选定的代码片段。\n\n.ifeqs string1, string2\n  .ifc命令的另一种形式，两个字符串必须通过双引号引起来\n\n.ifge absolute expression\n  如果给定的常量表达式的值大于等于0，就汇编选定的代码片段。\n\n.ifgt absolute expression\n  如果给定的常量表达式的值大于0，就汇编选定的代码片段。\n\n.ifle absolute expression\n  如果给定的常量表达式的值小于等于0，就汇编选定的代码片段。\n\n.iflt absolute expression\n  如果给定的常量表达式的值小于0，就汇编选定的代码片段。\n\n.ifnc string1, string2\n  和.ifc差不多，不过语义上是反过来的：即如果给定的两个字符串不相同，就汇编选定的代码片段。\n\n.ifndef symbolX\n.ifnotdef symbolX\n  如果给定的符号没有定义的话，就汇编选定的代码片段。这个命令的两种拼写形式都支持。注意，如果一个符号没有被显式地定义过而你直接拿去用了，那这个符号还是会被看作未定义的。\n\n.ifne abosolute expression\n  如果给定的常量表达式的值不等于0，就汇编选定的代码片段（换句话说，这个命令和.if命令是一个意思）。\n\n.ifnes string1, string2\n  和.ifeqs差不多，但是语义上反过来了： 即如果给定的两个字符串不同，就汇编选定的代码片段。\n\n## .incbin \"file\"[, skip[, count]]\n  .incbin命令会将指定的文件一字不拉的引入到当前位置来。你可以在as命令的-I参数中指定文件的搜索目录。file参数旁边的双引号是必须的。\n\n  skip参数可以指明在include的时候省略file文件开始的多少字节。count参数指明了最大可以读入多少字节。需要注意的是，读入的数据不会以任何方式对齐，因此使用该命令的人需要自己考虑在include之前和之后的空间对齐问题。\n  \n## .include \"file\"\n这个命令提供了一种在你的源代码中指定的地方引入一个文件的方式。参数file文件中的代码会当作.include这个点新插入的代码一样被汇编； 当include的文件到达末尾的时候，汇编程序会在调用.include命令的地方继续它的汇编过程。你可以通过as命令的-I选项来控制引入的文件的搜索路径。参数file附近的双引号是必须的。\n\n## .int expression\n.int命令可以在任何section中带0个或者多个表达式作为参数，参数以逗号作为分隔。每个表达式的值在运行时都得是一个数字。这个数字的字节序以及大小依赖于汇编的是哪种目标程序。\n\n## .internal names\n.internal是一个用来定义ELF文件中变量可见性的命令。其他两个定义可见性的命令是.hidden和.protected命令\n\n这个命令会覆盖掉变量默认的可见性设置（默认的可见性设置是这个变量是local，global还是weak来确定的。这个命令会强制将变量设置位internal这种可见性，即这个变量会被视为hidden状态（不能被其他组件看到），这个符号的相关的一些外部的、处理器相关的处理过程也会一并被执行。\n\n## .irp symbolX, values...\n产生一个语句序列，用来给symbolX赋不同的值。这个语句序列以.irp命令开始，以.endr命令结束。对于每个参数中给定的值，symbolX会被赋予这个值，产生的语句序列是可以被汇编的。如果参数中没有声明values，那么这个语句序列只会被汇编一次，并且symbolX会被赋值位空字符串。如果想要在产生的语句序列中引用symbolX，可以使用符号‘\\symbolX’。\n\n举个例子，如果我们使用语句：\n.irp param, 1,2,3\nmove d\\param,sp@-\n那么上面的语句在汇编的时候等价于：\nmove d1,sp@-\nmove d2,sp@-\nmove d3,sp@-\n\n## .irpc symbolX, values...\n产生一个语句序列，用来给symbolX赋不同的值。这个语句序列以.irpc命令开始，以.endr命令结束。对于每个参数中给定的字符，symbolX会被赋值为这个字符，产生的语句序列是可以被汇编的。如果参数中没有声明values，那么这个语句序列只会被汇编一次，并且symbolX会被赋值位空字符串。如果想要在产生的语句序列中引用symbolX，可以使用符号‘\\symbolX’。\n\n举个例子，如果我们使用语句：\n.irp param, 123\nmove d\\param,sp@-\n那么上面的语句在汇编的时候等价于：\nmove d1,sp@-\nmove d2,sp@-\nmove d3,sp@-\n\n\n## .lcomm symbolX, length\n给symbolX指定的一个本地变量预留length个字节。符号symbolX的section和值与这个预留的变量相同。变量的地址是分配在bss section中，因此在运行时的时候，这个预留的字节内容全是0.symbolX不是全局定义的，因此通常ld链接器并不能看到这个符号。\n\n一些计算机平台的.lcomm命令允许有第三个参数，这个参数声明了符号symbolX在bss section中对齐方式。\n\n## .lflags\nas汇编器会识别这个命令，但仅仅是为了和其他汇编器兼容，as会直接无视这个命令。\n\n## .line line-number\n这个命令可以改变逻辑的行号。参数line-number必须是一个常量表达式。这个命令的下一行会使用这个逻辑的行号。因此，任何其他在当前行的语句在逻辑上的行号是line-number - 1。as会在将来废除这个命令： 因为这个命令仅仅是为了和其他的汇编器兼容。\n\n尽管这个命令的功能与obj文件是a.out格式还是b.out格式相关，as汇编器仍然会在汇编COFF文件的时候接受这个命令。在汇编COFF文件的时候，.line命令和COFF文件中的.ln命令类似。\n\n当在.def/.endif命令之间使用.line命令时，这个命令会被编译器用来生成辅助性的符号调试信息。\n\n## .linkonce [type]\n将当前section标记一下，让链接器命令这个sectin只能被链接一次。这个命令在将同一个section的内容include到多个不同的obj文件中的时候特别有用。.linkonce这个命令必须在这个section的每个实例中被调用。判断section重复的方法时看多个section的名字是不是相同的，因此使用.linkonce的时候需要确保section的名字不和其他section相同。\n\n这个命令只支持在一小部分的obj文件格式中使用。到这个手册撰写的时间为止，目前只有Windows NT系统的PE格式支持这个命令。\n\ntype参数时可选的。如果声明了type参数的下，这个参数的值必须是以下几种字符串：\ndiscard: 丢弃重复的section，并且不发出告警。这个时默认的选项。\none_only: 在有重复的sectoin的时候，只保留一份，同时抛出告警\nsame_size: 如果重复的section的大小不一样的时候，发出告警。\nsame_contents: 如果重复的section的内容不是严格一致的话，发出告警。\n\n## .ln line-number\n.ln命令和.line命令相同。\n\n## .mri val\n如果参数val是一个非0值，这个命令的含义时告诉as汇编器进入MRI模式。如果val的值是0，这个命令的含义时告诉as退出MRI模式。这种操作会影响后续代码的汇编形式，这种影响一直持续到下一个.mri命令或者文件末尾。\n\n## .list\n（和.nolist命令一起使用）用来控制汇编的时候是不是要在控制台列出当前的汇编内容。这两个命令会维护一个内部的计数器，计数器的初始值时0..list命令会对计数器++，.nolist命令会对计数器--。汇编器会在这个计数器大于0的时候向控制台列出当前在汇编的内容。\n\n默认情况下，列出功能时关闭的。当你使用as命令的-a选项启用这个功能的时候，这个计数器的值会被设置成1.\n\n## .long expression.\n和.int命令相同。\n\n## .macro\n.macro命令和.endm命令允许你自定义个一个汇编宏。举个例子，下面的代码定义了一个sum宏，它能将一个数字序列写入到内存中：\n```\n.macro sum from=0, to=5\n.long \\from\n.if \\to-\\from\nsum \"(\\from+1)\",\\to\n.endif\n.endm\n```\n在上面的宏定义中，“SUM 0,5”这句话等价于：\n.long 0\n.long 1\n.long 2\n.long 3\n.long 4\n.long 5\n\n.macro macname\n.macro macname macargs ...\n  这两句话是用来定义一个名位macname的宏。如果你定义的宏接受参数，你可以在macname后面接着声明参数名，参数名之间通过逗号或者空格分隔。你可以用\"=deflt\"来为每个参数定义一个默认值。举例来说，下面的宏定义都是合法的：\n  - .macro comm: 定义一个名为comm的宏，不带参数；\n  - .macro plus1 p, p1\n  - .macro plus1 p p1: 这两个语句都是定义了一个名为plus1的宏，这个宏带两个参数，在宏的定义范围内，可以使用“\\p”和“\\p1”来代表这两个参数\n  - .macro reserve_str p1=0 p2: 定义一个名为reserve_str的宏，这个宏带两个参数。第一个参数有默认值，第二个没有。宏定义完成之后，你可以“reserve_str a,b”这样的方式定用宏，也可以“reserve_str ,b”这样的方式调用宏。\n  \n  在调用宏的时候，你既可以通过参数位置来声明一个参数的值，也可以通过给定参数名来声明参数的值。比如，\"sum 9,17\"等价于\"sum to=17,from=9\"\n\n.endm 标识一个宏定义的结束。\n.exitm 提前从当前的宏定义中退出\n\\@  as汇编器维护了一个计数器来记录当前运行了多少个宏了，\\@就是这个计数器变量。你可以使用“\\@”将这个计数器的值拷贝到你的输出中，但是这个符号只能在宏定义的上下文中使用。\n\n## .nolist\n见.list\n\n## .octa bignums\n这个命令可以接0个或者多个大整数，各个数以逗号隔开。这些大整数最多是16个字节的整数。\n\n为啥这里使用.octa这个单词呢？ 因为在计算机中，通常定义一个word是两个字节，那么octa个word就是16个字节了。\n\n## .org new-lc, fill\n将当前section的位置计数器（location counter）推进到new-lc参数指定的位置。new-lc可以是一个常量表达式，或者相同section内的当前subsection的表达式。也就是说，你不能用.org命令来跨section。如果new-lc指定到了一个非法的secton，.org命令会被汇编器给忽略掉。为了和以前的编译器兼容，如果new-lc指定的sectoin是absolute，as汇编器会抛一个告警，然后并提示说new-lc指示的section和当前的subsection相同。\n\n.org一般只能向前增加位置计数器，或者不做改动。你不能时候.org命令来将位置计数器向后移。\n\n由于as汇编器会尽力只执行一遍就完成汇编，new-lc参数不能是undefined。\n\n注意，移动的起点是section的起始点，而不是subsection的起始点。这个是为了和其他的汇编器保持兼容。\n\n当当前subsection的位置计数器开始向前移动时，越过的字节空间会被填充位参数fill提供的字节内容。所以fill参数必须是一个常量表达式。如果逗号和fill参数省略的话，默认使用0进行填充。\n\n## .p2align[wl] abs-expr, abs-expr, abs-expr\n将一个位置计数器（在当前subsection的位置计数器）限制在一个特殊的存储范围内。第一个参数必须是一个常量表达式，它声明了在对齐后位置计数器的低多少位必须是0.举个例子： '.p2align 3'说明位置计数器需要需要向前移动，直到位置计数器的值是8的倍数。如果位置计数器已经是8的倍数，那不需要做什么变化。\n\n第二个参数也是一个常量表达式，它声明了在对齐的时候，使用什么字节来填充。第二个参数可以被省略，如果省略的话，默认会使用0来填充。不过呢，在一些系统中，如果这个section中含有代码，并且省略了使用什么值来填充，那么会使用no-op指令来填充。\n\n第三个参数也是一个常量表达式，并且也是可选的。如果使用了这个参数，那么它声明了在对齐命令执行的时候，允许跨过的最大字节数。如果跨过的字节数大于这个参数的给定值，那么这次对齐不会执行。你可以使用两个逗号（‘,,’）来省略第二个参数同时使用第三个参数。这种写法在你想使用no-op命令来填充的时候很有用。\n\n.p2alignw和.p2alignl命令是.p2align命令的衍生。.p2alignw命令按照2个字节的模式来填充。.p2alignl命令按照4字节的模式来填充。举个例子，‘.p2alignw 2,0x368d’会按照4的倍数进行字节对齐，如果对齐过程中跨过的了2个字节，那么跨过的这两个字节会使用‘0x368d’这个值来填充。如果跨过的字节数是1或者3，那么使用什么值来填充是不确定的。\n\n## .previous\n这个是ELF文件的section栈操作命令。其他的栈操作命令包括.section, .subsectioin, .pushsection 和 .popsection。\n\n这个命令会交换当前的section和上一个访问的section。同一行中的多个.previous命令会翻转两个section。\n\n从section stack的角度来看，这个命令会交换当前section和section stack的栈顶sectoin。\n\n## .popsection\n这是一个ELF文件的secton stack操作命令。\n\n这个命令会将当前section替换成section stack的栈顶section。\n\n## .print string\nas汇编器会在汇编的时候将string的内容输出到标准输出。string必须使用双引号引起来。\n\n## .protected names\n这个是一个ELF的可见性命令。其他的两个可见性控制命令是.hidden和.internal。\n\n这个命令会覆盖有名符号的默认可见性（由它们的绑定关系确定：local, global或者weak）。这个命令会将可见性设置成protected，这意味着在当前模块中任何对于个这符号的引用都被限制在定义这个符号的模块中，即便在另外一个模块中再定义一下这个符号也不行。\n\n## .psize lines, columns\n可以使用这个命令来定义每页可以有多少行，多少列（多少列是一个可选项）。\n\n如果你不使用.psize命令，那在汇编过程展示的时候默认使用60行每页。你可以省略columns这个参数，省略的话默认值是200.\n\nas汇编器会在超出这个限定的行数之后自动添加换行符。如果你想自己搞一个换行符，你可以使用.eject命令。\n\n如果你声明的Lines参数是0，那就意味着as汇编器不会自己加换行符了。\n\n## .purgem name\nundefine一个宏名，这样的话后面就不能使用这个宏了。\n\n## .pushsection name, subsection\n这是一个ELF文件的secton stack操作命令。\n\n这个命令和.section命令是一个语义。它会将当前section push到section栈的栈顶，然后将当前栈的名字和subsection替换成‘name’参数的值和subsection参数的值。\n\n## .quad bignums\n.quad接受0个或者多个bignum参数，参数间通过逗号隔开。每个bignum都占用8个字节，如果这个bignum超过了8个字节，那会抛出一个告警，然后截断低位的8个字节。\n\n单词‘quad’是从'word'这个词演化过来的，'word'是占2个字节，所以'quad-word'是占8个字节。（quad在英文中有4倍的意思）\n\n## .rept count\n将指令.rept和指令.endr之前的行数按顺序重复‘count’次。\n\n举个例子，汇编代码：\n.rept 3\n.long 0\n.endr\n\n等价于：\n.long 0\n.long 0\n.long 0\n\n## .sbttl \"subheading\"\n在生成listing的时候将参数“subheading”设置位标题。\n\n这个命令会影响后面的页数，如果当前行在一页的开它，那也会影响当前页。\n\n## .scl class\n为一个符号设置存储类型（storage-class）。这个命令只能在.def/.endef命令对中间使用。存储类型指的是将一个符号标记成是静态的或者外部的，或者记录一些将来调试用的符号信息。\n\n.scl命令最开始是COFF输出文件专用的。如果在生成b.out文件的时候设置这个，as汇编器会忽略。\n\n## .section name\n使用.section命令来指示汇编器将下面的代码汇编到‘name’参数指定的section中。\n\n这个命令只能在那些支持自定义section名称的目标文件格式中使用。比如在a.out格式中，这个命令就不支持，即使你声明的是一个标准a.out支持的section名也不行。\n\nCOFF格式版本\n对于COFF目标格式，.section命令有下面几种使用方式：\n.section name[, \"flags]\n.section name[, subsegment]\n如果可选的参数是通过双引号引起来的，那么参数会被认为是描述这个section的一些flag标记。每个标记都是一个字符。总共支持的字符包括：\nb: 代表bss section\nn: 说明section没有被加载\nw: 可写section\nd: 代表是一个data section\nr: 代表是一个只读section\nx: 代表是一个可执行section\ns: 代表是一个共享section（对于PE格式的输出比较重要）\na: 无意义，仅仅是为了兼容ELF格式\n\n如果没有声明任何flag，那么默认的flag值由section名字决定。如果声明的参数‘name’不是一个标准的section，as汇编器不认识，那么默认的flag会将section设置成可加载、可写。注意，'n'和'w' flag的原理是从指定的section中移除一些属性，而不是往这个section中添加一些属性，因此如果你仅仅使用这两个flag，相当于你没有对这个section的声明任何flag。\n\n如果提供的参数没有加引号，那这个参数会被当作一个subsegment的编号。\n\nELF格式版本\n这个命令是一个ELF section栈操作命令。其他的几个section栈操作命令包括：  .subsection, .pushsection, .previous等等。\n\n对于ELF格式，.section命令的用法是：\n.section name [, \"flags\" [, @type[, @entsize]]]\n可选的参数flags需要用引号引起来，它一般是下面几个字符组成的字符串：\na: section可以被分配空间\nw: section是可写的\nx： section可执行\nM：section可以被合并\nS：section包含以0结尾的字符串\n可选参数‘type’可以使用下面几种可选值：\n@progbits: 说明section包含数据\n@nobits：说明section不包含数据（也就是说，这个section仅仅是用来占空间的）\n注意，如果在一些‘@’字符代表注释的体系架构下（比如ARM架构），那么就得用其他符号来代替’@‘字符了。比如ARM架构就是使用’%‘来代替’@‘的。\n\n如果‘flags’参数中包含‘M’，那么‘type’参数必须带上‘entsize’参数。带有'M'标记但是不带‘S’标记的section必须包含固定大小的常量，每个常量必须是‘entsize’这么大。既带有‘M’标记又带有‘S’标记的section必须包含以0结尾的字符串，并且字符串中的每个字符都必须是‘entsize’这么大。链接器可能会去除一些相同名字、并且相同flags、并且相同entsize的section。\n\n如果没有声明flags，那默认的flags取决于声明的是什么section名字。如果声明的不是一个汇编器认识的名字，那么默认的flags就代表这个section不包含上面介绍的任何一个flag： 也就是说，这个section不能在内存中分配空间，并且不可写，并且不可执行，可以包含数据。\n\n对于ELF格式来说，汇编器支持另外一种形式的.section命令： .section \"name\"[, flags...]，这个是为了和Solaris汇编器兼容而设计的。\n\n这个命令会将替换当前section和当前subsection的值。被替换的section和subsection会被push到section栈中。可以在gas汇编器源码的测试用例目录gas/testsuite/gas/elf中找到一些section栈操作命令使用的例子。\n\n## .set symbol, expression\n将符号‘symbol’的值设置成表达式‘expression’代表的值。这个命令会改变符号'symbol'的值和类型。如果符号'symbol'的flag是external，那么这个符号的flag还是会保留。\n\n你可以使用.set命令重复设置一个符号多次。\n\n如果你使用.set命令设置一个全局符号，那么最终存入到obj文件中的符号的值将会是最后一次设置的值。\n\n## .short expressions\n.short命令和.word命令差不多。不过在有一些系统的配置中，.short命令和.word命令生成的长度是不一样的。\n\n## .single flonums\n这个命令会编排0个或者多个浮点数，每个浮点数通过逗号隔开。这个命令的效果和.float命令的效果一样。具体这个浮点数是如何标识的依赖于as汇编器的配置。\n\n## .size\n这个命令用来设置一个符号的大小\n\nCOFF格式\n对于COFF格式的目标文件来说，这个.size命令只能在.def/.endef命令对中使用，使用的方法是： .size expression。.size命令只有在生成COFF格式的输出文件时有意义，如果as汇编器输出的b.out格式的文件，那么这个命令会被忽略。\n\nELF格式\n对于ELF格式的目标文件来说，这个.size命令的用法是： .szie name, expression 。这个命令设置了一个名为'name'的符号的大小。符号大小由expression表达式的值给出。这个命令多用来定函数符号的大小。\n\n## .sleb128 expressions\nsleb128代表‘single little endian base 128’\n\n## .skip size, fill\n这个命令会向前预留'size'个字节，每个字节使用‘fill’值填充。size参数和fill参数都是常量表达式。如果逗号和fill参数省略了的话，fill参数的值默认会是0。这个命令和.space命令是一样的。\n\n## .space size, fill\n这个命令会向前预留'size'个字节，每个字节使用‘fill’值填充。size参数和fill参数都是常量表达式。如果逗号和fill参数省略了的话，fill参数的值默认会是0。这个命令和.skip命令是一样的。\n\n## .stabd, .stabn, stabs\n这三个命令都以.stab打头。这些个命令都会声明一些供符号调试器使用的符号。这些符号都不会进入到as汇编器的hash表中： 因此它们不能在源代码的任何地方被引用。这些符号有5个字段：\n\nstring： 这个是声明这个符号的名字。可以包含任何字符除了字符‘\\000’，也就是说这里的符号名可以比普通的符号名包含更多类型的字符。一些调试器往往会在这个字段设置一些更加复杂的符号名。\n\ntype: 一个常量表达式。符号的类型会被设置成这个表达式的低8位。任意位的组合都是可以的，但是ld链接器和调试器会被一些奇奇怪怪的位组合给卡住。\n\ndesc： 一个常量表达式。符号的descriptor会被设置成这个表达式的低16位。\n\nvalue: 一个常量表达式，符号的值会被设置成这个表达式的值。\n\n如果在读取一个.stabd, .stabn 或者 .stabs语句的时候产生了告警，那这个符号大概率已经被生成了；不过你会在你的obj文件中得到一个不完整的符号。这种行为也是为了和以前的汇编器保持兼容。\n\n.stabd type, other, desc: 参数‘name‘代表生成的符号名，基本上不可能是一个空字符串。为了保持兼容性，在是一个空字符串的时候，它会是一个空指针。一些老的汇编器会使用空指针来代表空字符串，这样不会浪费空间。定义的符号的值会设置在当前位置计数器的地方。当你的程序被链接时，这个符号的地址会被链接成当前位置计数器的地址。\n\n.stabn type, other, desc, value: 符号的名字会被设置成空字符串。\n\n.stabs string, type, other, desc, value： 5个字段都声明了。\n\n## .string \"str\"\n将当前字符串“str”拷贝到目标文件中。你可以同时声明多个字符串，每个字符串都以逗号隔开。正常情况下，汇编器会将每个字符串的结尾添加一个0字节。\n\n## .struct expression\n切换到absolute section，并且将section的偏移设置成参数'expression'的值，这个参数必须时一个常量表达式。你可以这样使用：\n.struct 0\nfield1:\n.struct field1+4\nfield2:\n.struct field2+4\nfield3:\n这种写法会将符号field1的值设置成0，符号field2的值设置成4，符号field3的值设置成8.这个汇编过程会被限制在absolute section内，在进一步汇编之前，你需要使用.section命令来切换到其他的section内。\n\n## .subsection name\n这个是EFL section栈操作命令之一，其他的几个栈操作命令包括.section， .pushsection, .popsection, 和 .previous。\n\n这个命令会将当前的subsection替换成参数'name'声明的section。当前的sectioni不会发生改变。被替换的subsection会被push到section栈的顶部。\n\n## .symver\n你可以使用.symver命令在一个源代码文件中将一个符号绑定到一个指定的版本。这个命令只支持在ELF格式文件中使用，而且在将文件汇编和简介到一个共享库中时十分有用。下面有一些例子展示了如何在共享库中使用.symver命令来将符号限定在某些版本中可用。\n\n对于ELF文件来说，.symver可以这样用：\n.symver name, name2@nodename\n如果在汇编源代码文件中定义一个符号名‘name’,.symver命令会同时为符号‘name’创建一个别名‘name2@nodename’, 事实上我们不直接创建一个别名符号的原因是'@'符号是不能在符号名中使用的。‘name2’这一部分是这个符号的实际名字，可以被外部引用。参数‘name’仅仅是为了说明这个符号有可能在多个版本中有定义，这样编译器可以明确的知道具体指的是那个符号。'nodename'这一部分是一个在version script(提供给链接器使用)中声明的节点的名字。如果你想在共享库中覆盖一个带版本的符号，那么‘nodename’参数就需要对应上你想覆盖的符号对应的nodename。\n\n当参数‘name’对应的符号没有在汇编的时候定义的时候，所有引用符号‘name’的地方都会被汇编成‘name2@nodename’。如果符号‘name’没有被引用过，那么符号'name2@nodename'会从符号表中被移除。\n\n另一个使用.symver命令的方法： .symver name, name2@@nodename。在这种用法中，符号‘name’必须存在并且在当前被汇编的文件中存在。第二个参数和'name2@nodename'有点像，但是‘name2@@nodename’也会被链接器当作是‘name2’的引用。\n\n第三种使用.symver命令的方法是： .symver name, name2@@@nodename。在汇编的过程中如果发现‘name’没有被定义，那么这个符号会被当作‘name2@nodename’。当符号‘name’定义了的时候，符号’name‘会转成'name2@@nodename'.\n\n## .tag structname\n这个命令是由编译器自动生成的，用来在符号表中生成一些辅助的调试信息。这个命令只能在.def/.endef命令对中出现。Tags可以用来连接符号表中这些structure的定义以及这些structure的实例。\n\n‘.tag’只能在生成COFF文件的时候使用。当生成b.out文件的时候，as汇编器会直接忽略这个命令。\n\n## .text subsection\n告诉as汇编器将下面的语句汇编到.text的第'subsection'个subsection的末尾，参数‘subsection’必须是一个常量表达式。如果省略了‘subsection’参数，那么默认是0.\n\n## .title \"heading\"\n在生成Listing的时候将title设置成“heading”。\n\n这个命令会影响后续list时候的页数，如果在当前页的前10行出现的时候，也会影响当前页的页数。\n\n## .type\n这个命令用来设置一个符号的类型。\n\nCOFF版本：\n对于COFF格式的文件，这个命令必须出现在.def/.endef命令对的中间。用起来时候像这样： .type int。类型的属性会以一个整数的形式存放在符号表中。\n.type命令只对COFF文件格式有效，当生成b.out格式的时候，这个命令会直接被忽略。\n\nELF版本：\n对于ELF格式的文件，这个命令是这样使用的： .type name, type description。这个用法会将符号‘name’的类型设置成一个函数符号或者一个对象符号。参数”type description“有5种不同类型的语法(为了和其他的汇编器兼容):\n.type <name>, #function\n.type <name>, #object\n.type <name>,@function\n.type <name>,@object\n.type <name>,%function\n.type <name>,%object\n.type <name>,\"function\"\n.type <name>,\"object\"\n.type <name>,STT_FUNCTION\n.type <name>,STT_OBJECT\n\n## .uleb128 expressions\nuleb128的意思是： ‘unsigned little endian base 128’。\n\n## .val addr\n这个命令只能出现在.def/.endef命令对之间，参数‘addr’记录了符号表中符号的value属性所存放的地址。\n\n.val命令只能在COFF文件格式中使用 ，当as汇编器输出b.out格式文件的时候，这个命令会被忽略。\n\n## .version \"string\"\n这个命令会创建一个.note section，并且会将一个ELF格式的note放入这个section。这个note的类型是NT_VERSION，名字为参数\"string\"。\n\n## .vtable_entry table, offset\n这个命令会查找或者创建一个名为“table”的符号，并且为它创建一个VTABLE_ENTRY重定位。\n\n## .vtable_inherit child, parent\n这个命令会查找一个名为'child'的符号，然后查找或创建一个名为‘parent’的符号，然后为符号parent做一次VTABLE_INHERIT重定位，重定位的偏移值是符号child的值。一种特殊的情况是，parent的名字是0，那么parent会被当作ABS section。\n\n## .weak names\n这个命令会为参数'names'声明的符号序列（符号序列以逗号相互隔开）设置一个weak属性。如果给定的符号已经不存在，那么会创建新的同名的符号。\n\n## .word expressions\n这个命令接受0个或者多个表达式作为参数，每个参数以逗号隔开。\n\n给定的参数中的数字大小范围，以及字节序，取决于汇编器运行的计算机架构。\n\n注意： 为了支持编译器做的一些特殊处理：\n32位地址空间但是寻址不足32位的机器，这个命令会做以下特殊处理：如果这个机器使用了32位寻址，你可以忽略这个问题。为了汇编一些编译器生成的中间代码，as汇编器有些时候会在.word命令中做一些奇怪的事情。比如命令格式‘.word sym1-sym2’会经常被编译器用来在表之间做跳转。因此，当as汇编器汇编一个格式为’.word sym1-sym2‘的命令，并且sym1和sym2之前的差异不是16位的时候，as汇编器会在下一个标号前立即创建一个secondary jump table。这个“secondary jump table”会做一个short-jump跳转到这个secondary table后面的第一个字节。这次跳转可以避免控制流意外的进入新的table中。\n\n\n# 80386架构相关的特性\nas汇编器的i386版既支持原有的Intel 386架构(包括16位和32位模式)，也支持AMD在Intel 64位架构下扩展的的x86-64架构。\n\n## 命令行选项\nas汇编器的i386版本有一些机器相关的命令行选项：\n--32 | --64\n设定字长为32位或者64位。选择32位的话意味着是Intel i386架构，选择64位的话意味着是AMD x86-64架构\n\n这个选项只能在生成ELF格式文件的时候有用，并且需要确保必要的BFD支持已经被包含了（在32位平台你需要加上-enable-64-bit-bfd来配置）。\n\n## AT&T汇编语法 vs Intel汇编语法\nas汇编器现在也支持使用Intel汇编器的语法，你可以使用.intel_syntax来选择Intel模式，使用.att_syntax来切回默认的AT&T模式。GCC默认是生成AT&T模式的汇编代码。上面这两个命令可以带可选的参数： prefix/noprefix声明寄存器符号是否需要一个\"%\"作为前缀。AT&T的汇编语法和Intel的语法有很大不同，我们这里特意说明下这些不同，因为几乎所有的80386文档都是使用的Intel语法。这两种语法建最大的两个区别是： \n1. AT&T的立即数以‘$’打头；Intel的立即数没有什么特殊前缀（比如Intel语法的'push 4'在AT&T语法中为'pushl $4'）。AT&T的寄存器操作数以'%'打头，Intel语法中的寄存器操作数没有什么特殊前缀。AT&T中的常量跳转/调用操作（与之相反的是PC相关的跳转/调用操作）以'*'打头，在Intel语法中没有什么特殊前缀。\n2. AT&T和Intel的语法在源操作数和目的操作数的顺序上正好相反。Intel的语句“add eax, 4”在AT&T中为“addl $4, %eax”. “source, dest”这样的使用习惯是为了和以前的Unix汇编器保持兼容。需要注意的是，那些多于一个源操作数的指令（比如'enter'指令）没有采用和Intel相反的顺序。\n3. AT&T的语法中，内存操作数的大小由指令助记符的最后一个字符决定。这些助记符的后缀包括： 'b', w', 'l', 'q' 分别对应 byte(8位),word(16位), long(32位),和quadruple word(64位)内存寻址。在Intel的语法中，做到相同功能的写法是给内存操作数(不是指令助记符)加前缀，对应的，内存操作数的前缀包括'byte ptr', 'word ptr', 'dword ptr', 'qword ptr'。因此，Intel中的'mov al, byte ptr foo'对应与AT&T中的'movb foo, %al'。\n4. AT&T语法中的长跳转/长调用逻辑是：'lcall/ljump $sectoin, $offset'; 对应的Intel语法是： 'call/jmp far section:offset'。对应的，AT&T中的长返回指令为：'lret $stack-adjust'; Intel的长返回语法为：'ret far stack-adjust'.\n5. AT&T的汇编器不支持多section的程序，Unix风格的系统希望所有的程序都在一个section中。\n\n## 指令命名\nAT&T的指令助记符会以一个特殊字符结尾，这个字符标识了操作数的大小。'b','w','l','q'分别对应于byte, word, long, quadruple word。如果没有声明任何的后缀的话，as汇编器会尝试依据目标寄存器来自动补上这个后缀字符。因此，'mov %ax, %bx'等价于‘movw %ax, %bx’; 同样的，'mov $1, %bx'等价于‘movw $1, bx’。\n\n几乎所有的AT&T指令都会在Intel格式中有同名的指令。不过也有一些例外。符号扩展和0扩展指令在使用时需要两种大小的操作数。一种大小用来指示此次符号/0扩展的from的大小，另一种大小用来指示0扩展中的to的大小。这个需求在AT&T语法中是通过两个指令助记符后缀来完成的。AT&T语法中基础的符号扩展和0扩展为： 'movs ...'/'movz...'（对应Intel语法中的'movsx'和'movzx'）。指令助记符的后缀紧跟着指令的基础名字，from的后缀，然后是to的后缀。因此，AT&T中的语句‘movsbl %al, %eds’意思是：“符号扩展移动，从%al到%edx”。这里的后缀是'bl',意味这是“从byte到long”。其他的还有'bw', 从byte到word；'wl',从word到long；'wl',从word到long; 'bq',从byte 到quadruple word; 'wq', 从word到quadruple word; 'lq', 从long到quadruple word。\n\n在Intel语法中,下面这些指令：\n - 'cbw': 符号扩展，将“%al”扩展为\"%ax\"\n - 'cwde': 符号扩展，将一个\"%ax\"中的word扩展成一个存储在\"%eax\"中的long\n - 'cwd': 符号扩展，将\"%ax\"中的word扩展成一个存储在\"%dx:%ax\"中的long\n - 'cdq': 符号扩展，将“%eax”中的一个dword扩展成一个存储在“%edx:%eax”中的quad\n - 'cdqe': 符号扩展，将“%eax”中的一个dword扩展成一个存储在“%rax”中的quad\n - 'cdo': 符号扩展，将\"%rax\"中的一个quad扩展成一个存储在\"%rdx:%rax\"中的octuple\n在AT&T中对应的写作： \"cbtw\", 'cwtl', 'cwtd', 'cltd', 'cltq', 'cqto'。\n\nAT&T中的长调用/跳转指令为“lcall”/\"ljmp\"，Intel中对应的指令为“call far”/\"jump far\"。\n\n## 寄存器命名\n寄存器操作数通常会以\"%\"为前缀。80386寄存器包括：\n - 8个32位的寄存器%eax(累加器)， %ebx, %ecx, %edx, %edi, %esi, %ebp(栈帧指针), %esp(栈顶指针)\n - 8个16位寄存器： %ax, %bx, %cx, %dx, %di, %si, %bp, %sp\n - 8个8位寄存器： %ah, %al, %bh, %bl, %ch, %cl, %dh, %dl\n - 6个section寄存器： %cs (code section), %ds(data section), %ss(stack section), %es, %fs, %gs\n - 3个处理器控制寄存器： %cr0, %cr2, %cr3\n - 6个调试寄存器： %db0, %db1, %db2, %db3, %db6, %db7\n - 2个调试寄存器： %tr6和%tr7\n - 8个浮点栈寄存器： %st，准确的写法是： %st(0), %st(1), %st(2),%st(3),%st(4),%st(5),%st(6),%st(7)。这些寄存器也就是对应的8个MMX寄存器： %mm0, %mm1, %mm2, %mm3, %mm4, %mm5, %mm6, %mm7。\n - 8个SSE寄存器： %xmm0,%xmm1,%xmm2,%xmm3,%xmm4,%xmm5,%xmm6,%xmm7。\n\nAMD的x86-64扩展的寄存器包括：\n - 将8个32位寄存器扩展到64位： %rax, %rbx, %rcx, %rdx, %rdi, %rsi, %rbp, %rsp\n - 8个扩展寄存器: %r8 - %r15\n - 8个32位的小端扩展寄存器： %r8d - %r15d\n - 8个16位的小端扩展寄存器： %r8w - %r15w\n - 8个8位的小端扩展寄存器： %r8b - %r15b\n - 4个8位的寄存器： %sil, %dil, %bpl, %spl\n - 8个调试寄存器： %db8 - %db15\n - 8个SSE寄存器： %xmm8 - %xmm15\n\n## 指令前缀\n指令前缀是用来修改接下来的指令的。它们的功能包括： 重复一些字符串指令，提供section覆盖，执行锁总线操作，改变操作数和地址大小。指令前缀最好和它们要修饰的指令写在同一行。举个例子，“scas”(scan string)指令可以这样被修饰： repne scans %es:(%edi), %al\n\n下面是一些常见的指令前缀：\n - section覆盖类前缀： 'cs', 'ds', 'ss', 'es', 'fs', 'gs'。这些前缀会被汇编器自动添加到section:memory-operand内存寻址表达式上，形成一种类似于“section:memory-operand”形式的地址表达式。\n - 操作符/地址大小前缀（比如data16/addr16）可以将一个32位的操作数/地址转成16位的操作数/地址；data32/addr32可以将16位的操作数/地址转成32位的操作数/地址。这些指令前缀必须和它们修饰的指令出现在同一行。举个例子，在一个16位的.code16 section内， 你可以这么写： addr32 jmpl *(%ebx)。\n - 锁总线前缀可以让当前指令在执行的时候禁用中断。这种用法只对某一些指令有效，详情得参考80386的手册。\n - 等待协处理器的指令前缀：\"wait\"，它可以让当前指令在执行的时候等待协处理器操作完成。这个在80386/80387系列中用不上了。\n - \"rep\", \"repe\", \"repne\"前缀，用于修饰字符串指令，这样可以让这些字符串指令重复“%ecx”次。\n - x86-64指令集使用\"rex\"系列前缀来扩展i386指令集。\"rex\"前缀有4位，用来将一个操作数从32位扩展到64位，\n\n## 内存寻址\n在Intel汇编中，间接寻找的格式是： section: [base+index*scale+disp]， 对应AT&T格式为： section:disp(base, index, scale)。\n这里base和index是可选的32位基址和索引寄存器，disp是可选的偏移量，scale 可以取值1,2,4,8, 代表这个操作数的地址是多少倍的index。如果没有给出scale参数的话，scale默认是1。section参数声明了内存操作数的section寄存器，这个参数可能覆盖默认的section寄存器。不过要注意的是AT&T语法中，寄存器覆盖必须用符号“%”显式说明。如果你声明的section寄存器和默认的section寄存器一样的，as汇编器不会给当前指令加什么前缀修饰。因此，section这个参数一般用来强调声明下当前的内存寻址使用的是哪个section寄存器。\n\n下面是一些具体的例子来比较Intel和AT&T的内存寻址风格：\n - AT&T： '-4(%ebp)', Intel: '[ebp -4]'。base参数位%ebp, disp参数为-4，section参数没有给出，默认为%ss，因为使用%ebp默认对应的就是%ss。index, scale参数都没有给出。\n - AT&T: 'foo(,%eax, 4)', Intel: '[foo+eax*4]': index参数为%eax, scale参数为4，disp参数为'foo'。其他所有的参数都省略了。section寄存器默认使用的是%ds\n - AT&T: 'foo(,1)', Intel: '[foo]': 这个指令是将foo的地址值地址当作了内存操作数。base和index参数省略了，其他的只有一个逗号，因此这个语句是有语法问题的。\n - AT&T： '%gs:foo', Intel: 'gs:foo': 这个是选中了变量foo中存储的内容，section寄存器使用的是gs\n\n绝对调用和跳转指令必须使用'*'作为前缀。如果没有给一个'*'的话，as汇编器通常会选择一个PC计数器相对的地址进行跳转/调用。\n\n任何有内存操作数，但是没有寄存器操作数指令，都必须通过指令助记符的后缀声明数据操作的大小。\n\nx86-64架构添加了RIP(instruction pointer relative)地址。这种地址模式必须使用\"rip\"寄存器当作基址寄存器，并且只允许使用常量的offset。举个例子：\n- AT&T: '1234(%rip)', Intel: '[rip+1234]' 这个地址指令当前指令的向后1234字节处。\n- AT&T: 'symbol(%rip)', Intel: '[rip+symbol]'。这个地址以相对RIP指针的方式指向符号symbol。这种写法比使用默认的绝对寻址方式简短一些。\n\n其他32位的寻址模式在x86-64位架构下都保持不变，除了将32位寄存器换成对应的64位寄存器。\n\n## 跳转类指令的处理\n跳转类指令通常都会被优化下，这样可以保证跳转的时候只跳转一个最小的偏移量。如果跳转的目标地址足够近的话，跳转指令的偏移量参数只有8位。如果跳转的目标地址太远的话，会使用一个长一点的偏移量参数来做这个事情。在32位模式中，我们不支持16位的跳转偏移量参数。这个不是汇编器的锅，这个是因为80386CPU架构只会使用%eip寄存器的16位，而不是32位。\n\n需要注意的是，'jcxz', 'jecxz', 'loop', 'loopz', 'loope', 'loopnz' 和 'loopne'指令都只能使用8位的跳转偏移量，因此如果你要使用这些指令（反正GCC是不会用的）可能会报错。AT&T的80386汇编器为了应对这种问题，会尝试将'jcxz foo'命令解释成：\n```\njcxz cx_zero\njmp cx_nonzero\n\ncx_zero: jmp foo\ncx_nonzero:\n```\n\n## 浮点数\n80387的所有浮点类型（除了packed BCD）都支持。这些数据类型可以是16位、32位、64位的整数，以及32位的单精度浮点数和64位的双精度浮点数，还有80位的扩展京都浮点数。每种支持的类型都有一个指令助记符后缀以及一个与之相关的构造命令。指令助记符的后缀声明了这个操作数的数据类型。构造命令将这些数据类型存入到内存中。\n\n - 浮点类型的构造方法包括： .float, .single, .double 和 .tfloat 对应与 32位， 32位，64位，和80位的格式。80387只能通过fldt和fstpt指令来支持这些格式。\n - 整数构造命令包括： .word, .long, .int 和 .quad， 对应 16位， 32位， 64位 整数格式。对应的指令助记符后缀是's'(single), l(long), q(quad)。对于80位的实数格式，64位的'q'格式只会在 fildq和fistpq指令中出现。\n - 寄存器到寄存器的操作不应该使用指令助记符后缀。'fstl %st, %st(1)'这样的代码会抛出一个警告，然后当作指令'fst %st, %st(1)'命令去汇编。这是因为所有的寄存器到寄存器操作都是使用80位的浮点操作。\n\n## Intel的MMX指令集，以及AMD的 3DNow! SIMD操作\nas汇编器支持Intel的MMX指令集（Intel的整数数据SIMD指令集合）。as汇编器也支持AMD的3DNow!指令集（一种32位的浮点数数据的SIMD指令集）。\n\n到目前位值，as汇编器还不支持Intel的浮点SIMD指令集：Katmai(KNI)。\n\n8个64位MMX操作，也在3DNow!指令集中，它们是：  %mm0, %mm1, ..., %mm7。它们包含8个8位的整数，4个16位的整数，2个32位的整数，1个64位的整数，或者2个32位的浮点值。MMX寄存器不能同时当作浮点栈使用。\n\n可以参考下Intel和AMD的文档，需要注意的是，AT&T语法和Intel语法中操作数的顺序是相反的。\n\n## 用as写16位的汇编代码\n除了使用默认的配置，用as来写纯32位的i386代码或者64位的x86-64位代码外，as汇编器也支持跑在实模式的代码和跑在保护模式的16位代码。如果想这么做的话，可以在要以16位模式运行的代码前面写上.code16或者.code16gcc命令。你可以通过.code32命令将as切会32位模式。\n\n.code16gcc提供了一些尚在实验阶段的特性，它们可以支持gcc来生成16位的代码。因此，这个命令修饰的代码和.code16命令修饰的代码有一些不一样，主要是.code16中， call, ret, enter, leave, push, pop, pusha, popa, pushf, popf这几个指令默认是32位大小的。这么做是为了让栈指针可以在函数调用的时候保持同样的操作行为，以此来确保32位模式下函数的参数顺序是没有问题的。.code16gcc命令也会gcc生成32位地址的时候自动添加地址的大小前缀。\n\nas汇编器生成的16位代码不一定必须要运行在16位的80386处理器上。如果你确实是需要跑在这样的处理器上，你必须自己保证绝不在代码中使用任何32位的指令。\n\n如果要写16位的代码指令，得显式地声明指令助记符的前缀和后缀。在32位的代码段中，下面的代码： pushw $4 会生成机器码'66 6a 04'，意思是将4push到栈上，然后将%esp减2.\n\n同样的代码在16位的代码段中会生成机器码'6a 04'（也就是说，忽略了操作符前缀）。这个也是可以正确执行的，因为默认的操作数大小是16位，因为这个代码是在一个16位的代码段中。\n\n## AT&T的语法bug\n类Unix汇编器，以及其他从ix86衍生出来的AT&T汇编器，都会在几种特定的情况下，通过预留源寄存器和预留目的寄存器的方式来生成浮点指令。不幸的是，gcc以及其他的程序可能会使用这些预留的寄存器，然后我们就会卡在这了。\n\n举个例子：  fsub %st, %st(3)\n\n这个代码会将 %st(3)中的内容更新成 %st - %st(3) 而不是期望的 %st(3) - %st。这个情况会出现在两个操作数中源操作数是在%st寄存器中，目的操作数在%st(i)寄存器中的这种不可交换的四则浮点运算代码中。\n\n## 声明CPU架构\nas汇编器和通过.arch cpu_type命令声明一个特定的CPU架构。声明之后，gas如果检测到一个不属于这个架构的指令之后，会抛出一个告警。cpu_type参数的可选项包括：'i8086', 'i186', 'i286', 'i386', 'i486', 'i586', 'i686', 'pentium', 'pentiumpro', 'pentium4', 'k6', 'athlon', 'sledgehammer'.\n\n除去可以产生告警之外，这个指令还会对as汇编器的行为产生下面两个影响： 1. 如果你声明了一种CPU架构（除了i486架构），那么左移一位的指令，像'sarl $1, %eax'会自动使用一个2字节的操作码序列（i486架构会产生3字节码序列,你可以通过代码'sar1 %eax'显式地请求）。2. 如果你声明了'i8086', 'i186'或者'i286'CPU架构，同时又使用了.code16/.code16gcc命令，那么在必要的时候，一个以字节位单位的条件跳转语句会被转成两条指令，一条指令是相反的条件的跳转指令，另一条是一个无条件跳转指令，这个无条件跳转指令会跳转到原始的指令想要跳转的地方。对于这种情况的CPU架构，你可以使用'jumps'或者'nojumps'指令来控制这种特殊情况的条件跳转指令的转化。默认会使用‘jumps’指令来进行跳转转化。所有的外部跳转都是使用long类型变量，而文件内部的跳转是必须进行跳转转化的。'nojumps'指令将外部跳转指令看作是基于字节偏移的跳转，并且会在as汇编器进行文件内部跳转的转化的时候告警。非条件跳转指令和jumps指令类似。\n\n举个例子，你可以写这样的代码：  .arch i8086, nojumps\n\n## 备注\n值的说明的是，mul和imul指令有一些trickery。16位，32位，64位，128位扩展的乘法（乘法基本的操作码是0xf6,扩展位4对应与mul指令，5对应于imul指令）只能以一种操作数格式输出。因此，imul %ebx, %eax 指令不会选择扩展的乘法。扩展乘法会搞乱%edx寄存器，这会对gcc的输出造成影响。可以使用imul %ebx来获取64位的输出值（这个值是存储在%edx:%eax中）。\n\n我们添加了imul指令的2操作数形式，第一个操作数是一个立即数表达式，第二个操作数是一个寄存器。这只是一种简写，因此，如果你需要将 %eax乘以69，可以这么写： imul $69, %eax。而不是这么写：  imul $69, %eax, %eax。"},{"title":"kernel开发环境","url":"/2021/06/27/kernel开发环境/","content":"\n1. 编译\n就是常规的make menuconfig/ make / make bzImage套路，最终生成一个bzImage镜像文件\n\n2. 制作根文件系统\n略有一些复杂： \n - 创建一个目录x\n - 将一些要放入根文件系统的工具编译好，放入x目录中。通常是一些系统启动前需要使用的工具\n - 将x目录用cpio指令打包成一个img文件：  find . | cpio -o -Hnewc | gzip -9 > y.img\n\n3. 使用qemu将上述两个镜像加载并启动：  qemu -kernel bzImage -initrd y.img\n"},{"title":"胡思乱想","url":"/2021/05/17/胡思乱想/","content":"\n`人们对于美好生活的向往和追求是无止尽的，只有知足才有机会守住人性中的单纯和善良。\n当然，这更多的是一个「愿意不愿意」的问题，而不是一个「可行不可行」的问题。\n`","tags":["thought"]},{"title":"test-mermaid","url":"/2021/04/12/test-mermaid/","content":"\n\n```mermaid\ngraph TD\n\nA --> B\n```"},{"title":"GNU build system","url":"/2021/03/18/GNU-build-system/","content":"\n# GNU M4\n\n一个「Unix宏处理器」。\nAutoconfig 中用它来生成configure文件。\n大概的几条语法规则:\n- 注释（从注释符（默认#）到换行）保持不动输出。\n- 名字（由若干字母、数字和下划线组成，不以数字开始），当碰到名字是宏名字（多参数宏还要求马上紧接开括号），就触发宏展开，否则保持不动输出。\n- 引用字符串（默认由配对的|和’包围，但这可以动态设置），会被剥去一层包装后输出。\n- 其它字符，保持不动输出。","tags":["Tech"]},{"title":"TCP-receive-queue","url":"/2021/01/20/TCP-receive-queue/","content":"\n连接过程:\n1. sync队列\n2. 已连接队列\n\n数据接收过程:\n\n- receive\n\n- out-of-order\n\n- backlog\n\n- prequeue\n\n1中描述的队列是socket队列，用来存储处于不同状态的socket实体。SYN状态是TCP三次握手的第一此握手完成之后所处的状态，内核会将处于该状态的socket存储于这个队列。在连接建立完成之后，socket会被放置在'已连接队列上'。\n\n2中描述的队列是skb队列，用来存储通信过程中不同情景下传输的skb。详细的说明如下:\n\n1. 假如用户态进程还没有调用recv函数，内核已经接收到数据，会将数据按顺序放置在receive队列\n\n2. 假如用户态进程还没有调用recv函数，内核已经接收到数据，但数据是乱序的，内核会先将乱序的skb暂时存放在out-of-order队列\n\n3. 假如用户态进程调用recv函数，进入了数据接收的上下文中，而此时网卡又接到了数据，网卡驱动会先将数据暂时放在backlog队列\n\n4. 假如用户态进程调用recv函数，但是因为没有数据所有阻塞了，进程被挂起了，而这个时候网卡收到了数据，网卡驱动会先将数据放在prequeue队列\n","tags":["Tech"]},{"title":"C++ can not set reference as key in STL","url":"/2021/01/09/CPP-can-not-set-reference-as-key-in-STL/","content":"\n在写图的算法，尝试将Node/Edge的对象作为key存入unordered_map，发现一系列问题。\n首先，如果要追求 \n```\n  std::unordered_map<Node, int> data;\n```\n这种写法(类似Java的那种风格)，得做两件事情:\n1. 为Node类型重载 == 运算符，如果不愿意，可以选择未Node类型实现 () 运算符;\n2. 实现一个自定义的供Node类型使用的hash方法，比如简单一点的:\n  ```\n  class MyHash {\n   public:\n    std::size_t operator() (const Node& node) const {\n      return node.id;\n    }\n  }\n  ```\n3. 剩下的事情就是在申明unordered_map时注意一下，将hash函数传进去就行: \n```\nstd::unordered_map<Node, int, MyHash> data;\n```\n\n\n后来想尝试下，能不能向Java那样，使用地址值来做为hash值呢?写了个最简单的demo:\n```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass A {\nprivate:\n  std::string data_;\npublic:\n  A() {\n    data_ = \"hello world\";\n  }\n  bool operator== (const A& b) const {\n    return (const A*)this == &b;\n  }\n\n};\nclass Myhash {\n  public:\n    std::size_t operator()(const A& b) const {\n      return (std::size_t)&b; \n    }\n};\n\nint main() {\n\n  A t;\n  std::unordered_map<A&, int, Myhash> data;\n  data[t] = 1;\n  for (auto elem : data) {\n    std::cout<<&(elem.first)<<\", \"<<elem.second<<std::endl;\n  }\n  std::cout<<data[t]<<std::endl;\n  return 0;\n}\n```\n到这里时，编译器报错了。google给出的答案是: STL中各种map(unordered_map, std::map)都是通过拷贝传值作为key，无法使用引用作为key。(ref: https://stackoverflow.com/questions/3235927/reference-as-key-in-stdmap)\n\n\n怎么做到像Java那样自定义对象做key呢?几种可行的思路:\n1. 舍弃Node做key，改用Node*;\n2. 设计一个较好的hash函数，使得即使是拷贝传值的两个对象，也可通过hash值认为是同一份\n3. 使用C++11引入的std::reference_wrapper\n","tags":["Tech"]},{"title":"TODO-booklist","url":"/2020/11/17/TODO-booklist/","content":"1. 塞缪尔·亨廷顿(Samuel Huntington) 《文明的冲突与世界秩序的重建》(The Clash of Civilizations and the Remaking of World Order)\n2. 拉斯洛•博克(Laszlo Bock) 《重新定义团队：谷歌如何工作》(Work Rules！Insights from Inside Google That Will Transform How You Live and Lead)\n3. 科里.帕特森(Kerry Patterson)等，《关键对话》(Crucial Conversations:Tools for Talking When Stakes Are High)\n4. GNU文档阅读计划: http://www.gnu.org/manual/manual.html\n","tags":["TODO"]},{"title":"北漂三年","url":"/2020/08/25/北漂三年/","content":"\n在学业和工作上，我自认为做的并不比别人差。唯独在生活上，我应该连及格都困难。","tags":["EMOTION"]},{"title":"计算机的时间观念","url":"/2020/08/10/计算机的时间观念/","content":"\n1. L1缓存: 0.5ns\n2. L2缓存: 7ns\n3. 加解锁: 25ns\n4. 内存寻址: 100ns\n5. CPU上下文切换: 1500ns\n6. 1Gbps网络上传递2k的数据:  20us\n7. SSD随机读取1MB的数据: 150us\n8. 内存中读取1MB的连续数据: 250us\n9. 同一个数据中心网络上跑一个来回: 0.5ms\n10. SSD读取1MB的顺序数据: 1ms\n11. 磁盘寻址时间: 10ms\n12. 从磁盘读取1MB的连续数据: 20ms","tags":["TECH"]},{"title":"内嵌汇编","url":"/2020/07/25/内嵌汇编/","content":"\n__asm__ __violate__ (\"movl %1,%0\" : \"=r\" (result) : \"m\" (input) : \"ebx\");\n\n1. =r 指明返回的结果：最后会将eax中的内容拷贝到result变量中\n2. m： 指明输入的内容来自内存，从input变量中拷贝\n3. %1, %0: 指明参数的顺序： 这样指令展开的时候会成： movl (input分配的寄存器) (result分配的寄存器) \n4. ebx 破坏描述部分，显式的说明会破坏哪些寄存器的值\n\n\n2020/08/02:\nx64架构下，gas汇编器push/pop只能操作16bit或64bit的寄存器，对应的指令为: push/pushq\nref: https://stackoverflow.com/questions/21679131/error-invalid-instruction-suffix-for-push","tags":["OS"]},{"title":"leetcode-cn-377","url":"/2020/07/02/leetcode-cn-377/","content":"```\nclass Solution {\nprivate:\n  map<int, int> m;\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n      unsigned int re[target+1];\n      for (int i=0; i<=target; i++) re[i] = 0;\n      int cur = 0;\n      while (cur ++ < target) {\n        bool found = false;\n        for (auto elem: nums) {\n          if (elem <= cur) {\n            re[cur] += re[cur-elem];\n            if (elem == cur) found = true;\n          }\n        }\n        if (found) re[cur]++;\n      }\n      return re[target];\n    }\n};\n\n```\n\n坑很深的一道题：\n1. 一开始的时候没有细想，直接上搜索：\n  search(nums, begin, target-nums[begin], count);\n  search(nums, begin+1, target-nums[begin], count);\n  search(nums, begin+1, target, count);\n发现超时了，调试了一番，发现这种方法即使在target很小的时候，时间复杂度也十分惊人，可见是不可取的方法；\n2. 想到对1中方法进行优化：利用map记录已经搜索出结果的中间过程。试验一番发现仍然不行，时间复杂度还是太高\n3. 在网上搜索了别人的思路，发现正确做法是用dp，并且是自底向上的dp\n4. 确实是一道好题：你以为我在第一层，其实我在第四层","tags":["leetcode"]},{"title":"数据库范式","url":"/2020/06/29/数据库范式/","content":"\n1. 1NF: 最基本的数据库形式，要求每一列都是不同的，不存在相同的列，数据项不可分割。现在的RDB已经不可能创建出不符合1NF的表了\n2. 2NF：每个表格的每一行需要有至少一个可以唯一标识这一行的字段，通常我们会把这个字段称为码。因此2NF要求表必须要有码，码确定的情况下其他字段都可以确定\n3. 3NF：每个表格的每一行中的所有字段，都只依赖于码，不依赖于其他任何字段。每个表格中的属性，既不部分依赖于码，也不传递依赖于码\n4. BCNF：码与码之间不能有依赖关系\n","tags":["Tech"]},{"title":"回溯搜索全排列","url":"/2020/06/29/回溯搜索全排列/","content":"\n- 非常典型的一道搜索题 (leetcode 46)\n- 对于数组nums, 每次递归划分一个搜索范围，每次找这个范围的最后一个元素elem，将这个元素elem插入到已有搜索结果tmpRe的不通位置，再进行下一轮的搜索递归\n\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<int> > &re, vector<int> & nums, int end, vector<int> tmpRe){\n        if (end<0){\n            re.push_back(tmpRe);\n            return;\n        }\n        int elem = nums[end];\n        for (int i=0; i<=tmpRe.size(); i++){\n            vector<int> newTmpRe = tmpRe;\n            newTmpRe.insert(newTmpRe.begin()+i, elem);\n            dfs(re, nums, end-1, newTmpRe);\n        }\n    }\n    \n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int> > re;\n        vector<int> tmpRe;\n        dfs(re, nums, nums.size()-1, tmpRe);\n        return re;\n    }\n};\n```\n\n- 另：此题的标准解法应当是使用回溯法解。\n- 在上面的解法中，使用了一个很tricky的思想，及每次试探一个nums中的元素，我们都是从后面一个向前面一个试探。并且我们是向tmpRe的不同位置去插入这个元素。回溯的想法是，我每次都从nums中挑选一个，并且固定的加在tmpRe的最末尾。但是这样，我们每次都是去便利nums中的每一个元素，这就意味着有可能有元素被重复的挑选。比如nums = [1,2,3]，那这样的算出的结果中可能会出现[1,1,1]这样的数组。这时，我们可以额外使用一个used数组去记录，某一个位置i上的数是否已经被挑选到tmpRe中了。\n- 回溯的大致解法如下：\n```\n\nclass Solution {\npublic:\n    void dfs(vector<vector<int>> &re, vector<int> &nums, vector<int> &tmpRe, int* used){\n        if (tmpRe.size() == nums.size()){\n            re.push_back(tmpRe);\n            return;\n        }\n\n\n        for (int i=0; i<nums.size(); i++){\n            if (used[i])\n                continue;\n            tmpRe.push_back(nums[i]);   //每次都添加到tmpRe的末尾\n            used[i] = 1;\n            dfs(re, nums, tmpRe, used);\n            tmpRe.pop_back();    //回溯，对此次的选择反悔。这样此刻的这个nums[i]会在新的tmpRe末尾，相当于换了个位置\n            used[i] = 0;\n        }\n    }\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> re;\n        vector<int> tmpRe;\n        int used[nums.size()+1];\n        for (int i=0; i<nums.size()+1; i++)\n            used[i] = 0;\n        dfs(re, nums, tmpRe, used);\n        return re;\n    }\n};\n\n\n```\n","tags":["leetcode"]},{"title":"回溯搜索目标和数字组合","url":"/2020/06/29/回溯搜索目标和数字组合/","content":"- 非常标准的搜索+回溯 (leetcode 39)\n```\n\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> data;\n    vector<vector<int>> re;\n    void dfs(int target, int start, vector<int>& output){\n        if (target < 0) return;\n        if (target == 0) {\n            vector<int> tmp = output;\n            sort(tmp.begin(), tmp.end());\n            re.push_back(tmp);\n            return;\n        }\n\n        for (int i=start; i<data.size(); i++){\n            output.push_back(data[i]);\n            dfs(target-data[i], i, output);\n            output.pop_back();\n        }\n    }\n    static int cmp(int &a, int &b){\n        if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        data = candidates;\n        sort(data.begin(), data.end(), Solution::cmp); //here!!\n        vector<int> output; \n        dfs(target, 0, output);\n        return re;\n    }\n};\n```\n\n- 有意思的是，如果在开始dfs之前，先排序一把，能极大提高效率:-)","tags":["leetcode"]},{"title":"回溯搜索回文串","url":"/2020/06/29/回溯搜索回文串/","content":"\nleetcode 131\n- 字符串s, 假定前面的[0, a)都已经搜索过了，那么下面的[a, s.size())部分可以用这个策略：\n```\ni从[a, s.size())：\n- 假如s.substr(a, i-a+1)不是回文串，i++继续寻找下一个；\n- 假如s.substr(a, i-a+1)是回文串，可以将s.substr(a, i-a+1)推入我们的临时搜索结果集中，然后递归搜索剩下的；但是有个问题，i的后面就没有其他的字串s.substr(a, k-a+1)是回文串了吗?\n  所以，在将s.substr(a, i-a+1)推入搜索结果集中，并调用递归进行剩下的搜索之后，还需要把s.substr(a, i-a+1)从临时结果集中弹出，让i++继续，寻找当前临时结果集下其他的可能回文串。\n  故：\n  \n  void search(vector<vector<string>> &re, vector<string> tmpRe, string &s, int a, int b){\n      if (a >= b){\n          re.push_back(tmpRe);\n          return;\n      }\n      for (int i=a; i<=b; i++){\n          if (isPalindrome(s.substr(a, i-a+1))){\n              tmpRe.push_back(s.substr(a, i-a+1));\n              search(re, tmpRe, s, i+1, b);\n              tmpRe.pop_back();   // 这一步就是所谓的回溯\n          }\n      }\n  }\n```\n","tags":["leetcode"]},{"title":"阶乘中末尾连续0的个数","url":"/2020/06/29/阶乘中末尾连续0的个数/","content":"- 寻找一个数的阶乘中，末尾位数中连续的0的个数 (leetcode 39)\n- 目前的思路：将任意一个合数进行质因数分解，分解集中的5的个数，就是此数能够贡献的0的数量；\n    而对于一个质数，可以直接略过，因为它不可能贡献出0（当然除了5本身）；\n$$\n    C=2^{k_1}*3^{k_2}*5^{k_3}*7^{k_4}...\n$$\n- 对于阶乘，\n$$\nn! = 1*2*3*4*5*...*n\n$$\n每一个乘数都需要做质因数分解并计算分解集中5出现的次数。\n```\nclass Solution {\npublic:\n    int rawTrailingZeroes(int a, int b){\n        if (b - a < 5){\n            int count = 0;\n            for (int i=a; i<=b; i++){\n                int j = i;\n                while (!(j%5)){\n                    count++;\n                    j = j/5;\n                }\n            }\n            return count;\n        }\n\n        return rawTrailingZeroes(a, (a+b)/2)+rawTrailingZeroes((a+b)/2+1, b);\n    }\n    int trailingZeroes(int n) {\n        return rawTrailingZeroes(1, n);\n    }\n};\n    \n```\n\n- 提交，发现运行超时\n\n-------------------------------------------------------------\n\n\n- 设`$f(n)$`为n的阶乘中末尾0的数量，则有：\n    `$f(n) = n/5 + f(n/5)$`\n\n- 数学归纳法证明：\n    1. 对于`$n<5$`, 显然有`$f(n) = n/5 + f(n/5) = 0$`成立；\n    2. 假设对于`$n>5$`，有`$f(n) = n/5 + f(n/5)$`成立，则对于另一个数`$m$`,有：\n        - 若`$m(m\\in[n+1, n*5-1])$`，根据质因数分解公式，`$n \\to m$`中的任意数，都不会有新的质因数5出现。\n        - 若`$m=n*5$`,根据质因数分解公式，相对于`$n$`,`$m$`出现了新的质因数5，因此有`$f(m) = 1+f(n) = m/5+f(m/5)$`。\n    3. 综上，`$f(n) = n/5 + f(n/5)$` 成立。\n\n","tags":["leetcode"]},{"title":"leetcode-cn-376","url":"/2020/06/28/dp求子序列最大长度/","content":"leetcode 376\n```\nclass Solution {\npublic:\n  int wiggleMaxLength(vector<int>& nums) {\n    if (nums.size() <= 0) return 0;\n    int len = nums.size();\n    if (len == 1) return 1;\n    int up = 1; int down = 1;\n    for (int i=1; i<nums.size(); i++) {\n      if (nums[i] > nums[i-1]) {\n        up = down + 1;\n      }\n\n      if (nums[i] < nums[i-1]) {\n        down = up + 1;\n      }\n    }\n\n    return max(up, down);\n  }\n};\n```\n求摆动子序列的最大长度\n有点类似于脑筋急转弯：假如a[i]-a[i-1]的结果用/和\\来表示大于0和小于0，那么，就相当于求一个.../\\/\\/\\/序列和.../\\/\\/\\序列的最大长度\n用变量up表示.../\\/\\/\\/序列在遍历过程中的长度，down表示.../\\/\\/\\序列在遍历过程中的长度\n由于已经到i了，在i处时/还是\\是明确的（nums[i]-nums[i-1]就知道了）：\n1. 若在i处是/: 则在i处是以/结尾，即匹配.../\\/\\/\\/序列, 其长度up=down+1; \n2. 若在i处是\\: 则在i处是以\\结尾，即匹配.../\\/\\/\\序列，其长度down=up+1;","tags":["leetcode"]},{"title":"JS原型链","url":"/2020/06/27/JS原型链/","content":"const foo = new Foo();\n```\n1. foo.__proto__ === Foo.prototype\n2. Foo.prototype.constructor === Foo\n3. Foo.prototype === Foo.prototype // 左边指的是Foo这一对象(也是一个函数)的一个属性，右边指的是一个具体的对象，即‘Foo的原型对象’\n4. Foo.__proto__ === Function.prototype // 右边指的是JS内置对象Function的原型对象\n5. Foo === new Function('函数的定义语句字符串');\n6. Function.prototype.construction === Function\n7. Function.prototype === Function.prototype\n8. Function.__proto__ === Function.prototype // 所以函数的__proto__属性都指向Function.prototype，包括Function自己\n9. 对象Object.prototype.constructor === 函数Object()\n10. 函数Object().prototype === Object.prototype\n11. 函数Object().__proto__ === Function.prototype\n12. Function.prototype.__proto__ === Object.prototype\n13. Foo.prototype.__proto__ === Object.prototype\n14. Object.prototype.__proto__ === null\n\n```\n![js原型链](./js-prototype-link.png)","tags":["Tech"]},{"title":"TLS-Handshake","url":"/2020/06/24/TLS-Handshake/","content":"\n```mermaid\nsequenceDiagram\n  客户端 ->>  服务端 : 客户端生成一个随机数(r1)，加上自己支持的加密方式，将这二者发给服务端\n  服务端 ->> 客户端: 服务端收到客户端的随机数(r1)后，自己生成一个随机数(r2)，然后将r2和服务端证书发给客户端\n  客户端 ->> 服务端: 客户端新生成一个随机数(r3，又被称为预主密钥),将r3用步骤二中从证书里获取到的公钥加密，发给服务端\n```\n之后，服务端就可以用私钥解出r3。服务端和客户端都可以用商量好的加密方式，通过加密(r1, r2, r3)得到会话密钥。","tags":["Tech"]},{"title":"HighPerformanceMysql notes","url":"/2020/06/04/HighPerformanceMysql-notes/","content":"\n- [「完全的范式化和反范式化schema都是实验室里才有的东西」](#完全的范式化和反范式化schema都是实验室里才有的东西)\n- [「影子表」](#影子表)\n- [数据类型选型:](#数据类型选型)\n- [B-Tree索引](#b-tree索引)\n- [哈希索引](#哈希索引)\n- [空间数据索引(R-Tree)](#空间数据索引r-tree)\n- [全文索引](#全文索引)\n- [前缀索引](#前缀索引)\n- [聚簇索引](#聚簇索引)\n- [覆盖索引](#覆盖索引)\n- [慢查询](#慢查询)\n- [一些常见的优化招式](#一些常见的优化招式)\n- [案例1](#案例1)\n# 「完全的范式化和反范式化schema都是实验室里才有的东西」\n\n> 范式化的优点:\n  - 范式化的更新操作通常比反范式化要快\n  - 当数据较好地范式化时，就只有很少或者没有常负数据，所以值需要修改更少的数据\n  - 范式化的表通常更小，可以更好地放在内存里，所以执行更快\n  - 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP语句\n\n> 范式化的缺点\n\n  - 通常范式化需要大量的表关联，稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联\n\n> 反范式化的优点: \n    - 可以很好地避免关联\n    - 可以设计更好的索引策略\n\n# 「影子表」\n```\ndrop table if exists my_summary_new, my_summary_old;\ncreate table my_summary_new like my_summary;\nrename table my_summary to my_summary_old, my_summary_new to my_summary;\n```\n\n# 数据类型选型:\n\n  - 使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能的避免使用NULL值\n  - 尽量使用相同的数据类型存储相似霍相关的值，尤其是要在关联条件中使用的列\n  - 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存\n  - 小心使用ENUM和SET，不能滥用。最好避免使用BIT\n   \n# B-Tree索引\n\n> -  一般讨论索引的时候，都是指B树索引\n> -  InnoDB使用的是B+树\n> -  B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据\n> -  B-Tree适用于一下类型的查找: 全键值、键值范围、键值前缀(指适用于最左前缀匹配)\n> -  索引树中的所有节点都是有序的，所以也适用于order by排序操作\n   \n# 哈希索引\n\n> - 哈希索引指包含哈希指和行指针，而不存储字段值\n> - \n> - 哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序\n> - \n> - 哈希索引也不支持部分索引列匹配查找\n> - \n> - 哈希索引值支持等值比较查询，包括=, IN(), <=>，不支持任何范围查询\n> - \n> - 如果哈希冲突很多，一些索引的维护操作的代价高\n> - \n> - 可以在业务层手动为一些字段设置哈希函数，实现\"伪哈希索引\"\n\n\n# 空间数据索引(R-Tree)\n\n> MyISAM的特性，用于存储地理信息数据(3维GIS)，提供了一系列内置函数\n\n# 全文索引\n\n> 待后文详解\n\n# 前缀索引\n```\nalter table sakila.city_demo add key (city(7))\n```\n> 无法做group by和order by\n\n# 聚簇索引\n\n> 聚簇索引描述的是一种索引的存储结构。InnoDB中的聚簇索引是在同一个结构中保存B树的索引和数据行，所以所以结构和数据存放在同一个文件中。\n\n> 优势:\n\n  - 减少磁盘IO\n  - 数据访问更快\n> 缺点:\n\n  - 如果数据全部放在了内存中，则聚簇索引就没有什么意义了\n  - \n  - 数据插入的速度严重依赖于插入顺序\n  - \n  - 更新聚簇索引列的代价搞\n  - \n  - 页分裂问题\n  - \n# 覆盖索引\n\n> 案例\n```\nselect * from products where actor='SEAN CARRY' and title like '%APOLLO%';\n```\n# 慢查询\n\n> 典型的负面案例\n\n  - 查询不需要的attributes\n  - 表关联时返回全部attributes\n  - select *\n  - where中包含in 子查询: select * from tableA where tableA.fid in (select id from tableB where name='xxx');\n> mysql使用where的3种方式(以下从好到坏列出)\n  - 在索引中用where，过滤不匹配的行。在存储引擎中完成\n  - 使用索引覆盖扫描(explain extra: using index)，在mysql服务层完成，无需回表查询\n  - 从数据表中返回数据，然后过滤不满足条件的行，explain extra: using where，在mysql服务层完成，需要回表查询\n> 重构查询\n\n  - 复杂查询拆分成几步，可在业务代码中完成\n  - 利用循环，采用类似于分页的方式分批查询\n  - 分解关联查询\n> 关联查询的原理\n\n  - 所有的关联动作都是先生成一个临时表，然后通过嵌套查询的方式遍历。简单来说，如果A, B, C3表关联查询，3表分别有x, y, z行数据，则关联的复杂度为x * y * z;\n\n> 关联查询优化\n\n  - 所有的查询，mysql都会预先生成一个查询计划。查询计划是有很多个的，mysql会自己选择查询计划中看起来代价最小的那个\n\n  - 多表关联查询的查询计划，通常都是一棵左侧深度优先的树\n  - mysql的关联查询优化器会通过调整关联顺序尝试自己选择合适的查询计划: 当n个表关联时，会去尝试n!(n的阶乘)种排列方式。显然，n不能太大\n\n> 排序优化\n\n  - 数据量小的时候，mysql会在内存排序，数据量大了，就是在磁盘排序了。但在explain extra中看到的都是filesort\n\n  - mysql使用「快排」在内存中进行排序; 当在磁盘时，使用快排分段排序，再merge回磁盘\n\n> 查询的执行\n\n  - mysql的执行计划是一个数据结构\n  - 通过调用存储引擎的「handler API」完成。\n  - 查询优化器的一些提示关键字(hint): 用来指示查询优化器如何按照我们定制化的方案执行。类似于gcc的内置宏\n\n# 一些常见的优化招式\n\n> 优化count()\n\n  - count()既可以统计行数，也可以统计某个列值的数量。统计列值的时候mysql会计算列值不为空的数量。如果mysql确认count()括号里的内容不可能为空，此时统计的其实就是行数\n  - 所以如果要统计行数，请直接使用count(*)\n  - count(*)会扫描所有行，这是不可避免的，如果有必要，可以新增一张汇总表来解决\n> 优化关联查询\n\n  - 尽量让on或者using的字段有索引\n  - 确保group by和order by里的表达式只涉及到一个表中的列\n> 优化子查询\n\n  - 尽量用关联查询代替\n\n> 优化group by和distinct\n\n  - 使用索引来优化，这是最有效的办法\n\n  - A left join B ，最好只对A中的列做group by\n\n> 优化limit + offset + order by的分页方法\n\n  - 尽可能使用索引覆盖扫描。利用表关联，先通过覆盖索引找出id， 再做一次关联查询查询行的其他信息\n```\nselect film_id, description from sakila.film order by title limit to 50, 5\n建议改成:\nselect film.film_id, film.description\nfrom sakila.film\n\tinner join (\n  \tselect film_id from sakila.film\n    order by title limit 50, 5\n  ) as lim using(film_id)\n```\n  - 利用书签记录一下上次翻页的位置，然后利用>, <, between 加上索引的方式，可以减少无用的扫描次数\n\n> 使用用户自定义sql变量来优化\n\n  - 自定义变量在整个查询连接过程中都存在\n  - 使用了自定义变量的查询，无法使用查询缓存\n\n> 优化select for update\n表格式\n```\ncreate table unsent_emails (id int not null primary key auto_increament, status enum('unsent', 'claimed', 'sent')\n                  owner int unsigned not null default 0, ts timestamp, key (owner, status, ts)\n                )\n```\n常规的用法:\n```\nbegin;\nselect id from unsent_emails\n  where owner=0 and status='unsent'\n  limit 10 for update;\n-- result: 123, 456, 789\nupdate unsent_emails\n  set status='claimed', owner=connection_id(),\n  where id in(123, 456, 789)\n```\n改进的用法:\n```\nset autocommit=1;\ncommit;\nupdate unsent_emails\n  set status='claimed', owner=connection_id()\n  where owner=0 and status='unsent'\n  limit 10;\nset autocommit=0;\nselect id from unsent_emails\n  where owner=connection_id() and status='claimed';\n-- result 123,456,789 \n```\n\n______\n\n# 案例1\n翻页问题:  mysql可以使用limit m,n的方式支持翻页。但是在实现上，mysql查找第m条记录需要将前m条记录都扫一遍。因此当m比较大的时候，效率低。\n解决方法:\n1. 借助自增ID，定位m的值，较少扫描的行数。例如，limit m,n 的时候，我们可以改成 where id>m order by id ASC limit n; 效果提升明显\n2. 借助索引。具体想法是先找出limit m,n的id(id自带索引)，然后inner join整条记录:\n```\nselect * from TableA inner join (select id from TableA limit m,n) as TableB using(id);\n```\n\n"},{"title":"Questions","url":"/2020/05/20/Questions/","content":"\n### 1. Base64最长可以编码多长的数据而保证信息不丢失?\n"},{"title":"一些数论的基础知识","url":"/2019/12/29/一些数论的基础知识/","content":"\n1. 欧拉公式\n$$\nif \\ \\ \\  gcd(a, n) = 1, then \\ \\ a^{\\phi(n)} \\equiv 1 mod n\n$$\n\n2. 欧拉降幂法则\n`$ if \\ \\ gcd(a, n)=1 \\Rightarrow \\ a^b  \\equiv a^{b \\% \\phi(n)} mod n $`\n`$ if \\ \\ gcd(a, n)\\neq 1,  b<\\phi(n) \\Rightarrow a^b \\equiv a^b mod n $`\n`$ if \\ \\ gcd(a, n) \\neq 1, b \\ge \\phi(n) \\Rightarrow a^b \\equiv a^{b\\%\\phi(n)+\\phi(p)} mod n $`\n\n2. RSA加密\n    - 取大素数p, q\n    - 取数字e、d, 使得： `$ (e*d) \\% \\phi(p*q) = 1 $`. 由欧拉公式得，只要满足`$ gcd(e*d, p*q)=1 $`即可\n    - 制成公钥：(p*q, e), 私钥(p*q, d)。\n    - 明文M,用公钥加密成密文S, 过程为： `$ S=M^e \\% (p*q) $`\n    - 解密过程：`$ M=S^d \\% (p*q) $`. 因为`$ gcd(M, (p*q)) = 1 $`, 所以`$ S=M^e \\% (p*q) = M^{e*d} \\% (p*q) $`\n        由欧拉定理: `$ M^{\\phi(p*q)} \\% (p*q) = 1 $`, 而`$ (e*d) \\% \\phi(p*q) = 1 $`, 有： `$ M^{e*d-1} \\% (p*q) = 1 $`;\n        从而`$ M^{e*d} \\% (p*q) = M $`;                                    ","tags":["math"]},{"title":"SOSP2019-CrashTuner","url":"/2019/12/05/SOSP2019-CrashTuner/","content":"\n## CrashTunner: Detecting Crash-Recovery Bugs in Cloud Systems via Meta-Info Analysis\n","tags":["tech"]},{"title":"尝试electorn","url":"/2019/11/05/尝试electorn/","content":"\n## 安装依赖\n建议适用electron-builder进行打包\n需要配置taobao源\n```\nELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/\n```","tags":["tech"]},{"title":"vim代码索引与补全","url":"/2019/10/16/vim代码索引与补全/","content":"## 目标\n实现C/C++/Objective-C, js/ts的代码索引、自动补全。\n使用LSP。YCM、Ctags之类的软件太古老了。\n关于LSP: Language Server Protocol.\n\n## 需要的插件\n> Vundle.vim : 插件管理\n> nerdtree\n> roxma/vim-hug-neovim-rpc: 为vim8补全一些特性，像neoVim看齐。\n> roxma/nvim-yarp: 同上\n> autozimu/LanguageClient-neovim: neoVim的language client插件。vim8下需要上面两个插件支持\n> Shougo/deoplete.nvim: neoVim的代码补全插件\n> Shougo/neosnippet.vim: code snippet插件\n> Shougo/neosnippet-snippets: 同上\n> \n\n## language server\n> C/C++:  [ccls](https://github.com/MaskRay/ccls)\n  - install on macOS: brew install ccls\n  - js/ts: [javascript-typescript-langserer](https://github.com/sourcegraph/javascript-typescript-langserver)\n    - install on macOS: npm install -g javascript-typescript-langserver\n\n## 步骤\n\n#### 1. 安装Vundle: git repo: https://github.com/VundleVim/Vundle.\n```\ngit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim\n```\n    \n编辑.vimrc如下\n\n#### 2. .vimrc\n里面加了一些私货，请酌情参考\n```\nsyntax on\nmap <C-n> :NERDTreeToggle <CR>\nset nocompatible \" be iMproved, required\nfiletype off \" required\nset encoding=utf-8\n\n\" set the runtime path to include Vundle and initialize\nset rtp+=~/.config/nvim/bundle/Vundle.vim\ncall vundle#begin()            \" required\nPlugin 'VundleVim/Vundle.vim'  \" required\nPlugin 'git://github.com/scrooloose/nerdtree.git'\nPlugin 'https://github.com/Shougo/deoplete.nvim.git'\nPlugin 'https://github.com/autozimu/LanguageClient-neovim.git'\nPlugin 'git@github.com:vim-scripts/taglist.vim.git'\nPlugin 'scrooloose/syntastic'\n\" ===================\n\" my plugins here\n\" ===================\n\n\" Plugin 'dracula/vim'\n\n\n\" ===================\n\" end of plugins\n\" ===================\ncall vundle#end()               \" required\nfiletype plugin indent on       \" required\n\n\" Brief help\n\" :PluginList - lists configured plugins\n\" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate\n\" :PluginSearch foo - searches for foo; append `!` to refresh local cache\n\" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal\n\"\n\" see :h vundle for more details or wiki for FAQ\n\" Put your non-Plugin stuff after this line\n\"\n\"\nlet g:python3_host_prog = \"/usr/local/bin/python3\"\nlet g:python2_host_prog = \"/usr/local/bin/python2\"\n\n\" setup javascript/typescript language server\nlet g:LanguageClient_loadSettings = 1\nlet g:LanguageClient_settingsPath = '/Users/zivyou/.config/nvim/settings.json'\nlet g:LanguageClient_autoStart = 1\n\n\n\nlet g:LanguageClient_serverCommands = {\n    \\ 'javascript': ['javascript-typescript-stdio'],\n   \\ }\n\nif executable('javascript-typescript-stdio')\n  let g:LanguageClient_serverCommands.javascript = ['javascript-typescript-stdio']\n  \" Use LanguageServer for omnifunc completion\n  autocmd FileType javascript setlocal omnifunc=LanguageClient#complete\n  \n  \"let g:LanguageClient_serverCommands.typescript = ['javascript-typescript-stdio']\n  \"autocmd FileType typescript setlocal omnifunc=LanguageClient#complete\n\nelse\n  echo \"javascript-typescript-stdio not installed!\\n\"\n  :cq\nendif\n\n\" Register ccls C++ lanuage server.\n\"\"if executable('ccls')\n\"\"   au User lsp_setup call lsp#register_server({\n\"\"      \\ 'name': 'ccls',\n\"\"      \\ 'cmd': {server_info->['ccls']},\n\"\"      \\ 'root_uri': {server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), 'compile_commands.json'))},\n\"\"      \\ 'initialization_options': {'cache': {'directory': '/tmp/ccls/cache' }},\n\"\"      \\ 'whitelist': ['c', 'cpp', 'objc', 'objcpp', 'cc'],\n\"\"      \\ })\n\"\"endif\n\n\ncall deoplete#custom#option('sources', {\n            \\ 'vim': ['vim'],\n            \\ 'zsh': ['zsh']\n            \\})\n\n\n\" setup deoplete\nlet g:deoplete#enable_at_startup = 1\n\n\n\" setup eslint\"\nlet g:syntastic_javascript_checkers = ['eslint']\n\n\nnnoremap <C-n> :NERDTreeToggle <CR>\nnnoremap <C-l> :tabn <CR>\nnnoremap <C-h> :tabp <CR>\nnnoremap <F8> :TlistToggle <CR>\nnnoremap <C-f> :!find . -type f -name \"*.h\" -o -name \"*.cpp\" -o -name \"*.c\" -o -name \"*.cc\" -o -name \"*.hpp\" \\| xargs grep -r <cword>\n\n\" 生成cscope的索引\nnnoremap <C-c-t> :!find . -name \"*.c\" -o -name \"*.cpp\" -o -name \"*.h\" -o -name \"*.cc\" -o -name \"*.hpp\" > FileList.txt; cat FileList.txt \\| xargs ctags -a ; cscope -bkq -i FileList.txt;\nif has(\"cscope\")\n  set csto=0\n  set nocsverb\n  if filereadable(\"cscope.out\")\n    cscope add cscope.out\n  endif\n  set csverb\nendif\n\n\" Settings for cscope:\nnnoremap ,c :cs find c <C-R>=expand(\"<cword>\")<CR><CR>\nnnoremap ,s :cs find s <C-R>=expand(\"<cword>\")<CR><CR>\nnnoremap ,g :cs find g <C-R>=expand(\"<cword>\")<CR><CR>\nnnoremap ,t :cs find t <C-R>=expand(\"<cword>\")<CR><CR>\nnnoremap ,t :cs find e <C-R>=expand(\"<cword>\")<CR><CR>\nnnoremap ,f :cs find f <C-R>=expand(\"<cword>\")<CR><CR>\nnnoremap ,i :cs find c <C-R>^=expand(\"<cword>\")$<CR><CR>\nnnoremap ,d :cs find d <C-R>=expand(\"<cword>\")<CR><CR>\nnnoremap <C-r> :!\nnnoremap <C-c-s> :cs find \n\n\" LanguageClient-nvim key bindings\nnnoremap ;d :call LanguageClient#textDocument_definition()<cr>\nnnoremap ;r :call LanguageClient#textDocument_references({'includeDeclaration': v:false})<cr>\nnnoremap ;h :call LanguageClient#textDocument_hover()<cr>\n\" caller\nnnoremap ;c :call LanguageClient#findLocations({'method':'$ccls/call'})<cr>\n\nset showmatch\ncolor desert\n\"set background=dark\n\"colorscheme solarized\nset expandtab\nset ts=2\nset shiftwidth=2\nset hlsearch\nset backspace=indent,eol,start\ninoremap ' ''<ESC>i\ninoremap \" \"\"<ESC>i\ninoremap ( ()<ESC>i\ninoremap [ []<ESC>i\ninoremap { {}<ESC>i\ninoremap <C-b> <left>\ninoremap <C-n> <down>\ninoremap <C-p> <up>\ninoremap <C-f> <right>\ninoremap <C-e> <end>\ninoremap <C-a> <home>\n```\n\n#### 3. 装插件\n    - :PluginInstall\n\n#### 4. 使用\n    - ccls\n    ccls在做代码索引的时候，需要针对不同的项目做不同的预处理。主要是生成JSON Compliation Database.\n    ```\n    cmake -H. -BDebug -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=YES\n    ln -s Debug/compile_commands.json\n    ```\n","tags":["tech"]},{"title":"weechat指南","url":"/2019/10/08/weechat指南/","content":"\n## 常用命令 格式: /$cmd\n1. /help $cmd: 查看命令的手册\n2. /server add freenode8001 chat.freenode.net/8001  : 添加freenode:8001，并取名freenode8001\n3. /connect freenode8001 username:mypassword: 使用用户名username连接到freenode:8001\n4. /list -re open*: 查看以open开头的聊天室(支持正则)\n5. /join #channel: 进入名为channel的channel\n6. /close: close a server\n7. /nick username: 使用昵称username\n8. /msg NickServ identify ****: 输入用户名、密码，以空格相隔(相当于登录)\n9. Ctrl+n: switch between buffer\n10. Ctrl+x: switch between topic\n11. /part \"a message\" : leave a channel\n12. /Option+l: 纯显示聊天内容\n13. Ctrl+r: 历史命令搜索\n14. /window scroll 10/-10: buffer上下翻页\n\n\n## 设定\n1. /set irc.server_default.nicks \"nick1, nick2\" :设定默认的登录昵称\n2. /set\n3. 利用Alt+k来设定快捷键: /key bind (press Alt+k to get keys) (press your keys composite) /window scroll 1\n","tags":["tech"]},{"title":"Hello World","url":"/2019/08/20/hello-world/","content":"\n换了新主题[polarbear](https://github.com/frostfan/hexo-theme-polarbear)，貌似是出自一位国人之手。感叹他人的优秀，以及自己的平庸。\n"},{"title":"找工作与找对象","url":"/2019/08/20/找工作与找对象/","content":"\n别误会，这并不是一篇记录个人生活的文章。相反，我会尝试理性、客观、学术地去分析和理解这个问题。\n","tags":["thought"]},{"title":"梦付千秋星垂野","url":"/2019/08/11/梦付千秋星垂野/","content":"\n![所谓伊人 在水一方](baimengze.jpg)\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=3&id=2058065556&auto=1&height=66\"></iframe>\n\n![魔之骸](mozhihai.jpg)\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=3&id=2058071045&auto=1&height=66\"></iframe>"},{"title":"《斯通纳》","url":"/2019/07/23/《斯通纳》/","content":"\n六月与七月，我突然有了大把的空闲时间。然而即便是这么奢侈的赏赐，经历过短暂的兴奋之后也会变的很无聊甚至是焦虑。我尝试去做一些改变，其中之一就是读完了这本摆在床头很久的《斯通纳》。\n\n斯通纳是这部同名小说主角的名字。该怎么描述这样一个人物呢？书中细腻地描述了他的一生，但那些感同身受的故事经历实在没有一件说的上是不凡。他出生于一个贫苦的美国农民家庭。父母勤恳而努力，然而唯一能做的有远见事情就是让斯通纳去城里上中学。他学习刻苦努力，然而大学里唯一让他感觉有天赋和潜力的是大家都不待见的古典文学。在婚姻面前，他勇敢而笃定，坚定地向出生高贵的伊迪丝表白求婚，然而可笑的是这份婚姻最光辉的时候就是他们被安排去渡蜜月的那段尴尬的不堪回首的时间。面对无法自拔的感情，他也有勇气去摒弃世人的眼光，甚至想过要去承担责任，然而这却差点使他身败名裂，也搭进去他的后半段职业生涯。对于工作，他有能力也有热情去做好，然而命运却玩弄似的给他安排了一个无法化解的冤家对头。\n\n这一切都使得这本书读起来异常沉重。作者把这些痛苦和不幸一股脑地摆在了这个黑瘦、沉默而又倔强的男人面前，但是文字的描写又是如此的细腻，让这些痛苦显得如此的真实和压抑。\n\n斯通纳的故事是有一个历史背景的。他步入大学时，一战的阴影正笼罩着世界，他从密苏里大学毕业不久，美国就正式宣布加入一战。那些蔓延着的忐忑、迷茫和不明所以的痛苦，让即便是在象牙塔一般的密苏里大学里的人们都变的癫狂。我们的斯通纳也在经历着痛苦，只是于其他人不同，他无暇去观察和思考这个外部世界究竟在发生什么，对国家和个人会有多大影响。他的痛苦来纯粹自于对前途的迷茫命运的无可奈何。\n\n这些问题其实一直都存在，只是隐藏的很深。它们隐藏在斯通纳父母管理的农场那贫瘠的土地里，隐藏在他栖身了4年的福特姨妈家的储藏室中，隐藏在他穿了整整四年的破旧不堪的大衣中。斯通纳被沉重的生活压的喘不过气来，更别说抬起头来面对这些问题了。\n\n浑浑噩噩的日子终于迎来了改变，两个人几乎在同一时间左右了斯通纳的未来生活。第一个是斯通纳的古典文学老师斯隆教授，尽管这位老先生古板、严肃、不近人情，斯通纳还是在他的课上感受到了古典文学中记录的那另一个世界的美丽。他在课上的被莎士比亚的十四行诗所吸引，一时神游而被斯隆先生敏锐的察觉，也许就是这个细小的经历，斯隆坚定的认为斯通纳会是一名出色的古典文学老师。\n\n当然，斯通纳一开始并没有那么的认真地考虑斯隆的建议。他还远远没有到有把控自己前途的意识的阶段。这件事一直搁着，直到斯通纳听到马斯特斯那番真实而露骨的讲话。严格的来说，马斯特斯并不算是斯通纳多好的好友。他们相聚的时候大多是周五去哥伦比亚下城区的酒吧喝啤酒。那个时候的美国还没有禁酒令，密苏里大学里的年轻人大都靠着这种简单粗暴的消遣发泄着对世界的不满。马斯特斯大概算得上是老牌酒友了。在一个平常的星期五，斯通纳、费奇和马斯特斯再次来到酒吧喝酒，这次他们聊起了之前从来没有聊过的严肃话题。\n```\n他从店里提供的免费餐食中高高举起一只煮的有些过老的鸡蛋，好像举着一只晶体球，说道：“诸位先生可曾考虑过这所大学的真正本质吗？”\n```\n斯通纳笑着摇摇头。他肯定是没有想过的。对他而言，能够从那困苦的生活中解脱出来，来到密苏里大学这样一个安静而美好的环境中学习和工作，已经是他能想到的最贪婪的目标了。斯通纳的这点小心思被马斯特斯毫不留情地说穿，他只能别扭而尴尬地微笑着。\n\n在接着一口气点破费奇的小心思之后，马斯特斯用满不在乎和戏谑的口吻说出了他自己的想法。\n```\n马斯特斯把剩下的鸡蛋放进嘴里，津津有味地嚼了一会儿，又美美地喝了口啤酒。“可是你们都错了，”他说，“大学就想一所庇护所，或者--他们现在怎么称呼来着？--是给那些体弱、年迈、不满以及失去竞争力的人提供的休养所。看看我们三个人--我们就是这个大学。陌生人不知道，我们又这么多共同点，可是我们心里明白，不是吗？我们非常清楚。”\n```\n\n斯通纳大概不会知道，这段话就像是给他的人生立下的一个批注，他的一生再也没有离开过密苏里大学。\n\n博士毕业之后，斯通纳最终还是留在了密苏里大学，成为了一名古典文学讲师。这并不完完全全出自他的本愿，不过已经不重要了，对于斯通纳而言，他的确没有更好的选择。\n\n大学老师这个职业，意味着稳定的生活，安静而秩序的氛围。尽管每年都会有一批有一批的新同学走进斯通纳的课堂，他们会努力地沉下心去听斯通纳讲一讲那些古老诗文中的学问。这样的时间过的很快，不过对于斯通纳而言，唯一的变化可能就是备课的讲义会不时的换一换。\n\n似乎斯通纳的下半生已经大致有个轮廓了，事实上也的确如此。当然，书中他下半生的故事还有三个于他而言非常重要的女人: 他的妻子伊迪丝、女儿格蕾丝，还有他的情人凯瑟琳。\n\n斯通纳下半生的悲剧是从认识伊迪丝开始的。那时一战终于结束，密苏里大学组织了一个宴会欢迎复原的老职工重返教工队伍。就是在那个宴会上，斯通纳第一次见到了伊迪丝。也许是伊迪丝的高挑、漂亮和优雅吸引了斯通纳，他竟然鼓起了勇气主动去认识伊迪丝。虽然已经二十多岁的年纪，可能是因为良好的家庭教养和太少接触社会，伊迪丝并不知道如何去拒绝这样的接触。她腼腆、别扭地接受了斯通纳去她家拜访的请求。之后的故事，斯通纳并没有像其他小说的主角那样有四处散发的魅力，让他足以获得这个女孩的芳心。但是这个悲剧故事的开端，确确实实是伊迪丝在不情愿地接受斯通纳的求婚后开始的。\n\n也许是对当时美国社会的背景了解不够，我挺难理解伊迪丝以及她的父母为何会同意这样的一桩婚姻。伊迪丝的父亲有一家私人银行，家境优渥。伊迪丝对其他人\n\n# 这本书我大概是不想再看第二遍了。","tags":["thought"]},{"title":"超大碗鸡汤","url":"/2019/07/21/超大碗鸡汤/","content":"\n很多年以前，还在上大学的时候，有一回课上老师播放了一部电影：《当幸福来敲门》。那是一节类似于思想政治或者就业指导类的课程，记得影片放完，老师神情激动，慷慨激昂，试图用一番美妙的演讲激起我们对于美好前程的向往和斗志。我在台下感觉茫然失措，我知道在那样一个年纪，风华正茂、斗志昂扬才应该是主旋律。但是遗憾的是我真的没有从影片或者老师的演讲中受到任何的鼓舞，我的潜意识中应该是饱含着质疑和困惑的。\n\n若干年以后的今天，我在B站上又看到有人在推这部影片，心中不禁哑然失笑。只是过了这么多年，我渐渐明白了为什么自己会对影片有所质疑和困惑。\n\n《当幸福来敲门》上映于2006年，讲述的是一个由真实事件改编而来的故事。一位濒临破产、老婆离家的落魄业务员，刻苦耐劳，善尽单亲责任，奋发向上成为股市交易员，最后成为知名的金融投资家。故事的背景设在1981年的旧金山，那时的美国处于著名的经济滞涨时期，经济极度低迷，全国失业率高达40%。导演很鸡贼的在影片中避开了所有这些背景描述。所有的镜头故事都是聚焦在主角克里斯的日常点滴生活中。所以，你能清晰的感受到从开篇开始，克里斯的生活一步步陷入困顿，在这种困顿中，克里斯顽强奋斗，同时有尽其所能的爱护着自己的儿子，最终找到一份完美的工作，走向人生巅峰。\n\n故事很老套，表达的理念也很好懂：只要你努力拼搏，就能过上美好的生活。\n\n可是这个道理，在我刚刚懂事的时候，我的父母就曾灌输给我了呀。\n\n巧的是，美国人民也同样会将这个道理灌输给他们的孩子，只是他们的说法更加高大上一些：他们称之为“美国梦”。\n\n这样一个精神内核，实在是一大碗不折不扣的鸡汤。\n\n经历过互联网对“鸡汤文”的批判洗礼之后，现在的年轻人对于鸡汤的辨别能力和抵制能力比我们那时实在强了不少。还记得高中那会传阅最广的几本书中就有《心灵鸡汤》、《羊皮卷》这些鸡汤圣典。在后来求学的过程中，自己越来越认识到理性思维和批判思维的重要性，也慢慢开始尝试分析鸡汤的毒害原理。\n\n鸡汤存在的问题主要有两点：1. 虚假的故事。作者为了支撑其夸张的论点，想尽办法捏造一个精美的故事。某种程度上，这种做法与诈骗差不多。2. 只关注论点，不研究方法，所有的案例都没有可行性。其中惯用的伎俩就是以极端情况代替对事物的认识。\n\n鸡汤对于青少年的伤害是巨大的。在我还没有学会理性思维的那些年里，我有很长一段时间生活在漫无目的的盲目乐观中。对于自己所处的困境，对于自己欠缺的见识、能力、金钱等，我虽然有一个模糊的认识，但心里总想着会好起来的。但要真有一天想起来要去改变，却根本拿不出一个可行的方案。长此以往的这种思维困境，让自己在不知不觉中沉沦，最终成为一个庸人。\n\n回到这个故事本身，深入一点去思考，会发现它也是经不起推敲的。首先，导演的手法很高明，为角色量身定做的很多故事细节很打动人。但是理性的讲，主角所经历的真的有多惨多绝望吗？一个中年男人的失业悲剧，引发的妻离子散，这种故事就算放到现今的帝都，也是不断在上演着的。对于我个人而言，就更谈不上多么绝望了。我所经历过的黑暗，怕是喝再多鸡汤都冲不淡了。另外，故事的最后，为什么主角找了一份好工作，就走向人生巅峰了呢？这同样很可笑，相当于在帝都找了2个月工作，拿到一份大公司offer之后就从一个社会底层跃升成人生赢家。\n\n但是电影毕竟是电影，导演选择这样一个故事，必定是有其考虑的。我想尝试从一些其他的角度揣测一番。\n\n故事的背景设定在1981年，当时的美国仍处在经济滞涨时期，异常的通货膨胀率和失业率同时发生，使得美国政府进退两难，普通民众的生活也异常艰难。但是在80年代初里根总统上台之后，一系列的经济调整政策开始扭转局面。在1983年，美国终于迎来了新一轮的经济发展巅峰，之后就是美国经济发展的黄金20年。所以电影中主角的人生境遇，固然与其自身的努力息息相关，但是脱离如此有利的社会大背景，片面地将所有成就归功于其自身的努力，实在是有点不厚道。\n\n有意思的是，这部影片拍摄于2006年，当时美国的次贷危机蠢蠢欲动，金融危机一触即发，社会矛盾也积累到了一个新的波峰。导演在这个时候拍摄这样一部美国“主旋律”电影，还是有点耐人寻味的。\n\n再有，美国梦作为一个支撑了美国社会200余年的信条，必然不是一碗鸡汤这么简单。而美国历史上践行这一信念的人物也数不胜数。只是，这个信念大概现在只有在美国才有可行性。因为美国的财富来源于全世界，你可以努力成为一个资本家，吸取世界上其他人民的财富，最终走向人生巅峰。\n\n再往下讲，怕就是政治问题了，就此打住吧。","tags":["thought"]},{"title":"六月杂记","url":"/2019/07/08/六月杂记/","content":"\n五月底莫名其妙就被失业了，仓促的一个电话会议，就宣告了我们的下岗，美帝国主义的工厂果然不靠谱。\n\n说实话我对这份工作也并不是十分满意，结果倒好，公司帮我仁至义尽的一把，简直又好气又好笑。\n\n这直接导致了这个无所事事的六月的开始。\n\n盘算一下，回家过端午节花去了一周多的时间。回到北京后，除了找工作，大部分时间都在无聊中度过。\n\n一旦闲下来，自己就会被漫无目的的思绪给扰乱。各种关于生存和生活的问题，从世界观到价值观，从性格到人际关系，全都想理顺一遍。每天晚上都觉得自己理顺了，却在第二天睁开眼的时候推翻自己昨晚的结论。\n\n大概这就是所谓的不成熟吧（sigh）。\n\n\nanyway, 六月已经过去了。\n\n","tags":["emotion"]},{"title":"beijing","url":"/2019/06/17/beijing/","content":"\n北京是一个很古怪的城市。老实说，初来北京的时候，对这个地方的印象是很不具体的。这些印象也许来源于早年读过的文字，也许来源于别人口中荒诞的故事，甚至是电视上或者互联网中的画面。\n生活了一段时间以后，这些模糊的印象才开始慢慢具象化，只是这个过程并不是一个温柔的方式让你体验到的。\n我习惯不把北京当作一个整体看待。这是一个不同片区间泾渭分明、社会严重割裂的城市。你可以认为它鱼龙混杂，也可以认为它五彩斑斓。\n\n","tags":["emotion"]},{"title":"n-queens-problem","url":"/2018/11/15/n-queens-problem/","content":"\n## n-皇后：搜索，回溯与剪枝"},{"title":"gdbNotes","url":"/2018/11/01/gdbNotes/","content":"\n- start:\n- https://stackoverflow.com/questions/11408041/how-to-debug-the-linux-kernel-with-gdb-and-qemu\n    qemu-system-i386  -s -monitor stdio -fda floppy.img -boot a\n    -s for a gdbserver\n\n- ensure that lo eth are up\n- gdb toyos_kernel\n    - input \"target remote localhost:1234\" in gdb command line\n    - port 1234 is the default debug port for qemu\n    - monitor exit: to exit a connection\n- check register in gdb:\n    - info all-register: list all registers \n    - x/4ubh $eax\n        - x for examine, 4ub for 4 unsigned bytes, h for hexadecimal. $eax is the register\n- check stack in gdb:\n    - x/10x $sp\n        - print front 10*4 bytes of the stack\n"},{"title":"DrunkardProblem","url":"/2018/10/24/DrunkardProblem/","content":"\n-----------\n\n### 酒鬼问题，频率派概率与贝叶斯\n\nDota2贴吧莫名奇妙开展了一场数学大讨论，源于这道题：\n\n```\n已知某酒鬼有90%的日子都会出去喝酒，喝酒只去固定三家酒吧（注：三家酒吧去的频率一样），今天警察找了其中两家\n酒吧都没有找到酒鬼。请问：酒鬼在第三家酒吧的概率是多少？\n```\n\n问题被抛出之后，贴吧围观群众越来越多，在一番激烈的唇枪舌剑之后，吧友的结果基本分成了两种：90%与75%。\n90%党的思路是：题目给定酒鬼90%的概率回出去喝酒，而警察检查了前两家，没有发现酒鬼。则只要酒鬼出去喝酒，必定在第三家。酒鬼出去喝酒的概率为90%，故在第三家酒馆的概率为90%。\n\n75%党使用贝叶斯公式一本正经的推算，得出结论：75%。\n\n当然，最后进过多方认证，正确答案敲定为75%。\n\n有个最直观的思路：\n![solution](solution.jpg)\n","tags":["Math"]}]