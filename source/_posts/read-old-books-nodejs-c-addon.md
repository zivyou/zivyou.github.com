---
title: read-old-books-nodejs-c++-addon
date: 2021-11-06 19:22:38
tags: books
---

# V8基础

## 内存机制
### 内存管理基本原理
V8有自己的堆内存区域，并且有自己的堆管理策略。简单来说，V8将堆内存分成了下面几种区域：
- 新生代内存区： 基本的数据对象都会被分配到这里，其特点是小而频繁。区域小但是垃圾回收频繁；
  新生代内存使用Scavenge算法进行回收：将新生代空间分成两部分，一部分为From，一部分为To。分配时总是从From空间中预留空间。在遇到GC时，V8会将From空间中存活的对象复制到To空间中，剩下的不存活的对象会被直接释放。完成后交换From和To的角色。
- 老生代指针区：指向老生代内存区具体数据内容的指针会被存在这里。从新生代蜕变过来的对象的指针会被放在这里；
  老生代使用Mark-Sweep和Mark-Compact结合的机制进行垃圾回收。Mark-Sweep即标记删除法：先遍历老生代中的对象，将已经死亡的对象标记，之后统一进行清除。
  在使用标记清除法进行操作的时候，很容易产生内存碎片问题。Mark-Compact就是一种改进后的方案，可以堆内存碎片进行整理。即先标记，然后在统一进行清除的时候，让活着的对象尽可能的向内存区域的头部进行对齐。
- 老生代数据区：存放数据对象，而不是指向其他对象的指针。老生代指针区的指针就往这边指。
- 大对象区：这里存放体积超越其他区大小的对象，每个对象都有自己的内存，垃圾回收机制并不会移动大对象；
- 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。这是唯一拥有执行权限的区域； 
- Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单；
## 隔离实例(Isolate)
一个引擎的实例称为一个isolate。可以理解为是V8引擎的一个实例，拥有完全独立的各种状态、堆管理、垃圾回收等等。
在一个实例中生成的对象无法在另一个实例中使用。
## 句柄
句柄提供了对V8的堆内存的中JavaScript数据对象的一个引用。简单来说，句柄是一种包装过的指针，这种指针可以被V8的垃圾回收引擎识别，然后进行生命周期管理。
句柄有多种类型：
- 本地句柄：v8::Local; 本地句柄存在于栈中，在对应的析构函数被调用的时候会销毁内存。其生命周期由其所在的句柄作用域决定。可以通过成员函数As()/Cast()进行强制类型转换。
- 持久句柄：v8::Presistent；比较复杂，分为弱持久句柄（PresistentBase::SetWeak）、唯一持久句柄（v8::UniquePersistent<>）和一般持久句柄（v8::Persistent<>）;
- 永生句柄：v8::Eternal; 永生句柄在整个程序的生命周期内都不会被删除，也就是说不会进行垃圾回收。
下面就是几种常见的句柄：
```
v8::Local<v8::Number>
v8::Persistent<v8::String>
```
## 句柄作用域（Handle Scope）
存在于栈空间中，是一个维护一堆句柄的容器。当一个句柄作用域被析构时，其容器内的所有句柄都会被析构。句柄作用域一个类似于栈帧的逻辑组织和使用。
## 上下文
上下文是V8中JavaScript代码的执行环境。各个上下文是独立存在并且允许存在多个。即使在同一个隔离实例中，不同的上下文也是不想干的，可以执行各自的JavaScript代码。
在V8中，可以通过vm模块创建沙箱来执行一段JavaScript代码。也就是说，借助vm模块，可以自己定制上下文实例。
## 模版
在某个上下文中，创建JavaScript对象或者函数的一个原型。
- 函数模版（FunctionTemplate）。可以通过函数模版的GetFunction()方法来获取其具体函数实例的句柄。这样获取的具体函数实例是可以被JavaScript代码直接识别和使用的。
  函数模版的使用时候有一种特殊的情况，就是你设置了一个函数模版的实例，然后想让这个实例在JavaScript的世界中成为某一个类的构造函数。这是一个挺复杂的事情。在函数模版实例中，可以调用成员方法SetClassName()来设定‘当前函数为构造函数的情况下，new出来的对象是哪一个类的’。
- 对象模版（ObjectTemplate）：对象模版用于在运行时创建对象。由于JavaScript的面向对象使用的是原型对象的模式，因此在对象模版中添加的属性，也会被创建出来的对象实例所继承。
我们回顾一下JavaScript的原型链：
1. 每个对象实例都有一个__proto__属性指向自己的原型对象；
2. 所有的函数都有一个prototype属性，指向自己的原型对象。这个原型对象就是以该函数作为构造函数new出来的对象的原型；
3. 函数也是一个对象，所以也有__proto__属性。特别的，所有函数的__proto__属性都指向Function.prototype，因为所有的函数看成对象的会都是由Function（）作为构造函数构造出来的对象。
## 数据类型
## 异常机制
