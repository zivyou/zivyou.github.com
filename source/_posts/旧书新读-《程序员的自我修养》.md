---
title: '旧书新读:《程序员的自我修养》'
date: 2021-08-01 11:08:04
tags: books
---
- [编译与链接](#编译与链接)
  - [编译过程](#编译过程)
    - [预处理](#预处理)
    - [编译](#编译)
    - [汇编](#汇编)
    - [链接](#链接)
  - [编译器前端](#编译器前端)
    - [词法分析](#词法分析)
    - [语法分析](#语法分析)
    - [中间代码生成](#中间代码生成)
  - [编译器后端](#编译器后端)
    - [代码生成](#代码生成)
    - [目标代码优化](#目标代码优化)
- [目标文件格式](#目标文件格式)
  - [格式](#格式)
  - [分析工具](#分析工具)
    - [.text section](#text-section)
    - [.data section / .rodata section](#data-section--rodata-section)
    - [.bss section](#bss-section)
    - [自定义section](#自定义section)
  - [ELF文件格式](#elf文件格式)
    - [文件头（File header）](#文件头file-header)
    - [section表(section header table)](#section表section-header-table)
    - [重定位表(Relocation Table)](#重定位表relocation-table)
    - [字符串表](#字符串表)
  - [符号](#符号)
    - [符号表结构](#符号表结构)
    - [特殊符号](#特殊符号)
    - [符号修饰和函数签名](#符号修饰和函数签名)
    - [extern "C"](#extern-c)
- [静态链接过程](#静态链接过程)
  - [空间与地址分配](#空间与地址分配)
    - [空间占用与分配](#空间占用与分配)
    - [相似段合并](#相似段合并)
    - [两步链接法](#两步链接法)
    - [链接命令](#链接命令)
    - [链接后的地址变化](#链接后的地址变化)
    - [符号地址的确定](#符号地址的确定)
  - [符号解析与重定位](#符号解析与重定位)
    - [重定位](#重定位)
    - [重定位表](#重定位表)
    - [符号的解析](#符号的解析)
    - [指令的修正方式](#指令的修正方式)
  - [链接过程控制](#链接过程控制)
    - [链接器控制脚本](#链接器控制脚本)
    - [查看默认的链接器脚本](#查看默认的链接器脚本)
    - [最小的程序](#最小的程序)
    - [链接器脚本编写](#链接器脚本编写)
    - [链接器脚本语法](#链接器脚本语法)
    - [BFD库](#bfd库)
  

# 编译与链接

## 编译过程
C程序的编译过程： 
C源码文件: hello.c  --预处理器(cpp命令)--> hello.i --编译(gcc命令)--> hello.s --汇编(as命令)--> hello.o --链接(ld命令)--> a.out

### 预处理
使用cpp命令执行源码的预处理，预处理阶段主要做以下事情：
 - 宏展开，替换所有的#define宏
 - 处理预编译命令，比如: #if, #ifdef, #elif, #else, #endif
 - 递归展开#include
 - 删除所有注释
 - 添加行号和文件名标识: #2 "hello.c" 2
 - 保留#pragma

### 编译
这里的编译指的是狭义上的编译，主要做的是编译器前端的工作。使用gcc命令执行编译，主要做的事情：
 - 词法分析
 - 语法分析
 - 语义分析
 - 生成汇编代码及优化
这个阶段是广义的编译过程中最复杂的阶段。

### 汇编
比较简单，调用命令as对生成的汇编代码进行翻译，生成对应的机器指令即可。

### 链接
调用ld命令将汇编阶段生成的obj文件组装成一个可执行文件。这个过程略有一点复杂，下文重点讲这个内容。

## 编译器前端

### 词法分析
步骤：
1. 通过扫描器(Scanner)将源代码读入
2. 通过有限状态机(Finite State Machine)将字符串分割成一系列记号(Token)
可以识别出的记号一般包括这几种： 关键字、标识符、字面量、特殊符号（如加号，等号等）。在识别符号的同时也会做好分类，如将标识符放到符号表，将数字、字符串放到文字表等。
可用的词法分析工具： lex, GNU的Flex等。

### 语法分析
目标是将上面词法分析过程产生的记号生成一个语法树(Syntax Tree， 也会被称作AST: Abstract Syntax Tree)。使用上下文无关语法（Context-free Grammar）推理自动机。语法树是以表达式（Expression）为节点的树。
可选的语法分析工具包括： yacc(Yet Another Compiler Compiler), GNU的Bison, Antlr, JavaCC等。

### 中间代码生成
语法分析阶段生成的AST没法做优化，因此源代码优化器常常会将AST转换成中间代码(Intermediate Code， 也会被称作‘中间表达形式(Intermediate Representation)’)。它实际上是AST的一个线性展开，将语法树展开成顺序的表达形式。一般IC已经比较接近目标代码了，但目前为止和目标机器的运行时环境还是无关的，因为它不包含数据的尺寸、变量的地址、寄存器的名字等等。
中间代码有多种类型，比较常见的有：
 - 三地址码(Three-address code): 三地址码的表达式形式： x = y op z
  举个例子，表达式'2*a+(b-3)'用3地址码会翻译成下面这样：
  T1 = 2 * a;
  T2 = b - 3
  T3 = t1 + t2
 - P代码（P-Code）: 用来生成那些具有逻辑栈结构的机器（也被称为P-Machine，通常我们会在P机器上写解释器）。生成的P代码一般都是用来直接解释执行的，所以在P代码中会包含运行时环境的一些隐式描述。
  P机器由以下元素构成： 代码内存，有名变量的数据内存，栈，寄存器（抽象的）。
  举个例子：  还是表达式'2*a+(b-3)'用P代码会翻译成下面这样
  ```
  ldc 2    ; 加载常量2
  lod a    ; 加载变量a的值
  mpi      ; 整数乘法操作
  lod b    ; 加载变量b的值
  ldc 3    ; 加载常量3
  sbi      ; 整数减法
  adi      ; 整数加法
  ```

## 编译器后端

### 代码生成
代码生成器（Code Generator）将中间代码转换成目标机器代码。这个过程的具体内容依赖于目标机器，因为不同的机器有不同的字长、寄存器、整数数据类型和浮点数据类型等等。
我们以一个全新的例子来看。
假设有一段C代码： array[index] = (index + 4) * (2 + 6)
那么会生成中间代码（假设是三地址码）如下：
```
t1 = 2 + 6
t2 = index + 4
t3 = t2 * t1
array[index] = t3
```
中间代码优化后会得到：
```
t2 = index + 4
t2 = t2 * 8
array[index] = t2
```

那么，上面优化后的三地址码在代码生成阶段会生成下面的目标代码：
```
movl index, %ecx       ; 将index的值赋值给ecx
addl $4, %ecx          ; ecx的值加4
mull $8, %ecx          ; ecx的值乘以8
movl index, %eax       ; 将index的值赋值给eax
movl %ecx, array(, eax, 4) ; array[index] = ecx
```

### 目标代码优化
得到了上面的目标代码之后，目标代码优化器（Target Code Optimizer）还会对生成的目标代码进一步优化。主要的优化手段包括：
- 选择合适的寻址方式
- 使用位运算替代乘法运算
- 删除多余的指令
等等。
上面的例子，在优化之后，目标代码会变成：
```
movl index, %edx
leal 32(, %edx, 8), %eax
movl %eax, array(, %edx, 4)
```

至此，狭义的编译器的工作就全部完成了。

##　链接器
链接器的主要任务是各个目标文件中相互引用的部分处理好，使得各个目标文件可以正确衔接。主要包括以下几个过程：
- 地址和空间分配（Address and Storage Allocation）
- 符号决议（Symbol Resolution），也被称为 符号绑定（Symbol Binding）、名称绑定(Name Binding)、名称决议(Name Resolution)、地址绑定（Address Binding）、指令绑定（Instruction Binding）等等。
- 重定位（Relocation）

# 目标文件格式
Windows平台的可执行文件格式为PE格式（Portable Executable），Linux下的为ELF格式（Executable Linkable Format）。这两者都是COFF(Common File Format)格式的变种。
我们上面提到的‘目标文件’指的是编译完成后但是没有开始链接的那些中间文件，Windows下为.obj后缀，Linux下为.o后缀。
目标文件和可执行文件的内容和结构相似，所以一般和可执行文件采取相同的格式存储。(其实.dll文件，.so文件，.lib, .a文件还有.core文件也是按这个格式存储的)

## 格式
目标文件中内容有那些？ 答： 有机器指令代码、数据、符号表、调试信息、字符串等。
目标文件会将这些信息按照不同的属性，以section为单位进行存储。比如，编译后的机器指令放在.code或者.text section；全局变量和局部静态变量放在.data section中 等等。
目标文件还有一个‘文件头（File Header）’，它描述了整个文件的文件属性，比如文件是否可执行、是静态链接还是动态链接、如果是可执行文件，那入口地址是多少、目标硬件是什么、目标操作系统是什么等等。文件头中还有一个section表（section table），它是一个描述文件中各个section的数组，记录了文件中各个section在文件中的偏移位置及sectoin的属性等。

## 分析工具
objdump -h工具可以将文件的各个section的基本信息打印出来。
示例代码:
```
int printf(const char* format, ...);

int global_int_var = 84;
int global_uninit_var;

void func1(int i) {
        print("%d, \n", i);
}

int main(void) {
        static int static_var = 85;
        static int static_var2;
        int a = 1;
        int b;
        func1(static_var + static_var2 + a + b);
        return a;
}
```
gcc -o hello.o -c hello.c 编译之后得到hello.o。使用objdump -h得到：
```
hello.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000005f  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000008  0000000000000000  0000000000000000  000000a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  0000000000000000  0000000000000000  000000a8  2**2
                  ALLOC
  3 .rodata       00000006  0000000000000000  0000000000000000  000000a8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .comment      0000002b  0000000000000000  0000000000000000  000000ae  2**0
                  CONTENTS, READONLY
  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d9  2**0
                  CONTENTS, READONLY
  6 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000e0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .eh_frame     00000058  0000000000000000  0000000000000000  00000100  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```
上述输出中，section有多个必选属性： idx, 名字，大小，VMA，LMA，文件内偏移File Offset, 对齐方式Align。第二行的contents, allocation, load, relocation, readonly, code等标识section的一些可选属性。
下面依次看这些section。

### .text section
objdump -s 可以以十六进制打印，-d可进行反汇编，于是： objdump -s -d hello.o 有：
```
hello.o:     file format elf64-x86-64

Contents of section .text:
 0000 f30f1efa 554889e5 4883ec10 897dfc8b  ....UH..H....}..
 0010 45fc89c6 488d3d00 000000b8 00000000  E...H.=.........
 0020 e8000000 0090c9c3 f30f1efa 554889e5  ............UH..
 0030 4883ec10 c745f801 0000008b 15000000  H....E..........
 0040 008b0500 00000001 c28b45f8 01c28b45  ..........E....E
 0050 fc01d089 c7e80000 00008b45 f8c9c3    ...........E... 
Contents of section .data:
 0000 54000000 55000000                    T...U...        
Contents of section .rodata:
 0000 25642c20 0a00                        %d, ..          
Contents of section .comment:
 0000 00474343 3a202855 62756e74 7520392e  .GCC: (Ubuntu 9.
 0010 332e302d 31377562 756e7475 317e3230  3.0-17ubuntu1~20
 0020 2e303429 20392e33 2e3000             .04) 9.3.0.     
Contents of section .note.gnu.property:
 0000 04000000 10000000 05000000 474e5500  ............GNU.
 0010 020000c0 04000000 03000000 00000000  ................
Contents of section .eh_frame:
 0000 14000000 00000000 017a5200 01781001  .........zR..x..
 0010 1b0c0708 90010000 1c000000 1c000000  ................
 0020 00000000 28000000 00450e10 8602430d  ....(....E....C.
 0030 065f0c07 08000000 1c000000 3c000000  ._..........<...
 0040 00000000 37000000 00450e10 8602430d  ....7....E....C.
 0050 066e0c07 08000000                    .n......        

Disassembly of section .text:

0000000000000000 <func1>:
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   89 7d fc                mov    %edi,-0x4(%rbp)
   f:   8b 45 fc                mov    -0x4(%rbp),%eax
  12:   89 c6                   mov    %eax,%esi
  14:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 1b <func1+0x1b>
  1b:   b8 00 00 00 00          mov    $0x0,%eax
  20:   e8 00 00 00 00          callq  25 <func1+0x25>
  25:   90                      nop
  26:   c9                      leaveq 
  27:   c3                      retq   

0000000000000028 <main>:
  28:   f3 0f 1e fa             endbr64 
  2c:   55                      push   %rbp
  2d:   48 89 e5                mov    %rsp,%rbp
  30:   48 83 ec 10             sub    $0x10,%rsp
  34:   c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%rbp)
  3b:   8b 15 00 00 00 00       mov    0x0(%rip),%edx        # 41 <main+0x19>
  41:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 47 <main+0x1f>
  47:   01 c2                   add    %eax,%edx
  49:   8b 45 f8                mov    -0x8(%rbp),%eax
  4c:   01 c2                   add    %eax,%edx
  4e:   8b 45 fc                mov    -0x4(%rbp),%eax
  51:   01 d0                   add    %edx,%eax
  53:   89 c7                   mov    %eax,%edi
  55:   e8 00 00 00 00          callq  5a <main+0x32>
  5a:   8b 45 f8                mov    -0x8(%rbp),%eax
  5d:   c9                      leaveq 
  5e:   c3                      retq  
```
'Contents of section .text'部分就是用十六进制将.text section的内容打印出来。

### .data section / .rodata section
.data section存储已经初始化的全局静态变量和局部静态变量。.rodata section存放只读数据，如字符串字面量、使用了const修饰的只读变量等。

### .bss section
.bss存放未初始化的全局变量和未初始化的局部静态变量，比如示例中的global_uninit_var和static_var2就存在.bss section中。

### 自定义section
1. 将二进制数据拷贝到目标文件中： objcopy -I binary -O elf64-x86-64 -B i386 image.jpg hello.o
2. 在C语言中显式地指定变量的section:
   ```
   __attribute__((setion("FOO")) int global = 42;
   __attribute__((section("BAR"))) void foo() {}
   ```


## ELF文件格式

### 文件头（File header）
方法： 使用readelf命令来查看elf文件： readelf -h hello.o
```
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00                  // EFL魔数
  Class:                             ELF64                                  // 机器的字长
  Data:                              2's complement, little endian          // 数据存储方式
  Version:                           1 (current)                            // 版本
  OS/ABI:                            UNIX - System V                        // 运行平台
  ABI Version:                       0                                      // ABI版本
  Type:                              REL (Relocatable file)                 // ELF重定位类型
  Machine:                           Advanced Micro Devices X86-64          // 硬件平台
  Version:                           0x1                                    // 硬件平台版本
  Entry point address:               0x0                                    // 入口地址
  Start of program headers:          0 (bytes into file)                    // 程序头入口和长度
  Start of section headers:          1184 (bytes into file)                 // section表的位置和长度
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         14                                     // section的数量
  Section header string table index: 13
```


### section表(section header table)
保存各个section的基本属性信息，比如section名字、长度、在文件中的偏移、读写权限等等。
获取section表的信息：  readelf -S hello.o
```
There are 14 section headers, starting at offset 0x4a0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       000000000000005f  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  00000380
       0000000000000078  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  000000a0
       0000000000000008  0000000000000000  WA       0     0     4
  [ 4] .bss              NOBITS           0000000000000000  000000a8
       0000000000000004  0000000000000000  WA       0     0     4
  [ 5] .rodata           PROGBITS         0000000000000000  000000a8
       0000000000000006  0000000000000000   A       0     0     1
  [ 6] .comment          PROGBITS         0000000000000000  000000ae
       000000000000002b  0000000000000001  MS       0     0     1
  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000d9
       0000000000000000  0000000000000000           0     0     1
  [ 8] .note.gnu.propert NOTE             0000000000000000  000000e0
       0000000000000020  0000000000000000   A       0     0     8
  [ 9] .eh_frame         PROGBITS         0000000000000000  00000100
       0000000000000058  0000000000000000   A       0     0     8
  [10] .rela.eh_frame    RELA             0000000000000000  000003f8
       0000000000000030  0000000000000018   I      11     9     8
  [11] .symtab           SYMTAB           0000000000000000  00000158
       00000000000001b0  0000000000000018          12    12     8
  [12] .strtab           STRTAB           0000000000000000  00000308
       0000000000000072  0000000000000000           0     0     1
  [13] .shstrtab         STRTAB           0000000000000000  00000428
       0000000000000074  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
```
这里面，需要关注一下的是section的类型，即Type这个属性。由于section的名字可以自定义，我们的系统是通过section的Type来确认这个section是干嘛用的。另外，Flags这个属性指示了这个section在进程虚拟地址空间中的属性，比如是否可写、是否可执行等等。Link和Info两个属性指示了该section如何进行链接，具体的组合有点复杂，这里略去。

### 重定位表(Relocation Table)
.rela.text这个section的Type属性是RELA，说明这个section是一个重定位表（Relocation Table）。这个section指示了链接器需要对那些内容进行怎样的重定位。需要说明的是，.rela.text这个section是针对.text section中那些需要重定位的内容设置的，同理，如果需要对.data section进行重定位，那么也会有一个.rela.data section来提供这些信息。

### 字符串表
上面例子中的.strtab和.shstrtab section就是字符串表，用来存储普通的字符串。

## 符号
函数和变量都是符号。链接的过程就是让引用符号的人找到符号定义的地址的过程。
每个目标文件都会有一个符号表（Symbol Table），用来记录目标文件需要使用到的符号。每个符号都有一个对应的值，叫做符号值（Symbol Value）。对于函数和变量来说，符号值就是它们的地址。
除了函数和变量，还有其他种类的符号，它们分别是：
 - 定义在本目标文件中的全局符号，可以被其他目标文件引用。比如示例中的func1, main, global_init_var
 - 在本目标文件中引用的全局符号，但是却没有在本目标文件中定义，这种称为外部符号。比如示例中的printf
 - section名字，由编译器产生，它的值就是该section的起始地址。比如.text, .data
 - 局部符号，这种符号只能一个编译单元内部看到。比如static_var, static_var2。局部符号在链接过程是不可见的，链接器会直接忽略它们。
 - 行号信息，目标文件中的指令预源代码中的行号的对应信息
  
链接器最关心是上面的第一种和第二种符号。

### 符号表结构
符号表就是上面例子中的.symtab section。它的内容也是一个数组，数组中的每个元素包含以下几个关键信息： 
- 符号类型和绑定信息（st_info）:说明是不是外部的、弱引用的，同时还说明该符号是个啥类型
- 符号所在section(st_shndx): 如果符号是在本目标文件中定义，那这个字段会指示其所在的是那个section。如果不是，那该字段会是几个特殊的值。
- 符号值（st_value）: 对于变量和函数，就是它们的地址。

可以通过readelf -s hello.o来看目标文件中的符号。
```
Symbol table '.symtab' contains 18 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1922
     7: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 static_var2.1923
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 
    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 
    12: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_int_var
    13: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var
    14: 0000000000000000    40 FUNC    GLOBAL DEFAULT    1 func1
    15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND print
    17: 0000000000000028    55 FUNC    GLOBAL DEFAULT    1 main
```

### 特殊符号
有很多由链接器ld为我们内置的符号，我们甚至可以直接在代码中引用它们。
- __executable_start: 程序的起始地址，不是入口地址，是指程序的最开始的地址
- __etext: .text section的结束地址
- _edata: .data section的结束地址
- _end/end: 程序的结束地址
上面的这些地址都是在程序状态完成之后，操作系统为我们分配的虚拟地址。

### 符号修饰和函数签名
简单来说，为了避免我们自己写的函数名、变量名和系统中内置的库中的函数名、变量名重复，编译器会在编译的时候给我们自定义的符号名修饰一下。
C++的修饰方法：
1. 函数签名： 函数签名包括了它的函数名、参数类型、所在的类、命令空间等等信息。
   举个几个例子：
   - int func(int) -> _Z4funci
   - float func(float) -> _Z4funcf
   - int C::func(int) -> _ZN1C4funcEi
   - int C::C2::func(int) -> _ZN1C2C24funcEi
   - int N::func(int) -> _ZN1N4funcEi
   - int N::C::func(int) -> _ZN1N1C4funcEi
   这个修饰的规律是： C++的修饰风格都以_Z打头，对于嵌套的名字；后面会加一个N，然后接命令空间或者类的名字，这里的名字前面的数字是指这个名字的长度；最后会以E结尾。参数列表会紧跟在E的后面。
   有个工具叫c++filt可以帮我们翻译被修饰过的名字。

### extern "C"
这个语句是C++中用来声明和C兼容的语句的时候使用的。在使用了这个语句的大括号内的语句，C++编译器不会启动符号修饰机制。


# 静态链接过程
代码片段A：
```
extern int shared;
int main() {
     int a = 100;
     swap(&a, &shared);
}
```
编译： gcc -c a.c -fno-stack-protector -o a.o

代码片段B：
```
int shared = 1;
void swap (int *a, int * b) {
     *a ^= *b ^= *a ^= *b;
}
```
编译： gcc -c b.c -fno-stack-protector -o b.o

## 空间与地址分配

### 空间占用与分配
在上文中，我们提到.text section和.data section，它们的空间占用很好理解： 它们中都存储了具体的内容，这些内容需要多少空间来存储，对应就有多少空间被占用。
但是对于.bss section，它自身是没有包含内容的，它的空间占用如何理解？
.bss section本身在obj文件和最终的输出文件中，都是不占用空间的，因为未初始化的数据，都是以0表示。为了节省，obj文件和输出文件都会用一句话描述'这里有多少个0'来描述.bss section，而不会实际去存那么多个0.
但是，当最终输出的可执行文件装载并执行的时候，运行时的.bss section是会去申请内存空间的，并且有多少个0就会申请多少字节的空间。运行时申请的空间是虚拟地址空间。为了统一，下文在描述‘空间分配’问题时，都是只关注虚拟地址空间的分配。因此，在讨论空间分配问题的时候，.bss section也是需要考虑的。

### 相似段合并
上述A片段在编译之后的obj文件中会有.text, .data, .bss等section； 同样的，B片编译后产生的obj文件中也会有.text, .data, .bss等section。如何将A.obj和B.obj一起存放到输出文件中？这个是链接器需要解决的问题。
现代链接器通常都会采用‘相似段合并’的策略，即A.obj中的.text section与B.obj中的.text section合并成为输出文件中的.text section。同样的，.data section和.bss section也会有这样一个相似段合并的过程。

### 两步链接法
采用了相似段合并的链接器，一般会采用一种‘两步链接法’：
1. 分配空间与地址： 
   - 扫描所有输入文件，获取它们各个section的长度、属性和位置
   - 获取所有输入文件中的符号表中的符号定义和符号引用，并统一放到一个全局符号表中
   - 计算出输出文件中各个section所需的长度和对应的位置，并将记录输入文件中的各个section的映射关系

2. 符号解析和重定位：
   - 读取输入文件中section中的数据和重定位信息
   - 进行符号解析、重定位、调整地址

### 链接命令
ld a.o b.o -e main -o ab

其中，-e声明了入口函数的名字， “-o ab”声明了输出文件的名字

### 链接后的地址变化
a.o: 通过objdump -h a.o查看信息
```
a.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000055  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000095  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000095  2**0
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000095  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000c0  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000e0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```

b.o: 通过objdump -h b.o查看信息：
```
b.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  0000000000000000  0000000000000000  00000090  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000094  2**0
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000094  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000bf  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000e0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```
在链接之前，a.o的各个section,其VMA都是0，对应的，b.o也是。但是在链接之后，我们可以看下ab文件的内容： objdump -h ab
```
ab:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .note.gnu.property 00000020  00000000004001c8  00000000004001c8  000001c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000040  0000000000401000  0000000000401000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .eh_frame     00000058  0000000000402000  0000000000402000  00002000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000004  0000000000404000  0000000000404000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000002a  0000000000000000  0000000000000000  00003004  2**0
                  CONTENTS, READONLY
```
在链接之后，可执行文件的VMA地址已经确定下来。并且这个VMA地址是可执行文件在装载完成进入运行时后会对应的虚拟地址空间的地址。在这里可以看到，.text的VMA地址是0000000000401000，这个应该是约定好的x86-64系统中可执行文件的入口地址。

### 符号地址的确定
两步链接法中的第二部，是在各个section的VMA确定之后，开始确定各个符号的虚拟地址。
各个符号在各自的section的偏移地址是确定的(这个信息很重要)，因此，在我们的例子中，‘main’、‘shared’、‘swap’的地址可以通过section+内部偏移的方式计算出来。

## 符号解析与重定位

### 重定位
必须以例子才能讲明白重定位的过程。
在链接发生之前，a.o的内容，可以通过 objdump -d a.o 来反汇编查看其中的逻辑：
```
a.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64                                         # 不太明白
   4:   55                      push   %rbp                                     # 这一行和下面的一行是在初始化栈帧。rbp在上，rsp在下。上面为高地址，下面为低地址
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp                               # 0x10对应10进制中的16，这里将rsp下移16是为了给main函数分配栈空间。其实这里main函数根本不需要在栈上申请空间（没有局部变量），
                                                                                # 至于为啥这里还要再申请16字节的栈，可能有什么特别的原因。搞不太明白
   c:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)                         # 将rbp[-4]的值设置成100(0x64)，由于rbp是在最上面的，rbp[-4]其实就是: int a = 100;
  13:   48 8d 45 fc             lea    -0x4(%rbp),%rax                          # 将rpb[-4]的地址记录在rax中。上面说过rbp[-4]是a，所以这里取地址就是对应于 &a
  17:   48 8d 35 00 00 00 00    lea    0x0(%rip),%rsi        # 1e <main+0x1e>   # 将rip[0]的地址记录在rsi中。rip寄存器记录的是当前执行位置，生成的注释中也说明了，当前的执行位置为<main+0x1e>
                                                                                # rip[0]这个地址是什么呢？其实这个例子中编译器也猜不出来，这里就随便用了rip[0]来代表swap函数的shared参数（rsi一般用来记录参
                                                                                # 数）。这个就是后面着重要介绍的符号重定位
  1e:   48 89 c7                mov    %rax,%rdi                                # 上面我们说了，rax这里记录的是&a，所以这里是为了提供swap函数的另一个参数： &a
  21:   b8 00 00 00 00          mov    $0x0,%eax                                # 清空eax。eax一般用来在函数中记录返回值
  26:   e8 00 00 00 00          callq  2b <main+0x2b>                           # 这里就去调用swap函数了。这里调用的地址是<main+0x2b>。这里这样记录地址，也是后面需要着重介绍的符号重定位
  2b:   b8 00 00 00 00          mov    $0x0,%eax                                # 这里就设置main函数的返回值了，默认是0
  30:   c9                      leaveq 
  31:   c3                      retq   
```

我们再看一下链接之后的反汇编代码：
```
ab:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <main>:
  401000:	f3 0f 1e fa          	endbr64 
  401004:	55                   	push   %rbp
  401005:	48 89 e5             	mov    %rsp,%rbp
  401008:	48 83 ec 10          	sub    $0x10,%rsp
  40100c:	c7 45 fc 64 00 00 00 	movl   $0x64,-0x4(%rbp)
  401013:	48 8d 45 fc          	lea    -0x4(%rbp),%rax                                   # 这里还是&a
  401017:	48 8d 35 e2 2f 00 00 	lea    0x2fe2(%rip),%rsi        # 404000 <shared>        # 这个生成的汇编注释都说了，这里是在&shared。至于这里的地址‘404000’，应该是shared这个变量在.data section中的 
                                                                                            # 地址。也就是说，这里已经发生了重定位了
  40101e:	48 89 c7             	mov    %rax,%rdi
  401021:	b8 00 00 00 00       	mov    $0x0,%eax
  401026:	e8 07 00 00 00       	callq  401032 <swap>                                     # 这里重定位之后，也已经替换成<swap>了。401032，恰好就是下面的swap在.text section中的起始地址
  40102b:	b8 00 00 00 00       	mov    $0x0,%eax
  401030:	c9                   	leaveq 
  401031:	c3                   	retq   

0000000000401032 <swap>:
  401032:	f3 0f 1e fa          	endbr64 
  401036:	55                   	push   %rbp
  401037:	48 89 e5             	mov    %rsp,%rbp
  40103a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  40103e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  401042:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401046:	8b 10                	mov    (%rax),%edx
  401048:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40104c:	8b 00                	mov    (%rax),%eax
  40104e:	31 c2                	xor    %eax,%edx
  401050:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401054:	89 10                	mov    %edx,(%rax)
  401056:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40105a:	8b 10                	mov    (%rax),%edx
  40105c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401060:	8b 00                	mov    (%rax),%eax
  401062:	31 c2                	xor    %eax,%edx
  401064:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401068:	89 10                	mov    %edx,(%rax)
  40106a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40106e:	8b 10                	mov    (%rax),%edx
  401070:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401074:	8b 00                	mov    (%rax),%eax
  401076:	31 c2                	xor    %eax,%edx
  401078:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40107c:	89 10                	mov    %edx,(%rax)
  40107e:	90                   	nop
  40107f:	5d                   	pop    %rbp
  401080:	c3                   	retq   

```

### 重定位表
ELF文件通过重定位表来说明那些section中的哪些符号需要如何重定位。每个需要被重定位的section都有一个对应的重定位表。而重定位表通常也是ELF文件中的一个单独的section： 举个例子，加入.text section需要重定位，那会存在一个对应的.rel.text section, 这个.rel.text section就是一个重定位表。可以通过命令objdump -r a.o来查看一个目标文件的重定位表信息:
```
a.o:     file format elf64-x86-64

RELOCATION RECORDS FOR [.text]:                                   // .text说明要被重定位的符号是在.text section中
OFFSET           TYPE              VALUE 
000000000000001a R_X86_64_PC32     shared-0x0000000000000004     // offset表示了这个要被重定位的符号现在在哪里
0000000000000027 R_X86_64_PLT32    swap-0x0000000000000004


RELOCATION RECORDS FOR [.eh_frame]:
OFFSET           TYPE              VALUE 
0000000000000020 R_X86_64_PC32     .text

```
这个命令列出了a.o的所有需要重定位的符号。上面的这个例子中就包括： .text section中的两个外部符号shared和swap，.eh_frame中的一个符号.text。


### 符号的解析
简单来说，就是要让程序找到某个符号存储在哪里。举个例子，上面的重定位过程中，重定位表是记录了重定位前符号的offset的，但是重定位后符号的位置是会发生改变的，因此链接器就需要确定这个符号的地址改变后会在哪里。
链接器是怎么做的呢？链接器会先去找全局符号表，如果发现有这个符号，但是符号是未定义的，说明这个符号等待被重定位。如果没找到，那链接器就会报错。

### 指令的修正方式
我们上面通过objdump -r a.o查看重定位表的时候，有一个信息，即TYPE那一栏中，有R_X86_64_PC32/R_X86_64_PLT32这样的信息。这个就是代表指令的修正方式。这部分的内容涉及到CPU指令的寻址方式。
R_X86_64_PC32： 相对寻址修正 S+A-P。其中，A代表‘保存在被修正位置的值’， P代表‘被修正的位置（即offset）’，S代表‘符号的实际地址（即该重定位入口的符号在符号表中的下标）’
修正的具体方式，还得参考下芯片手册。

## 链接过程控制

### 链接器控制脚本
要控制链接器的行为一般有3中方案：
- 给链接命令设置命令行参数，比如ld链接器的-o, -e参数等等
- 将链接的命令存放在obj文件中，编译器负责将命令传递给链接器。windows平台的COFF文件中会这么用
- 使用链接器控制脚本。这是本节重点介绍的内容

### 查看默认的链接器脚本
使用命令 ld -verbose可以查看默认的链接器脚本内容。这个脚本的内容有点多，一般可以取目录/usr/lib/ldscripts下面看到源文件。
我们可以在调用ld命令的时候显式声明我们自定义的链接器脚本文件：  ld -T link.script

### 最小的程序
```
char* str = "Hello World!\n";

void print() {
  asm("movl $13, %%edx \n\t"
    "movl %0, %%ecx \n\t"
    "movl $0, %%ebx \n\t"
    "movl $4, %%eax \n\t"
    "int $0x80 \n\t"
    ::"r"(str):"edx", "ecx", "ebx"
  );
}

void exit() {
  asm("movl $42, %ebx \n\t"
    "movl $1, %eax \n\t"
    "int $0x80 \n\t");
}

void nomain() {
  print();
  exit();
}
```
编译方法： gcc -fno-builtin -c test.c -m32
链接方法： ld -static -e nomain test.o -o test -m elf_i386


### 链接器脚本编写
我们现在为上面的代码编写一个TinyHelloWorld.lds链接器脚本。
```
ENTRY(nomain) 

SECTIONS
{
  . = 0x08048000 + SIZEOF_HEADERS;
  tinytext : { *(.text) *(.data) *(.rodata) }
  /DISCARD/ : { *(.comment) }
}
```
这三句话的含义：
1. . = 0x08048000 + SIZEOF_HEADERS: 将当前虚拟地址设置成0x08048000 + SIZEOF_HEADERS。SIZEOF_HEADERS这个变量代表输出文件的文件头大小。‘.’表示当前虚拟地址。这样设置之后，下一句话的地址就会变成我们设置过的0x08048000 + SIZEOF_HEADERS了
2. tinytext: { *(.text) *(.data) *(.rodata) }: 这第二条语句定义了一个section的转换规则，这里是将.text, .data, .rodata三个section依次合并到输出文件的.tinytext section中
3. /DISCARD/ : { *(.comment) }： 这第三句话定义了一个丢弃规则，这里是将输入文件中名为.comment的section内容丢弃，不拼接到输出文件中。

定义好lds之后，我们就可以这样链接了：
ld -static -T TinyHelloWorld.lds -o test test.o


### 链接器脚本语法
链接器脚本有两种语句：
1. 命令语句
2. 赋值语句
语句之间使用分号作为分隔符。有表达式与运算符，比如+,-,*,/,+=,*=,&,|,>>,<<等等。可以使用注释，与C语言类似，使用/**/注释。
命令语句略微复杂一些。上面的例子中的ENTRY(nomain)就是一个命令语句。同理，SECTIONS{}也是一个命令语句。
常用的命令语句包括：
- ENTRY(symbol)
- STARTUP(filename)
- SEARCH_DIR(path)
- INPUT(file, file,...)
- INCLUDE filename
- PROVIDE(symbol): 在链接脚本中定义某个符号，定义的符号可以在程序中被引用。

SECTION命令的语法为：
SECTIONS
{
  ...
  secname : {contents}
  ...
}

其中，secname表示输出section的名字，后面必须接一个空格符，这样可以保证提供的输出section名字不会有歧义。后面必须紧跟着冒号和大括号。大括号里面的contents描述了一套规则和条件： 所有符合这种条件和规则的输入section都会合并到secname中。secname的命名方法必须符合输出文件的格式要求。
上面出现了一个特殊的输出section名字： /DISCARD/，如果使用这个名字作为输出section的名字，那么所有符合后面定义的规则的输入section都会被丢弃，不编排到输出文件中。

从上面的描述可以看出，关键的内容还是contents这个描述规则和条件的内容。contents中可以包含多个条件，每个条件之间以空格隔开，如果输入section满足任何一个条件都可以被编排到输出文件中。contents的写法如下：
filename(sections)
其中，filename代表输入文件名，sections代表输入section的名字。神奇的是，这个匹配规则可以使用正则:-)
比如：  [a-z]*(.text*[A-Z])

### BFD库
简单来说，BFD(Binary File Descriptor library)库是一个GNU项目，目标是希望通过一种统一的接口来处理不同的目标文件格式。BFD本身是binutils项目的一个子项目。目前GNU的多个项目，包括汇编器gas,链接器ld，调试器gdb，binutils底层都是使用的BFD库。Ubuntu下BFD库有一个C语言开发库叫binutils-dev。