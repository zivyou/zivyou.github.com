---
title: '旧书新读: 《大象-think in UML》'
date: 2022-01-17 12:47:12
tags: books
mathjax:
  enable: true
---

# why
## 面向过程 VS. 面向对象

面向对象与面向过程之争本质上是认识论的争论。书中提到说古希腊哲学家亚里士多德也思考过这个问题: 世界是过程还是对象?学术界也有关于这个面向对象思维认识论的讨论。[<sup>1</sup>](#ref-anchor-1)
作者本人是认同这个世界的本质是由对象组成的，平时看上去相互无关的独立对象在不同的驱动力和规则下体现出不同的运动过程。而在面向过程的认知中，世界的一切都不是孤立的，他们互相紧密的联系在一起，缺一不可，互相影响，互相作用，并形成一个个具有严格因果律的小系统。

从面向过程思想转变到面向对象思想，首先要接受的事实是: 这个世界是割裂的，只有在特点的场景下，孤立对象之间进行了某些信息交互才会表现出我们理解的一个过程。

### 面向过程的问题
> 面向过程方法认为每个小系统都有着明确的开始和明确的结束，开始和结束之间有着严谨的因果关系。只要我们将这个小系统中的每一个步骤和影响这个小系统走向的所有因素都分析出来，我们就能完全定一个这个系统的行为。
单从上面的描述来看，文中对与面向过程思想的概括，与图灵机的定义非常像。

图灵机模型:
一台图灵机是一个七元组，`$ \{ Q, \Sigma, \Gamma, \delta, q_0, qaccept, qreject \}$`。其中，`$Q, \Sigma, \Gamma $`都是有限集合。这个七元组满足:
1. `$Q$`是状态集合;
2. `$\Sigma$`是输入字母表，其中不包含特殊的空白字符;
3. `$\Gamma$`是整个纸带上的字母集合，并且有，`$Q\subseteq\Gamma, \Sigma\subseteq\Gamma$`，
4. 定义运算: `$\delta: Q\times\Gamma \rightarrow Q\times\Gamma\times\{L, R\}$`，其中的L, R标识的是纸带的运行方向;
5. `$q_0 \in Q$`代表机器的初始状态;
6. qaccept代表一个特殊的状态，即「接受」;
7. qreject代表一个特殊的状态，即「拒绝」;


### 面向对象的思路
将世界看作一个一个独立的对象，对象之间没有因果关系。在外部力量的推动下，对象之间会依据某种规律传递信息。

### 面向对象的问题
1. 对象自己是怎么来的? 它的的生命周期是怎么回事?
2. 同一批对象，按照不同的结构组织起来，可以表达出不一样的功能。那么如何根据一批对象的组织结构来确定其功能呢?
3. 怎么确定一批对象的组合就满足了我们的需要呢?什么样的组合方式是好的，什么样的组合方式是坏的?

解决以上问题的关键，是抽象:
1. 找到一种方法，可以将现实世界映射到对象世界;
2. 找到一种方法，可以用对象世界描述现实世界;
3. 找到一种方法，可以验证对象世界是否正确的反映了现实世界; 

UML就是这样一种方法。

### 先将现实世界映射到业务模型
使用用例图来实现。用例图是一种元模型，其中，Actor是整个业务的驱动者，代表现实世界的人，是模型信息来源的提供者。用例则是描述Actor业务目标的模型，代表现实世界的事。业务场景和用例场景则代表的是规则。对象业务模型(business object model)代表达成业务目标过程中的事务，对应现实世界的物。因此，用例图定义了与现实世界中的人、事、物、规则之间的映射。

### 将业务模型映射到概念模型
借助分析模型图来实现。分析模型主要定义了以下元素:
1. 边界类: 定义了交互界面/操作界面;
2. 实体类: 定义与现实世界一一映射的事物和其间的逻辑关联;
3. 控制类: 定义原始需求中的动态信息;
在分析模型图的基础之上，可以加以归纳和整理，得出软件的一些关键信息，比如包、组件和节点。

### 将概念模型映射到设计模型
做一些具体的软件设计工作，包括且不限于:
1. 控制类转换成程序或者框架，比如说工作流，算法体等;
2. 实体类转化成数据库表、XML文档等持久化元素;
3. 设定实现类的关系，例如继承、接口等;
4. 编程语言选型;
5. 中间件选型;
6. 代码规范选型;
...

# 建模
什么是建模? 怎么样建模? 建出的模是什么?
$$
问题领域 = \sum_{1}^{n} 抽象角度
$$
$$
抽象角度 = 问题领域边界之外的参与者的业务目标 = 业务用例
$$
$$
业务用例 = \sum_{1}^{n} 特定场景
$$
$$
特定场景 = 静态的事物 + 特定的规则 + 特定的动作
$$
$$
特定场景 = 特定的事物 + 特定的规则 + 特定的的人的行动
$$

## 用例驱动
用例可以用于构建以下内容:
1. 逻辑视图: 以图形方式说明系统的关键用例实现、子系统、包和类;
2. 进程视图: 以图形方式说明系统中进程的详细组织结构;
3. 部署视图: 以图形的方式说明处理活动在系统中各节点的分布;
4. 实施视图: 获取为实施指定的架构决策，包括: 描述子系统，描述分层，描述子系统的依赖关系。说的直白一点就是团队分工。

## 抽象层次
面向对象软件设计方法一般采用自顶向下的抽象方法;

## 对象分析方法
1. 一切都是对象;
2. 对象都是独立的;
3. 对象都具有原子性;
4. 对象都是可抽象的;
5. 对象都有层次;

# UML核心元素

## 版型(stereotype)
UML中的一个基础元素以及扩展元素。例如以下概念都可以称之为版型: 业务用例、类、接口、边界类、实体类、控制类、参与者等基础元素，子系统、组织结构、模块等自定义的扩展元素，文档、开发小组等更模糊的元素。
下面逐个介绍各个版型的内涵。

## 参与者(Actor)
参与者在建模中是处于核心地位的，他是系统外与系统交互的人或事物。

## 用例
用例是UML建模中最最重要的一个元素。由于面向对象世界中的对象是独立的、静止的，只有用例可以施加一种外力，让这些静止的对象成为一个系统。

### 用例的特征
1. 用例是相对独立的;
2. 用例的执行结果对于参与者来说是可观测的、有意义的;
3. 用例必须由参与者发起;
4. 用例必须以动宾短语出现;
5. 一个用例就是一个需求单元、分析单元、设计单元、开发单元、测试单元，甚至是部署单元;

### 用例的粒度
粒度的选择问题，本质上是边界认定的问题。
1. 参与者中是位于系统边界之外的;
2. 参与者对于系统有着明确的期望和明确的回报要求;
3. 参与者的期望和回报要求在系统边界之外;

## 业务实体
业务实体是类(class)的一种版型，代表业务角色执行业务用例时所处理或使用的事物。

### 业务实体的属性
属性是用来保存业务实体特征的一个记录，业务实体的属性集合决定了它的唯一性。
### 业务实体的方法
方式是业务实体的一个访问句柄，它规定了外部可以怎样来使用它。

### 如何获取业务实体
首先，我们需要建立业务用例场景。一般来说是一个动宾短语，用来描述参与者实现其业务目标的过程。
然后，我们从用例的动宾短语中获取其中的名词，这些名词都是我们业务实体的备选对象。
然后，对这些备选对象进行一轮筛选，去除对于业务目标没有直接贡献的对象，剩下的就是业务实体。
最后，分析这些业务实体的关系，并决定哪些可以单独建模，哪些只是作为属性。


## 包
包是一种容器，类似于文件夹，可以将信息分类，形成逻辑单元。包可以容纳任何UML元素，包括用例、业务实例、类图、子包等等。
分包的好坏是由包之间的依赖关系来评判的，包与包之间只有一种关系: 依赖关系。好的包应该具有高内聚、低耦合的特征。
什么是依赖?
1. 如果A发生变化，B必然发生变化，我们称B依赖于A;
分包可以按照以下思路:
1. 分入同一个包中的元素应当是相互紧密联系、不可分割的;
2. 包中任意一个元素被修改，其他包中的任何一个元素的内容都不受影响;
3. 如何包与包之间有依赖关系，则这种依赖关系应该是单向的，应避免发生双向依赖或者循环依赖;

一些常见的包的版型包括:
1. 领域包: 用于在业务领域内的业务单元之间做分类;
2. 子系统: 用于分类系统中的逻辑对象并形成子系统;
3. 组织结构: 用于分类业务领域内的组织结构;
4. 层: 用于分类软件中的层次;

## 分析类


## Reference

<div id="ref-anchor-1"></div>
<!-- 下面必须有一个空行 -->

  - [1]: [Aristotle and object-oriented programming](https://dl.acm.org/doi/10.1145/330908.331862)