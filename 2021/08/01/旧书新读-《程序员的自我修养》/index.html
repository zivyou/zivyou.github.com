<!DOCTYPE html>
<head>
  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  
  <title>旧书新读:《程序员的自我修养》 | zivyou</title>
  <link rel="shortcut icon" href="/img/favicon.png">
  <meta name="description" content="编译与链接 编译过程 预处理 编译 汇编 链接   编译器前端 词法分析 语法分析 中间代码生成   编译器后端 代码生成 目标代码优化     目标文件格式 格式 分析工具 .text section .data section &#x2F; .rodata section .bss section 自定义section   ELF文件格式 文件头（File header） section表(secti">
<meta property="og:type" content="article">
<meta property="og:title" content="旧书新读:《程序员的自我修养》">
<meta property="og:url" content="http://zivyou.github.io/2021/08/01/%E6%97%A7%E4%B9%A6%E6%96%B0%E8%AF%BB-%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B/index.html">
<meta property="og:site_name" content="zivyou">
<meta property="og:description" content="编译与链接 编译过程 预处理 编译 汇编 链接   编译器前端 词法分析 语法分析 中间代码生成   编译器后端 代码生成 目标代码优化     目标文件格式 格式 分析工具 .text section .data section &#x2F; .rodata section .bss section 自定义section   ELF文件格式 文件头（File header） section表(secti">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-01T03:08:04.000Z">
<meta property="article:modified_time" content="2023-06-13T14:51:59.286Z">
<meta property="article:author" content="zivyou">
<meta property="article:tag" content="books">
<meta name="twitter:card" content="summary">
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
<script src="/js/image-preview.js" defer></script>

  
  
<script src="/js/main.js" defer></script>

  
<meta name="generator" content="Hexo 7.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
<html>

<body>
  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container">
    <header class="user-select">
  <div class="header-container-wrap">
    <div class="header-container">
      
      
      
      <style>
        .logo>* {
          width:auto;height:4rem;border-radius:50%;;
        }
      </style>
      
      <a href="/" class="logo">
        <img data-src="/img/logo.gif" / src=/img/load.gif>
      </a>
      
      <nav>
        
        <div class="search" tabindex="-1">
          <input class="search-input" placeholder="Search for articles" type="search" maxlength="64">
          <div class="seach-icon-container">
            <svg class="search-icon" width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12.4008 12.4008C14.744 10.0577 14.744 6.25871 12.4008 3.91556C10.0577 1.57242 6.25871 1.57242 3.91556 3.91556C1.57242 6.25871 1.57242 10.0577 3.91556 12.4008C6.25871 14.744 10.0577 14.744 12.4008 12.4008ZM12.4008 12.4008L15.5828 15.5828" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor"></path>
</svg>
          </div>
          <div class="search-history">
            <div class="search-history-title">
              <span>Search for History</span>
              <span class="search-history-clear">Clear</span>
            </div>
            <div class="search-history-list"></div>
          </div>
          <div class="search-result"></div>
          
<script src="/js/search.js" path="&#x2F;search.json" defer></script>

        </div>
        

        
        
        <ul class="nav-list">
          
          <li class="nav-list-item">
            <a href="/">Home</a>
          </li>
          
        </ul>
        <div class="sidebar-nav" tabindex="-1">
          <svg class="sidebar-nav-btn" viewBox="0 0 16 16" width="16" height="16">
  <path d="M3,11.335h16M3,6h16M3,16.67h16" transform="translate(-3-3.335)" stroke="currentColor" stroke-width="2" />
</svg>
          <div class="mask" tabindex="-1"></div>
          <ul class="nav-list">
            
            <li class="nav-list-item">
              <a href="/">Home</a>
            </li>
            
          </ul>
        </div>
        
      </nav>
    </div>
  </div>
</header>
    <div class="main-wrap">
      <main class="main-width">
        
        <h1 class="page-title">旧书新读:《程序员的自我修养》</h1>
        
        <article class="article page">
  <div class="article-info">
    
    <img data-src="https://www.imlete.cn/img/avatar.png" alt="avatar" class="avatar" src=/img/load.gif>
    
    <div class="article-meta">
      <div class="author-name">zivyou</div>
      <div class="article-meta-list">
        
        <time datetime="2021-08-01 11:08:04" title="2021-08-01 11:08:04" class="time">
          2021-08-01 11:08:04
        </time>
        
        <div class="article-meta-item-wrap">
          
          <div class="article-meta-item">
            <svg class="word-icon" width="16" height="16" viewBox="0 0 48 48" fill="none" stroke-width="4" stroke-linejoin="round" stroke="currentColor" xmlns="http://www.w3.org/2000/svg" >
  <path d="M10 4H30L40 14V42C40 43.1046 39.1046 44 38 44H10C8.89543 44 8 43.1046 8 42V6C8 4.89543 8.89543 4 10 4Z"></path>
  <path d="M16.0083 20L19.0083 34L24.0083 24L29.0083 34L32.0083 20"></path>
</svg>
            <span>8.6k</span>
          </div>
          
          
          <div class="article-meta-item">
            <svg class="time-icon" width="16" height="16" viewBox="0 0 48 48" fill="none" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path d="M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z" />
  <path d="M24.0084 12.0001L24.0072 24.0089L32.4866 32.4883" />
</svg>
            <span>36min</span>
          </div>
          
        </div>
        
      </div>
    </div>
  </div>
  <div class="article-content"><ul>
<li><a href="#编译与链接">编译与链接</a><ul>
<li><a href="#编译过程">编译过程</a><ul>
<li><a href="#预处理">预处理</a></li>
<li><a href="#编译">编译</a></li>
<li><a href="#汇编">汇编</a></li>
<li><a href="#链接">链接</a></li>
</ul>
</li>
<li><a href="#编译器前端">编译器前端</a><ul>
<li><a href="#词法分析">词法分析</a></li>
<li><a href="#语法分析">语法分析</a></li>
<li><a href="#中间代码生成">中间代码生成</a></li>
</ul>
</li>
<li><a href="#编译器后端">编译器后端</a><ul>
<li><a href="#代码生成">代码生成</a></li>
<li><a href="#目标代码优化">目标代码优化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#目标文件格式">目标文件格式</a><ul>
<li><a href="#格式">格式</a></li>
<li><a href="#分析工具">分析工具</a><ul>
<li><a href="#text-section">.text section</a></li>
<li><a href="#data-section--rodata-section">.data section / .rodata section</a></li>
<li><a href="#bss-section">.bss section</a></li>
<li><a href="#自定义section">自定义section</a></li>
</ul>
</li>
<li><a href="#elf文件格式">ELF文件格式</a><ul>
<li><a href="#文件头file-header">文件头（File header）</a></li>
<li><a href="#section表section-header-table">section表(section header table)</a></li>
<li><a href="#重定位表relocation-table">重定位表(Relocation Table)</a></li>
<li><a href="#字符串表">字符串表</a></li>
</ul>
</li>
<li><a href="#符号">符号</a><ul>
<li><a href="#符号表结构">符号表结构</a></li>
<li><a href="#特殊符号">特殊符号</a></li>
<li><a href="#符号修饰和函数签名">符号修饰和函数签名</a></li>
<li><a href="#extern-c">extern “C”</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#静态链接过程">静态链接过程</a><ul>
<li><a href="#空间与地址分配">空间与地址分配</a><ul>
<li><a href="#空间占用与分配">空间占用与分配</a></li>
<li><a href="#相似段合并">相似段合并</a></li>
<li><a href="#两步链接法">两步链接法</a></li>
<li><a href="#链接命令">链接命令</a></li>
<li><a href="#链接后的地址变化">链接后的地址变化</a></li>
<li><a href="#符号地址的确定">符号地址的确定</a></li>
</ul>
</li>
<li><a href="#符号解析与重定位">符号解析与重定位</a><ul>
<li><a href="#重定位">重定位</a></li>
<li><a href="#重定位表">重定位表</a></li>
<li><a href="#符号的解析">符号的解析</a></li>
<li><a href="#指令的修正方式">指令的修正方式</a></li>
</ul>
</li>
<li><a href="#链接过程控制">链接过程控制</a><ul>
<li><a href="#链接器控制脚本">链接器控制脚本</a></li>
<li><a href="#查看默认的链接器脚本">查看默认的链接器脚本</a></li>
<li><a href="#最小的程序">最小的程序</a></li>
<li><a href="#链接器脚本编写">链接器脚本编写</a></li>
<li><a href="#链接器脚本语法">链接器脚本语法</a></li>
<li><a href="#bfd库">BFD库</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>C程序的编译过程：<br>C源码文件: hello.c  —预处理器(cpp命令)—&gt; hello.i —编译(gcc命令)—&gt; hello.s —汇编(as命令)—&gt; hello.o —链接(ld命令)—&gt; a.out</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>使用cpp命令执行源码的预处理，预处理阶段主要做以下事情：</p>
<ul>
<li>宏展开，替换所有的#define宏</li>
<li>处理预编译命令，比如: #if, #ifdef, #elif, #else, #endif</li>
<li>递归展开#include</li>
<li>删除所有注释</li>
<li>添加行号和文件名标识: #2 “hello.c” 2</li>
<li>保留#pragma</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>这里的编译指的是狭义上的编译，主要做的是编译器前端的工作。使用gcc命令执行编译，主要做的事情：</p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>生成汇编代码及优化<br>这个阶段是广义的编译过程中最复杂的阶段。</li>
</ul>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>比较简单，调用命令as对生成的汇编代码进行翻译，生成对应的机器指令即可。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>调用ld命令将汇编阶段生成的obj文件组装成一个可执行文件。这个过程略有一点复杂，下文重点讲这个内容。</p>
<h2 id="编译器前端"><a href="#编译器前端" class="headerlink" title="编译器前端"></a>编译器前端</h2><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>步骤：</p>
<ol>
<li>通过扫描器(Scanner)将源代码读入</li>
<li>通过有限状态机(Finite State Machine)将字符串分割成一系列记号(Token)<br>可以识别出的记号一般包括这几种： 关键字、标识符、字面量、特殊符号（如加号，等号等）。在识别符号的同时也会做好分类，如将标识符放到符号表，将数字、字符串放到文字表等。<br>可用的词法分析工具： lex, GNU的Flex等。</li>
</ol>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>目标是将上面词法分析过程产生的记号生成一个语法树(Syntax Tree， 也会被称作AST: Abstract Syntax Tree)。使用上下文无关语法（Context-free Grammar）推理自动机。语法树是以表达式（Expression）为节点的树。<br>可选的语法分析工具包括： yacc(Yet Another Compiler Compiler), GNU的Bison, Antlr, JavaCC等。</p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>语法分析阶段生成的AST没法做优化，因此源代码优化器常常会将AST转换成中间代码(Intermediate Code， 也会被称作‘中间表达形式(Intermediate Representation)’)。它实际上是AST的一个线性展开，将语法树展开成顺序的表达形式。一般IC已经比较接近目标代码了，但目前为止和目标机器的运行时环境还是无关的，因为它不包含数据的尺寸、变量的地址、寄存器的名字等等。<br>中间代码有多种类型，比较常见的有：</p>
<ul>
<li>三地址码(Three-address code): 三地址码的表达式形式： x = y op z<br>举个例子，表达式’2<em>a+(b-3)’用3地址码会翻译成下面这样：<br>T1 = 2 </em> a;<br>T2 = b - 3<br>T3 = t1 + t2</li>
<li>P代码（P-Code）: 用来生成那些具有逻辑栈结构的机器（也被称为P-Machine，通常我们会在P机器上写解释器）。生成的P代码一般都是用来直接解释执行的，所以在P代码中会包含运行时环境的一些隐式描述。<br>P机器由以下元素构成： 代码内存，有名变量的数据内存，栈，寄存器（抽象的）。<br>举个例子：  还是表达式’2*a+(b-3)’用P代码会翻译成下面这样<figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ldc 2    ; 加载常量2</span><br><span class="line">lod a    ; 加载变量a的值</span><br><span class="line">mpi      ; 整数乘法操作</span><br><span class="line">lod b    ; 加载变量b的值</span><br><span class="line">ldc 3    ; 加载常量3</span><br><span class="line">sbi      ; 整数减法</span><br><span class="line">adi      ; 整数加法</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="编译器后端"><a href="#编译器后端" class="headerlink" title="编译器后端"></a>编译器后端</h2><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>代码生成器（Code Generator）将中间代码转换成目标机器代码。这个过程的具体内容依赖于目标机器，因为不同的机器有不同的字长、寄存器、整数数据类型和浮点数据类型等等。<br>我们以一个全新的例子来看。<br>假设有一段C代码： array[index] = (index + 4) * (2 + 6)<br>那么会生成中间代码（假设是三地址码）如下：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = 2 + 6</span><br><span class="line">t2 = index + 4</span><br><span class="line">t3 = t2 * t1</span><br><span class="line">array[index] = t3</span><br></pre></td></tr></table></figure></p>
<p>中间代码优化后会得到：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t2 = index + 4</span><br><span class="line">t2 = t2 * 8</span><br><span class="line">array[index] = t2</span><br></pre></td></tr></table></figure></p>
<p>那么，上面优化后的三地址码在代码生成阶段会生成下面的目标代码：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl index, %ecx       ; 将index的值赋值给ecx</span><br><span class="line">addl $4, %ecx          ; ecx的值加4</span><br><span class="line">mull $8, %ecx          ; ecx的值乘以8</span><br><span class="line">movl index, %eax       ; 将index的值赋值给eax</span><br><span class="line">movl %ecx, array(, eax, 4) ; array[index] = ecx</span><br></pre></td></tr></table></figure></p>
<h3 id="目标代码优化"><a href="#目标代码优化" class="headerlink" title="目标代码优化"></a>目标代码优化</h3><p>得到了上面的目标代码之后，目标代码优化器（Target Code Optimizer）还会对生成的目标代码进一步优化。主要的优化手段包括：</p>
<ul>
<li>选择合适的寻址方式</li>
<li>使用位运算替代乘法运算</li>
<li>删除多余的指令<br>等等。<br>上面的例子，在优化之后，目标代码会变成：<figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl index, %edx</span><br><span class="line">leal 32(, %edx, 8), %eax</span><br><span class="line">movl %eax, array(, %edx, 4)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，狭义的编译器的工作就全部完成了。</p>
<h2 id="链接器"><a href="#链接器" class="headerlink" title="　链接器"></a>　链接器</h2><p>链接器的主要任务是各个目标文件中相互引用的部分处理好，使得各个目标文件可以正确衔接。主要包括以下几个过程：</p>
<ul>
<li>地址和空间分配（Address and Storage Allocation）</li>
<li>符号决议（Symbol Resolution），也被称为 符号绑定（Symbol Binding）、名称绑定(Name Binding)、名称决议(Name Resolution)、地址绑定（Address Binding）、指令绑定（Instruction Binding）等等。</li>
<li>重定位（Relocation）</li>
</ul>
<h1 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h1><p>Windows平台的可执行文件格式为PE格式（Portable Executable），Linux下的为ELF格式（Executable Linkable Format）。这两者都是COFF(Common File Format)格式的变种。<br>我们上面提到的‘目标文件’指的是编译完成后但是没有开始链接的那些中间文件，Windows下为.obj后缀，Linux下为.o后缀。<br>目标文件和可执行文件的内容和结构相似，所以一般和可执行文件采取相同的格式存储。(其实.dll文件，.so文件，.lib, .a文件还有.core文件也是按这个格式存储的)</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>目标文件中内容有那些？ 答： 有机器指令代码、数据、符号表、调试信息、字符串等。<br>目标文件会将这些信息按照不同的属性，以section为单位进行存储。比如，编译后的机器指令放在.code或者.text section；全局变量和局部静态变量放在.data section中 等等。<br>目标文件还有一个‘文件头（File Header）’，它描述了整个文件的文件属性，比如文件是否可执行、是静态链接还是动态链接、如果是可执行文件，那入口地址是多少、目标硬件是什么、目标操作系统是什么等等。文件头中还有一个section表（section table），它是一个描述文件中各个section的数组，记录了文件中各个section在文件中的偏移位置及sectoin的属性等。</p>
<h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><p>objdump -h工具可以将文件的各个section的基本信息打印出来。<br>示例代码:<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int printf(const char* format, ...);</span><br><span class="line"></span><br><span class="line">int global_int_var = 84;</span><br><span class="line">int global_uninit_var;</span><br><span class="line"></span><br><span class="line">void func1(int i) &#123;</span><br><span class="line">        print(&quot;%d, \n&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">        static int static_var = 85;</span><br><span class="line">        static int static_var2;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b;</span><br><span class="line">        func1(static_var + static_var2 + a + b);</span><br><span class="line">        return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gcc -o hello.o -c hello.c 编译之后得到hello.o。使用objdump -h得到：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000005f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000a0  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000004  0000000000000000  0000000000000000  000000a8  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000006  0000000000000000  0000000000000000  000000a8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002b  0000000000000000  0000000000000000  000000ae  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d9  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000e0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .eh_frame     00000058  0000000000000000  0000000000000000  00000100  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure></p>
<p>上述输出中，section有多个必选属性： idx, 名字，大小，VMA，LMA，文件内偏移File Offset, 对齐方式Align。第二行的contents, allocation, load, relocation, readonly, code等标识section的一些可选属性。<br>下面依次看这些section。</p>
<h3 id="text-section"><a href="#text-section" class="headerlink" title=".text section"></a>.text section</h3><p>objdump -s 可以以十六进制打印，-d可进行反汇编，于是： objdump -s -d hello.o 有：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 f30f1efa 554889e5 4883ec10 897dfc8b  ....UH..H....&#125;..</span><br><span class="line"> 0010 45fc89c6 488d3d00 000000b8 00000000  E...H.=.........</span><br><span class="line"> 0020 e8000000 0090c9c3 f30f1efa 554889e5  ............UH..</span><br><span class="line"> 0030 4883ec10 c745f801 0000008b 15000000  H....E..........</span><br><span class="line"> 0040 008b0500 00000001 c28b45f8 01c28b45  ..........E....E</span><br><span class="line"> 0050 fc01d089 c7e80000 00008b45 f8c9c3    ...........E... </span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 54000000 55000000                    T...U...        </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 25642c20 0a00                        %d, ..          </span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202855 62756e74 7520392e  .GCC: (Ubuntu 9.</span><br><span class="line"> 0010 332e302d 31377562 756e7475 317e3230  3.0-17ubuntu1~20</span><br><span class="line"> 0020 2e303429 20392e33 2e3000             .04) 9.3.0.     </span><br><span class="line">Contents of section .note.gnu.property:</span><br><span class="line"> 0000 04000000 10000000 05000000 474e5500  ............GNU.</span><br><span class="line"> 0010 020000c0 04000000 03000000 00000000  ................</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 28000000 00450e10 8602430d  ....(....E....C.</span><br><span class="line"> 0030 065f0c07 08000000 1c000000 3c000000  ._..........&lt;...</span><br><span class="line"> 0040 00000000 37000000 00450e10 8602430d  ....7....E....C.</span><br><span class="line"> 0050 066e0c07 08000000                    .n......        </span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func1&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64 </span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   c:   89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">   f:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  12:   89 c6                   mov    %eax,%esi</span><br><span class="line">  14:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 1b &lt;func1+0x1b&gt;</span><br><span class="line">  1b:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  20:   e8 00 00 00 00          callq  25 &lt;func1+0x25&gt;</span><br><span class="line">  25:   90                      nop</span><br><span class="line">  26:   c9                      leaveq </span><br><span class="line">  27:   c3                      retq   </span><br><span class="line"></span><br><span class="line">0000000000000028 &lt;main&gt;:</span><br><span class="line">  28:   f3 0f 1e fa             endbr64 </span><br><span class="line">  2c:   55                      push   %rbp</span><br><span class="line">  2d:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  30:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">  34:   c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%rbp)</span><br><span class="line">  3b:   8b 15 00 00 00 00       mov    0x0(%rip),%edx        # 41 &lt;main+0x19&gt;</span><br><span class="line">  41:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 47 &lt;main+0x1f&gt;</span><br><span class="line">  47:   01 c2                   add    %eax,%edx</span><br><span class="line">  49:   8b 45 f8                mov    -0x8(%rbp),%eax</span><br><span class="line">  4c:   01 c2                   add    %eax,%edx</span><br><span class="line">  4e:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  51:   01 d0                   add    %edx,%eax</span><br><span class="line">  53:   89 c7                   mov    %eax,%edi</span><br><span class="line">  55:   e8 00 00 00 00          callq  5a &lt;main+0x32&gt;</span><br><span class="line">  5a:   8b 45 f8                mov    -0x8(%rbp),%eax</span><br><span class="line">  5d:   c9                      leaveq </span><br><span class="line">  5e:   c3                      retq</span><br></pre></td></tr></table></figure></p>
<p>‘Contents of section .text’部分就是用十六进制将.text section的内容打印出来。</p>
<h3 id="data-section-rodata-section"><a href="#data-section-rodata-section" class="headerlink" title=".data section / .rodata section"></a>.data section / .rodata section</h3><p>.data section存储已经初始化的全局静态变量和局部静态变量。.rodata section存放只读数据，如字符串字面量、使用了const修饰的只读变量等。</p>
<h3 id="bss-section"><a href="#bss-section" class="headerlink" title=".bss section"></a>.bss section</h3><p>.bss存放未初始化的全局变量和未初始化的局部静态变量，比如示例中的global_uninit_var和static_var2就存在.bss section中。</p>
<h3 id="自定义section"><a href="#自定义section" class="headerlink" title="自定义section"></a>自定义section</h3><ol>
<li>将二进制数据拷贝到目标文件中： objcopy -I binary -O elf64-x86-64 -B i386 image.jpg hello.o</li>
<li>在C语言中显式地指定变量的section:<figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((setion(&quot;FOO&quot;)) int global = 42;</span><br><span class="line">__attribute__((section(&quot;BAR&quot;))) void foo() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h2><h3 id="文件头（File-header）"><a href="#文件头（File-header）" class="headerlink" title="文件头（File header）"></a>文件头（File header）</h3><p>方法： 使用readelf命令来查看elf文件： readelf -h hello.o<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00                  // EFL魔数</span><br><span class="line">  Class:                             ELF64                                  // 机器的字长</span><br><span class="line">  Data:                              2&apos;s complement, little endian          // 数据存储方式</span><br><span class="line">  Version:                           1 (current)                            // 版本</span><br><span class="line">  OS/ABI:                            UNIX - System V                        // 运行平台</span><br><span class="line">  ABI Version:                       0                                      // ABI版本</span><br><span class="line">  Type:                              REL (Relocatable file)                 // ELF重定位类型</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64          // 硬件平台</span><br><span class="line">  Version:                           0x1                                    // 硬件平台版本</span><br><span class="line">  Entry point address:               0x0                                    // 入口地址</span><br><span class="line">  Start of program headers:          0 (bytes into file)                    // 程序头入口和长度</span><br><span class="line">  Start of section headers:          1184 (bytes into file)                 // section表的位置和长度</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         14                                     // section的数量</span><br><span class="line">  Section header string table index: 13</span><br></pre></td></tr></table></figure></p>
<h3 id="section表-section-header-table"><a href="#section表-section-header-table" class="headerlink" title="section表(section header table)"></a>section表(section header table)</h3><p>保存各个section的基本属性信息，比如section名字、长度、在文件中的偏移、读写权限等等。<br>获取section表的信息：  readelf -S hello.o<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">There are 14 section headers, starting at offset 0x4a0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000380</span><br><span class="line">       0000000000000078  0000000000000018   I      11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000a0</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000006  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000ae</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000d9</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .note.gnu.propert NOTE             0000000000000000  000000e0</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .eh_frame         PROGBITS         0000000000000000  00000100</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [10] .rela.eh_frame    RELA             0000000000000000  000003f8</span><br><span class="line">       0000000000000030  0000000000000018   I      11     9     8</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  00000158</span><br><span class="line">       00000000000001b0  0000000000000018          12    12     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  00000308</span><br><span class="line">       0000000000000072  0000000000000000           0     0     1</span><br><span class="line">  [13] .shstrtab         STRTAB           0000000000000000  00000428</span><br><span class="line">       0000000000000074  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure></p>
<p>这里面，需要关注一下的是section的类型，即Type这个属性。由于section的名字可以自定义，我们的系统是通过section的Type来确认这个section是干嘛用的。另外，Flags这个属性指示了这个section在进程虚拟地址空间中的属性，比如是否可写、是否可执行等等。Link和Info两个属性指示了该section如何进行链接，具体的组合有点复杂，这里略去。</p>
<h3 id="重定位表-Relocation-Table"><a href="#重定位表-Relocation-Table" class="headerlink" title="重定位表(Relocation Table)"></a>重定位表(Relocation Table)</h3><p>.rela.text这个section的Type属性是RELA，说明这个section是一个重定位表（Relocation Table）。这个section指示了链接器需要对那些内容进行怎样的重定位。需要说明的是，.rela.text这个section是针对.text section中那些需要重定位的内容设置的，同理，如果需要对.data section进行重定位，那么也会有一个.rela.data section来提供这些信息。</p>
<h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>上面例子中的.strtab和.shstrtab section就是字符串表，用来存储普通的字符串。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>函数和变量都是符号。链接的过程就是让引用符号的人找到符号定义的地址的过程。<br>每个目标文件都会有一个符号表（Symbol Table），用来记录目标文件需要使用到的符号。每个符号都有一个对应的值，叫做符号值（Symbol Value）。对于函数和变量来说，符号值就是它们的地址。<br>除了函数和变量，还有其他种类的符号，它们分别是：</p>
<ul>
<li>定义在本目标文件中的全局符号，可以被其他目标文件引用。比如示例中的func1, main, global_init_var</li>
<li>在本目标文件中引用的全局符号，但是却没有在本目标文件中定义，这种称为外部符号。比如示例中的printf</li>
<li>section名字，由编译器产生，它的值就是该section的起始地址。比如.text, .data</li>
<li>局部符号，这种符号只能一个编译单元内部看到。比如static_var, static_var2。局部符号在链接过程是不可见的，链接器会直接忽略它们。</li>
<li>行号信息，目标文件中的指令预源代码中的行号的对应信息</li>
</ul>
<p>链接器最关心是上面的第一种和第二种符号。</p>
<h3 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h3><p>符号表就是上面例子中的.symtab section。它的内容也是一个数组，数组中的每个元素包含以下几个关键信息： </p>
<ul>
<li>符号类型和绑定信息（st_info）:说明是不是外部的、弱引用的，同时还说明该符号是个啥类型</li>
<li>符号所在section(st_shndx): 如果符号是在本目标文件中定义，那这个字段会指示其所在的是那个section。如果不是，那该字段会是几个特殊的值。</li>
<li>符号值（st_value）: 对于变量和函数，就是它们的地址。</li>
</ul>
<p>可以通过readelf -s hello.o来看目标文件中的符号。<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Symbol table &apos;.symtab&apos; contains 18 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1922</span><br><span class="line">     7: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 static_var2.1923</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 </span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">    12: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_int_var</span><br><span class="line">    13: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var</span><br><span class="line">    14: 0000000000000000    40 FUNC    GLOBAL DEFAULT    1 func1</span><br><span class="line">    15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND print</span><br><span class="line">    17: 0000000000000028    55 FUNC    GLOBAL DEFAULT    1 main</span><br></pre></td></tr></table></figure></p>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>有很多由链接器ld为我们内置的符号，我们甚至可以直接在代码中引用它们。</p>
<ul>
<li>__executable_start: 程序的起始地址，不是入口地址，是指程序的最开始的地址</li>
<li>__etext: .text section的结束地址</li>
<li>_edata: .data section的结束地址</li>
<li>_end/end: 程序的结束地址<br>上面的这些地址都是在程序状态完成之后，操作系统为我们分配的虚拟地址。</li>
</ul>
<h3 id="符号修饰和函数签名"><a href="#符号修饰和函数签名" class="headerlink" title="符号修饰和函数签名"></a>符号修饰和函数签名</h3><p>简单来说，为了避免我们自己写的函数名、变量名和系统中内置的库中的函数名、变量名重复，编译器会在编译的时候给我们自定义的符号名修饰一下。<br>C++的修饰方法：</p>
<ol>
<li>函数签名： 函数签名包括了它的函数名、参数类型、所在的类、命令空间等等信息。<br>举个几个例子：<ul>
<li>int func(int) -&gt; _Z4funci</li>
<li>float func(float) -&gt; _Z4funcf</li>
<li>int C::func(int) -&gt; _ZN1C4funcEi</li>
<li>int C::C2::func(int) -&gt; _ZN1C2C24funcEi</li>
<li>int N::func(int) -&gt; _ZN1N4funcEi</li>
<li>int N::C::func(int) -&gt; _ZN1N1C4funcEi<br>这个修饰的规律是： C++的修饰风格都以_Z打头，对于嵌套的名字；后面会加一个N，然后接命令空间或者类的名字，这里的名字前面的数字是指这个名字的长度；最后会以E结尾。参数列表会紧跟在E的后面。<br>有个工具叫c++filt可以帮我们翻译被修饰过的名字。</li>
</ul>
</li>
</ol>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>这个语句是C++中用来声明和C兼容的语句的时候使用的。在使用了这个语句的大括号内的语句，C++编译器不会启动符号修饰机制。</p>
<h1 id="静态链接过程"><a href="#静态链接过程" class="headerlink" title="静态链接过程"></a>静态链接过程</h1><p>代码片段A：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern int shared;</span><br><span class="line">int main() &#123;</span><br><span class="line">     int a = 100;</span><br><span class="line">     swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译： gcc -c a.c -fno-stack-protector -o a.o</p>
<p>代码片段B：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int shared = 1;</span><br><span class="line">void swap (int *a, int * b) &#123;</span><br><span class="line">     *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译： gcc -c b.c -fno-stack-protector -o b.o</p>
<h2 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h2><h3 id="空间占用与分配"><a href="#空间占用与分配" class="headerlink" title="空间占用与分配"></a>空间占用与分配</h3><p>在上文中，我们提到.text section和.data section，它们的空间占用很好理解： 它们中都存储了具体的内容，这些内容需要多少空间来存储，对应就有多少空间被占用。<br>但是对于.bss section，它自身是没有包含内容的，它的空间占用如何理解？<br>.bss section本身在obj文件和最终的输出文件中，都是不占用空间的，因为未初始化的数据，都是以0表示。为了节省，obj文件和输出文件都会用一句话描述’这里有多少个0’来描述.bss section，而不会实际去存那么多个0.<br>但是，当最终输出的可执行文件装载并执行的时候，运行时的.bss section是会去申请内存空间的，并且有多少个0就会申请多少字节的空间。运行时申请的空间是虚拟地址空间。为了统一，下文在描述‘空间分配’问题时，都是只关注虚拟地址空间的分配。因此，在讨论空间分配问题的时候，.bss section也是需要考虑的。</p>
<h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p>上述A片段在编译之后的obj文件中会有.text, .data, .bss等section； 同样的，B片编译后产生的obj文件中也会有.text, .data, .bss等section。如何将A.obj和B.obj一起存放到输出文件中？这个是链接器需要解决的问题。<br>现代链接器通常都会采用‘相似段合并’的策略，即A.obj中的.text section与B.obj中的.text section合并成为输出文件中的.text section。同样的，.data section和.bss section也会有这样一个相似段合并的过程。</p>
<h3 id="两步链接法"><a href="#两步链接法" class="headerlink" title="两步链接法"></a>两步链接法</h3><p>采用了相似段合并的链接器，一般会采用一种‘两步链接法’：</p>
<ol>
<li><p>分配空间与地址： </p>
<ul>
<li>扫描所有输入文件，获取它们各个section的长度、属性和位置</li>
<li>获取所有输入文件中的符号表中的符号定义和符号引用，并统一放到一个全局符号表中</li>
<li>计算出输出文件中各个section所需的长度和对应的位置，并将记录输入文件中的各个section的映射关系</li>
</ul>
</li>
<li><p>符号解析和重定位：</p>
<ul>
<li>读取输入文件中section中的数据和重定位信息</li>
<li>进行符号解析、重定位、调整地址</li>
</ul>
</li>
</ol>
<h3 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h3><p>ld a.o b.o -e main -o ab</p>
<p>其中，-e声明了入口函数的名字， “-o ab”声明了输出文件的名字</p>
<h3 id="链接后的地址变化"><a href="#链接后的地址变化" class="headerlink" title="链接后的地址变化"></a>链接后的地址变化</h3><p>a.o: 通过objdump -h a.o查看信息<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000055  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  00000095  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000095  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000002b  0000000000000000  0000000000000000  00000095  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000c0  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000c0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000e0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure></p>
<p>b.o: 通过objdump -h b.o查看信息：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">b.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  00000090  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000094  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000002b  0000000000000000  0000000000000000  00000094  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000bf  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000c0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000e0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure></p>
<p>在链接之前，a.o的各个section,其VMA都是0，对应的，b.o也是。但是在链接之后，我们可以看下ab文件的内容： objdump -h ab<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ab:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .note.gnu.property 00000020  00000000004001c8  00000000004001c8  000001c8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .text         00000040  0000000000401000  0000000000401000  00001000  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  2 .eh_frame     00000058  0000000000402000  0000000000402000  00002000  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .data         00000004  0000000000404000  0000000000404000  00003000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  4 .comment      0000002a  0000000000000000  0000000000000000  00003004  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure></p>
<p>在链接之后，可执行文件的VMA地址已经确定下来。并且这个VMA地址是可执行文件在装载完成进入运行时后会对应的虚拟地址空间的地址。在这里可以看到，.text的VMA地址是0000000000401000，这个应该是约定好的x86-64系统中可执行文件的入口地址。</p>
<h3 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h3><p>两步链接法中的第二部，是在各个section的VMA确定之后，开始确定各个符号的虚拟地址。<br>各个符号在各自的section的偏移地址是确定的(这个信息很重要)，因此，在我们的例子中，‘main’、‘shared’、‘swap’的地址可以通过section+内部偏移的方式计算出来。</p>
<h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>必须以例子才能讲明白重定位的过程。<br>在链接发生之前，a.o的内容，可以通过 objdump -d a.o 来反汇编查看其中的逻辑：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64                                         # 不太明白</span><br><span class="line">   4:   55                      push   %rbp                                     # 这一行和下面的一行是在初始化栈帧。rbp在上，rsp在下。上面为高地址，下面为低地址</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   48 83 ec 10             sub    $0x10,%rsp                               # 0x10对应10进制中的16，这里将rsp下移16是为了给main函数分配栈空间。其实这里main函数根本不需要在栈上申请空间（没有局部变量），</span><br><span class="line">                                                                                # 至于为啥这里还要再申请16字节的栈，可能有什么特别的原因。搞不太明白</span><br><span class="line">   c:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)                         # 将rbp[-4]的值设置成100(0x64)，由于rbp是在最上面的，rbp[-4]其实就是: int a = 100;</span><br><span class="line">  13:   48 8d 45 fc             lea    -0x4(%rbp),%rax                          # 将rpb[-4]的地址记录在rax中。上面说过rbp[-4]是a，所以这里取地址就是对应于 &amp;a</span><br><span class="line">  17:   48 8d 35 00 00 00 00    lea    0x0(%rip),%rsi        # 1e &lt;main+0x1e&gt;   # 将rip[0]的地址记录在rsi中。rip寄存器记录的是当前执行位置，生成的注释中也说明了，当前的执行位置为&lt;main+0x1e&gt;</span><br><span class="line">                                                                                # rip[0]这个地址是什么呢？其实这个例子中编译器也猜不出来，这里就随便用了rip[0]来代表swap函数的shared参数（rsi一般用来记录参</span><br><span class="line">                                                                                # 数）。这个就是后面着重要介绍的符号重定位</span><br><span class="line">  1e:   48 89 c7                mov    %rax,%rdi                                # 上面我们说了，rax这里记录的是&amp;a，所以这里是为了提供swap函数的另一个参数： &amp;a</span><br><span class="line">  21:   b8 00 00 00 00          mov    $0x0,%eax                                # 清空eax。eax一般用来在函数中记录返回值</span><br><span class="line">  26:   e8 00 00 00 00          callq  2b &lt;main+0x2b&gt;                           # 这里就去调用swap函数了。这里调用的地址是&lt;main+0x2b&gt;。这里这样记录地址，也是后面需要着重介绍的符号重定位</span><br><span class="line">  2b:   b8 00 00 00 00          mov    $0x0,%eax                                # 这里就设置main函数的返回值了，默认是0</span><br><span class="line">  30:   c9                      leaveq </span><br><span class="line">  31:   c3                      retq</span><br></pre></td></tr></table></figure></p>
<p>我们再看一下链接之后的反汇编代码：<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ab:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;main&gt;:</span><br><span class="line">  401000:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401004:	55                   	push   %rbp</span><br><span class="line">  401005:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  401008:	48 83 ec 10          	sub    $0x10,%rsp</span><br><span class="line">  40100c:	c7 45 fc 64 00 00 00 	movl   $0x64,-0x4(%rbp)</span><br><span class="line">  401013:	48 8d 45 fc          	lea    -0x4(%rbp),%rax                                   # 这里还是&amp;a</span><br><span class="line">  401017:	48 8d 35 e2 2f 00 00 	lea    0x2fe2(%rip),%rsi        # 404000 &lt;shared&gt;        # 这个生成的汇编注释都说了，这里是在&amp;shared。至于这里的地址‘404000’，应该是shared这个变量在.data section中的 </span><br><span class="line">                                                                                            # 地址。也就是说，这里已经发生了重定位了</span><br><span class="line">  40101e:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401021:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401026:	e8 07 00 00 00       	callq  401032 &lt;swap&gt;                                     # 这里重定位之后，也已经替换成&lt;swap&gt;了。401032，恰好就是下面的swap在.text section中的起始地址</span><br><span class="line">  40102b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401030:	c9                   	leaveq </span><br><span class="line">  401031:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401032 &lt;swap&gt;:</span><br><span class="line">  401032:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401036:	55                   	push   %rbp</span><br><span class="line">  401037:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  40103a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)</span><br><span class="line">  40103e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)</span><br><span class="line">  401042:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">  401046:	8b 10                	mov    (%rax),%edx</span><br><span class="line">  401048:	48 8b 45 f0          	mov    -0x10(%rbp),%rax</span><br><span class="line">  40104c:	8b 00                	mov    (%rax),%eax</span><br><span class="line">  40104e:	31 c2                	xor    %eax,%edx</span><br><span class="line">  401050:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">  401054:	89 10                	mov    %edx,(%rax)</span><br><span class="line">  401056:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">  40105a:	8b 10                	mov    (%rax),%edx</span><br><span class="line">  40105c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax</span><br><span class="line">  401060:	8b 00                	mov    (%rax),%eax</span><br><span class="line">  401062:	31 c2                	xor    %eax,%edx</span><br><span class="line">  401064:	48 8b 45 f0          	mov    -0x10(%rbp),%rax</span><br><span class="line">  401068:	89 10                	mov    %edx,(%rax)</span><br><span class="line">  40106a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax</span><br><span class="line">  40106e:	8b 10                	mov    (%rax),%edx</span><br><span class="line">  401070:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">  401074:	8b 00                	mov    (%rax),%eax</span><br><span class="line">  401076:	31 c2                	xor    %eax,%edx</span><br><span class="line">  401078:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">  40107c:	89 10                	mov    %edx,(%rax)</span><br><span class="line">  40107e:	90                   	nop</span><br><span class="line">  40107f:	5d                   	pop    %rbp</span><br><span class="line">  401080:	c3                   	retq</span><br></pre></td></tr></table></figure></p>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>ELF文件通过重定位表来说明那些section中的哪些符号需要如何重定位。每个需要被重定位的section都有一个对应的重定位表。而重定位表通常也是ELF文件中的一个单独的section： 举个例子，加入.text section需要重定位，那会存在一个对应的.rel.text section, 这个.rel.text section就是一个重定位表。可以通过命令objdump -r a.o来查看一个目标文件的重定位表信息:<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:                                   // .text说明要被重定位的符号是在.text section中</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">000000000000001a R_X86_64_PC32     shared-0x0000000000000004     // offset表示了这个要被重定位的符号现在在哪里</span><br><span class="line">0000000000000027 R_X86_64_PLT32    swap-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p>
<p>这个命令列出了a.o的所有需要重定位的符号。上面的这个例子中就包括： .text section中的两个外部符号shared和swap，.eh_frame中的一个符号.text。</p>
<h3 id="符号的解析"><a href="#符号的解析" class="headerlink" title="符号的解析"></a>符号的解析</h3><p>简单来说，就是要让程序找到某个符号存储在哪里。举个例子，上面的重定位过程中，重定位表是记录了重定位前符号的offset的，但是重定位后符号的位置是会发生改变的，因此链接器就需要确定这个符号的地址改变后会在哪里。<br>链接器是怎么做的呢？链接器会先去找全局符号表，如果发现有这个符号，但是符号是未定义的，说明这个符号等待被重定位。如果没找到，那链接器就会报错。</p>
<h3 id="指令的修正方式"><a href="#指令的修正方式" class="headerlink" title="指令的修正方式"></a>指令的修正方式</h3><p>我们上面通过objdump -r a.o查看重定位表的时候，有一个信息，即TYPE那一栏中，有R_X86_64_PC32/R_X86_64_PLT32这样的信息。这个就是代表指令的修正方式。这部分的内容涉及到CPU指令的寻址方式。<br>R_X86_64_PC32： 相对寻址修正 S+A-P。其中，A代表‘保存在被修正位置的值’， P代表‘被修正的位置（即offset）’，S代表‘符号的实际地址（即该重定位入口的符号在符号表中的下标）’<br>修正的具体方式，还得参考下芯片手册。</p>
<h2 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h2><h3 id="链接器控制脚本"><a href="#链接器控制脚本" class="headerlink" title="链接器控制脚本"></a>链接器控制脚本</h3><p>要控制链接器的行为一般有3中方案：</p>
<ul>
<li>给链接命令设置命令行参数，比如ld链接器的-o, -e参数等等</li>
<li>将链接的命令存放在obj文件中，编译器负责将命令传递给链接器。windows平台的COFF文件中会这么用</li>
<li>使用链接器控制脚本。这是本节重点介绍的内容</li>
</ul>
<h3 id="查看默认的链接器脚本"><a href="#查看默认的链接器脚本" class="headerlink" title="查看默认的链接器脚本"></a>查看默认的链接器脚本</h3><p>使用命令 ld -verbose可以查看默认的链接器脚本内容。这个脚本的内容有点多，一般可以取目录/usr/lib/ldscripts下面看到源文件。<br>我们可以在调用ld命令的时候显式声明我们自定义的链接器脚本文件：  ld -T link.script</p>
<h3 id="最小的程序"><a href="#最小的程序" class="headerlink" title="最小的程序"></a>最小的程序</h3><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">char* str = &quot;Hello World!\n&quot;;</span><br><span class="line"></span><br><span class="line">void print() &#123;</span><br><span class="line">  asm(&quot;movl $13, %%edx \n\t&quot;</span><br><span class="line">    &quot;movl %0, %%ecx \n\t&quot;</span><br><span class="line">    &quot;movl $0, %%ebx \n\t&quot;</span><br><span class="line">    &quot;movl $4, %%eax \n\t&quot;</span><br><span class="line">    &quot;int $0x80 \n\t&quot;</span><br><span class="line">    ::&quot;r&quot;(str):&quot;edx&quot;, &quot;ecx&quot;, &quot;ebx&quot;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exit() &#123;</span><br><span class="line">  asm(&quot;movl $42, %ebx \n\t&quot;</span><br><span class="line">    &quot;movl $1, %eax \n\t&quot;</span><br><span class="line">    &quot;int $0x80 \n\t&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void nomain() &#123;</span><br><span class="line">  print();</span><br><span class="line">  exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法： gcc -fno-builtin -c test.c -m32<br>链接方法： ld -static -e nomain test.o -o test -m elf_i386</p>
<h3 id="链接器脚本编写"><a href="#链接器脚本编写" class="headerlink" title="链接器脚本编写"></a>链接器脚本编写</h3><p>我们现在为上面的代码编写一个TinyHelloWorld.lds链接器脚本。<br><figure class="highlight plain">
    <div class="code-block-header" lang="plain">
      <span class="copy-code">COPY</span>
    </div>
    <table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(nomain) </span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  . = 0x08048000 + SIZEOF_HEADERS;</span><br><span class="line">  tinytext : &#123; *(.text) *(.data) *(.rodata) &#125;</span><br><span class="line">  /DISCARD/ : &#123; *(.comment) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三句话的含义：</p>
<ol>
<li>. = 0x08048000 + SIZEOF_HEADERS: 将当前虚拟地址设置成0x08048000 + SIZEOF_HEADERS。SIZEOF_HEADERS这个变量代表输出文件的文件头大小。‘.’表示当前虚拟地址。这样设置之后，下一句话的地址就会变成我们设置过的0x08048000 + SIZEOF_HEADERS了</li>
<li>tinytext: { <em>(.text) </em>(.data) *(.rodata) }: 这第二条语句定义了一个section的转换规则，这里是将.text, .data, .rodata三个section依次合并到输出文件的.tinytext section中</li>
<li>/DISCARD/ : { *(.comment) }： 这第三句话定义了一个丢弃规则，这里是将输入文件中名为.comment的section内容丢弃，不拼接到输出文件中。</li>
</ol>
<p>定义好lds之后，我们就可以这样链接了：<br>ld -static -T TinyHelloWorld.lds -o test test.o</p>
<h3 id="链接器脚本语法"><a href="#链接器脚本语法" class="headerlink" title="链接器脚本语法"></a>链接器脚本语法</h3><p>链接器脚本有两种语句：</p>
<ol>
<li>命令语句</li>
<li>赋值语句<br>语句之间使用分号作为分隔符。有表达式与运算符，比如+,-,<em>,/,+=,</em>=,&amp;,|,&gt;&gt;,&lt;&lt;等等。可以使用注释，与C语言类似，使用/**/注释。<br>命令语句略微复杂一些。上面的例子中的ENTRY(nomain)就是一个命令语句。同理，SECTIONS{}也是一个命令语句。<br>常用的命令语句包括：</li>
</ol>
<ul>
<li>ENTRY(symbol)</li>
<li>STARTUP(filename)</li>
<li>SEARCH_DIR(path)</li>
<li>INPUT(file, file,…)</li>
<li>INCLUDE filename</li>
<li>PROVIDE(symbol): 在链接脚本中定义某个符号，定义的符号可以在程序中被引用。</li>
</ul>
<p>SECTION命令的语法为：<br>SECTIONS<br>{<br>  …<br>  secname : {contents}<br>  …<br>}</p>
<p>其中，secname表示输出section的名字，后面必须接一个空格符，这样可以保证提供的输出section名字不会有歧义。后面必须紧跟着冒号和大括号。大括号里面的contents描述了一套规则和条件： 所有符合这种条件和规则的输入section都会合并到secname中。secname的命名方法必须符合输出文件的格式要求。<br>上面出现了一个特殊的输出section名字： /DISCARD/，如果使用这个名字作为输出section的名字，那么所有符合后面定义的规则的输入section都会被丢弃，不编排到输出文件中。</p>
<p>从上面的描述可以看出，关键的内容还是contents这个描述规则和条件的内容。contents中可以包含多个条件，每个条件之间以空格隔开，如果输入section满足任何一个条件都可以被编排到输出文件中。contents的写法如下：<br>filename(sections)<br>其中，filename代表输入文件名，sections代表输入section的名字。神奇的是，这个匹配规则可以使用正则:-)<br>比如：  [a-z]<em>(.text</em>[A-Z])</p>
<h3 id="BFD库"><a href="#BFD库" class="headerlink" title="BFD库"></a>BFD库</h3><p>简单来说，BFD(Binary File Descriptor library)库是一个GNU项目，目标是希望通过一种统一的接口来处理不同的目标文件格式。BFD本身是binutils项目的一个子项目。目前GNU的多个项目，包括汇编器gas,链接器ld，调试器gdb，binutils底层都是使用的BFD库。Ubuntu下BFD库有一个C语言开发库叫binutils-dev。</p>
</div>
  
  <div class="article-end">
    
    <div class="article-meta">
      
      
      <div class="article-tags">
        <div class="article-tags-name">Tags: </div>
        
        <a class="article-tags-item" href="/tags/books/">
          books
        </a>
        
      </div>
      
    </div>
    
    

<div class="post-copyright">
  <div class="post-copyright-icon"><svg class="copyright-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
  <path d="M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm117.134 346.753c-1.592 1.867-39.776 45.731-109.851 45.731-84.692 0-144.484-63.26-144.484-145.567 0-81.303 62.004-143.401 143.762-143.401 66.957 0 101.965 37.315 103.422 38.904a12 12 0 0 1 1.238 14.623l-22.38 34.655c-4.049 6.267-12.774 7.351-18.234 2.295-.233-.214-26.529-23.88-61.88-23.88-46.116 0-73.916 33.575-73.916 76.082 0 39.602 25.514 79.692 74.277 79.692 38.697 0 65.28-28.338 65.544-28.625 5.132-5.565 14.059-5.033 18.508 1.053l24.547 33.572a12.001 12.001 0 0 1-.553 14.866z" />
</svg></div>
  <div class="post-copyright-author">
    <span class="post-copyright-meta">Authorship: </span>
    <span class="post-copyright-info">
      <a href="http://zivyou.github.io">zivyou</a>
    </span>
  </div>
  <div class="post-copyright-type">
    <span class="post-copyright-meta">Article Link: </span>
    <span class="post-copyright-info">
      <a href="http://zivyou.github.io/2021/08/01/%E6%97%A7%E4%B9%A6%E6%96%B0%E8%AF%BB-%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B/">http://zivyou.github.io/2021/08/01/%E6%97%A7%E4%B9%A6%E6%96%B0%E8%AF%BB-%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B/</a>
    </span>
  </div>
  <div class="post-copyright-notice">
    <span class="post-copyright-meta">Copyright: </span>
    <span class="post-copyright-info">All posts on this blog are licensed under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> license unless otherwise stated. Please cite <a href="http://zivyou.github.io" target="_blank">zivyou</a> !</span>
  </div>
</div>

  </div>
</article>
      </main>
      <aside tabindex="-1">
  
  <div class="sidebar-block sidebar-sticky toc-wrap" tabindex="-1">
    <div class="toc-btn">
      <svg class="toc-btn-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z"></path>
  <path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z"></path>
</svg>
    </div>
    <div class="sidebar-title toc-title">Catalog</div>
    <div class="sidebar-body">
      <ul class="toc-list">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">编译与链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96"><span class="toc-number">1.1.3.</span> <span class="toc-text">汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.4.</span> <span class="toc-text">链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%89%8D%E7%AB%AF"><span class="toc-number">1.2.</span> <span class="toc-text">编译器前端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">词法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">语法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.2.3.</span> <span class="toc-text">中间代码生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%90%8E%E7%AB%AF"><span class="toc-number">1.3.</span> <span class="toc-text">编译器后端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">代码生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">目标代码优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">　链接器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">目标文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#text-section"><span class="toc-number">2.2.1.</span> <span class="toc-text">.text section</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-section-rodata-section"><span class="toc-number">2.2.2.</span> <span class="toc-text">.data section &#x2F; .rodata section</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bss-section"><span class="toc-number">2.2.3.</span> <span class="toc-text">.bss section</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89section"><span class="toc-number">2.2.4.</span> <span class="toc-text">自定义section</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">ELF文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4%EF%BC%88File-header%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">文件头（File header）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section%E8%A1%A8-section-header-table"><span class="toc-number">2.3.2.</span> <span class="toc-text">section表(section header table)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8-Relocation-Table"><span class="toc-number">2.3.3.</span> <span class="toc-text">重定位表(Relocation Table)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">字符串表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7"><span class="toc-number">2.4.</span> <span class="toc-text">符号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">符号表结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7"><span class="toc-number">2.4.2.</span> <span class="toc-text">特殊符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">2.4.3.</span> <span class="toc-text">符号修饰和函数签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="toc-number">2.4.4.</span> <span class="toc-text">extern “C”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">静态链接过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D"><span class="toc-number">3.1.</span> <span class="toc-text">空间与地址分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%8D%A0%E7%94%A8%E4%B8%8E%E5%88%86%E9%85%8D"><span class="toc-number">3.1.1.</span> <span class="toc-text">空间占用与分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E6%AE%B5%E5%90%88%E5%B9%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">相似段合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%AD%A5%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">两步链接法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.4.</span> <span class="toc-text">链接命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%90%8E%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E5%8C%96"><span class="toc-number">3.1.5.</span> <span class="toc-text">链接后的地址变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%9C%B0%E5%9D%80%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">3.1.6.</span> <span class="toc-text">符号地址的确定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.2.</span> <span class="toc-text">符号解析与重定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">重定位表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">3.2.3.</span> <span class="toc-text">符号的解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BF%AE%E6%AD%A3%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">指令的修正方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">链接过程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC"><span class="toc-number">3.3.1.</span> <span class="toc-text">链接器控制脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E9%93%BE%E6%8E%A5%E5%99%A8%E8%84%9A%E6%9C%AC"><span class="toc-number">3.3.2.</span> <span class="toc-text">查看默认的链接器脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">最小的程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99"><span class="toc-number">3.3.4.</span> <span class="toc-text">链接器脚本编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.3.5.</span> <span class="toc-text">链接器脚本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFD%E5%BA%93"><span class="toc-number">3.3.6.</span> <span class="toc-text">BFD库</span></a></li></ol></li></ol></li></ol>
      </ul>
    </div>
  </div>
  
</aside>
    </div>
    
    

<footer class="footer main-width">
  <div class="copyright">
    &copy; 2020 - 2024
    zivyou
  </div>
  <div class="framework-info">
    <span>Framework</span>
    <a href="https://hexo.io" target="_blank">Hexo</a>
    <span class="footer-separator">|</span>
    <span>Theme</span>
    <a href="https://github.com/Lete114/hexo-theme-MengD" target="_blank">MengD</a>
  </div>
  
  <div class="custom">A clean and lightweight Hexo theme</div>
  
</footer>
  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</body>

</html>